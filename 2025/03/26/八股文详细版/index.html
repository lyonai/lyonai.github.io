<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>八股文详细版 | Lyon`s Blog</title><meta name="keywords" content="面试,Java,八股文,后端,网络编程,多线程,数据库,设计模式,操作系统,计算机网络,场景题,尚硅谷"><meta name="author" content="lyon ai"><meta name="copyright" content="lyon ai"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="八股文详细版"><meta name="application-name" content="八股文详细版"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="八股文详细版"><meta property="og:url" content="http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/index.html"><meta property="og:site_name" content="Lyon`s Blog"><meta property="og:description" content="Java基础 100%JAVASE1、写出Java的四类八种基本数据类整数                      byte short int long 小数(浮点)             float double 布尔                      boolean 字符"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA"><meta property="article:author" content="lyon ai"><meta property="article:tag" content="编程"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA"><meta name="description" content="Java基础 100%JAVASE1、写出Java的四类八种基本数据类整数                      byte short int long 小数(浮点)             float double 布尔                      boolean 字符"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://lyonai-github-io.vercel.app/',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: lyon ai","link":"链接: ","source":"来源: Lyon`s Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Lyon`s Blog',
  title: '八股文详细版',
  postAI: '',
  pageFillDescription: 'Java基础 100%, JAVASE, 1、写出Java的四类八种基本数据类, 2、amp 和 ampamp 的区别x20, 3、switch的参数可以是什么类型, 4、说出实例变量和局部变量的区别, 5、static关键字都能修饰什么？ 都有什么特点, 6、overload和override的区别, 7、 final 和 finally的区别, 8、 this和super都能用到哪些地方, 9、 接口与抽象类的区别, 10、 静态变量与实例变量的区别, 11、throw和throws 的区别, 12、StringStringBuilder 与 StringBuffer 的区别, 13、 x3Dx3D 和 equals的区别, 14、包装类拆箱装箱, 15、异常结构图, 16、 HashSet 的去重原理, 17、集合与数组的区别, 18、多线程的五种实现方式, 19、多线程的生命周期, 20、TreeSet和HashSet的区别, 21、所学习的io流一共分为几类, 22、map的三种遍历方式, 23、HashMap与HashTable 的区别, 24、ArrayList和LinkedList的区别, 25、什么是反射, 26、深拷贝和浅拷贝, 集合类, 1、Java集合框架是什么?说出集合框架的一些优点?, 2、集合接口的常见实现类, 3、List和Map区别?, 4、List、Map、Set三个接口存取元素时各有什么特点?, 5、为什么Map接口不继承Collection接口?, 6、Iterator和ListIterator之间有什么区别?, 7、集合框架中的泛型有什么优点?, 8、Map接口提供了哪些不同的集合视图?, 9、jdk1.7HashMap, 10、jdk1.8HashMap, 11、JDK8中的HashMap为什么要使用红黑树？, 12、JDK8中的HashMap什么时候将链表转化为红黑树？, 13、JDK7与JDK8中HashMap的不同点？, 14、jdk1.7ConcurrentHashMap, 15、jdk1.8ConcurrentHashMap, 16、jdk1.7ConcurrentHashMap如何保证并发, 17、jdk1.8ConcurrentHashMap如何保证并发, Java高级-建议会, JVM, １、说一下JVM的主要组成部分？及其作用？, 2、说一下JVM运行时数据区？, 3、什么是类加载器？, 4、双亲委派模型, ５、说一下类装载的执行过程？, ６、怎么判断对象是否可以被回收？, 7、哪些对象可以作为GC-Roots, 8、Java中都有哪些引用类型？, 9、说一下JVM有哪些垃圾回收算法？, 10、说一下JVM有哪些垃圾回收器？, 11、详细介绍一下CMS垃圾回收器？, 12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？, 13、简述分代垃圾回收器是怎么工作的？, 14、垃圾回收器的比较, 15、三色标记, 写屏障 + 增量更新（IU）, 写屏障 + 原始快照（SATB）, 16、说一下JVM调优的工具？, 17、常用的JVM调优的参数都有哪些？, 18、你能保证GC执行吗？, 19、怎么获取Java程序使用的内存？堆使用的百分比？, 设计模式, 1 、什么是设计模式？有什么好处？, 2、 设计模式的7大基本原则有哪些？, 3 、使用哪种设计模式可以提高代码可维护性？, 4、 使用哪种设计模式可以提高代码的复用性？, 5 、你在工作中是如何使用设计模式的？, 6、单例模式的多种写法, 7、 如何破坏单例模式？, 8 、为什么说枚举是实现单例最好的方式？, 9 、不使用锁如何实现线程安全的单例？, 10、什么是享元模式有哪些具体应用？, Java框架 –必会100%, MyBatis, 1、Mybatis中和$的区别？, 2、Mybatis的编程步骤是什么样的？, 3、JDBC编程有哪些不足之处MyBatis是如何解决这些问题的？, 4、使用MyBatis的mapper接口调用时有哪些要求？, 5、Mybatis中一级缓存与二级缓存？, 6、MyBatis在insert插入操作时如何返回主键ID？, 7、简述 Mybatis 的插件运行原理如何编写一个插件, Spring、SpringMVC、SpringBoot, 1. 什么是 Spring IOC 容器？, 2. 如何实现一个Spring容器, 3. 什么是依赖注入？可以通过多少种方式完成依赖注入？, 4. BeanFactory 和 ApplicationContext的区别？, 5. 构造函数注入和 setter 注入, 6. spring 提供了哪些配置方式？, 7. Spring 中的 bean 的作用域有哪些?, 8. 深入谈谈对Ioc的理解？, 9. 将一个类声明为Spring的 bean 的注解有哪些?, 10. Spring 中的 bean 生命周期?, 11.什么是bean的自动装配有哪些方式？, 12. Spring中出现同名bean怎么办？, 13. Spring 怎么解决循环依赖问题？, 什么是循环依赖, 如何解决循环依赖：, 14. Spring 中的单例 bean 的线程安全问题？, 15. 什么是 AOP？, 16. 谈谈对Aop的理解, 17. AOP 有哪些实现方式？, 18. Spring 框架中用到了哪些设计模式？, 19. Spring 事务实现方式有哪些以及原理, 20. Spring事务的隔离级别, 21. Spring事务定义的传播规则, 22. Spring事务什么时候会失效, 23. SpringMVC 工作原理了解吗?, 24. 简单介绍 Spring MVC 的核心组件, 25. @Controller 注解有什么用？, 26. @RestController 和 @Controller 有什么区别？, 27. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？, 28. @RequestParam 和 @PathVariable 两个注解的区别, 29. 返回 JSON 格式使用什么注解？, 30. 什么是springmvc拦截器以及如何使用它？, 31. 为什么要用SpringBoot?, SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。, 32.Spring Boot 自动配置原理？, 33. Spring Boot中如何实现对不同环境的属性配置文件的支持？, 34. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？, 35. 你如何理解 Spring Boot 中的 Starter？, 36. Spring Boot Starter 的工作原理是什么？, 37. 什么是嵌入式服务器？为什么要使用嵌入式服务器?, SpringCloud, 1、spring cloud断路器的作用是什么？, 2、spring cloud的核心组件有哪些以及作用, 3、spring 如何注册cloud服务？, 4、微服务优点是什么？, 5、微服务的缺点是什么？, 6、Spring Cloud Bus是什么?, 7、什么是服务熔断？什么是服务降级？, 8、负载均衡的意义是什么？, 9、SpringBoot和SpringCloud有什么联系和区别？, JUC–必会100%, 什么是线程池线程池有哪些？, （1）newCachedThreadPool, （2）newFixedThreadPool, （3）newSingleThreadExecutor, （4）newScheduleThreadPool, ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点], 参数与作用：共7个参数, 线程池大小设置：, 拒绝策略：, 常见线程安全的并发容器有哪些？, Atomic原子类了解多少？原理是什么？, synchronized底层实现是什么？lock底层是什么？有什么区别？, Synchronized原理：, Lock原理：, Lock与synchronized的区别, 数据库 –100%, MySQL–100%, 1、对MySQL数据库去重的关键字是什么？, 2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？, 3、索引的基本原理, 4、说一下索引的优势和劣势？, 5、MySQL聚簇和非聚簇索引的区别, 6、MySQL索引的数据结构各自优劣, 7、MySQL索引的设计原则, 8、MySQL中B+树和B树的区别, 9、MySQL中的锁类型有哪些？, 10、MySQL什么是死锁？怎么解决？, 11、MySQL的约束有哪些？, 12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？, 13、MySQL事务的基本特性和隔离级别, 14、MySQL中ACID靠什么保证的？, 15、MySQL中的MVCC是什么？, 16、UNION和UNION ALL的区别？, 17、主键使用自增ID还是UUID为什么？, 18、MySQL数据库cpu飙升的话要怎么处理呢？, 19、什么是存储过程？有哪些优缺点？, 20、了解什么是表分区吗？表分区的好处有哪些？, 21、MySQL主从同步原理, 22、简述MyISAM和InnoDB的区别, 23、简述MySQL中索引类型及对数据库的性能的影响, 24、MySQL执行计划怎么看, 25、MySQL常见优化手段, 网络–60%, Netty–不看（快速学）, 1 为什么Netty适合做网络编程？, 2 Netty性能好的原因是什么？, 3 Netty的零拷贝是怎么实现的？, 4 能不能说一说Netty的无锁化设计？, 5 Netty的线程模型是怎么样的？, 6 Netty如何解决TCP粘包、拆包的问题的？, 7 Netty的Buffer为什么好用, 8 说说 Netty 的对象池技术？, 9 Netty有哪些序列化协议？, 10 Netty 中用了哪些设计模式？, Tomcat 100%, 1、Tomcat的缺省端口是多少怎么修改？, 2、tomcat 有哪几种Connector 运行模式(优化)？, 3、Tomcat有几种部署方式？, 4、tomcat容器是如何创建servlet类实例？用到了什么原理？, 5、tomcat 如何优化？, 6、熟悉tomcat的哪些配置？, 计算机网络 -选择（原理必须搞清楚）选择性学习, 1、介绍一下OSI七层模型？, 2、什么是TCP的粘包、拆包, 3、ARP 与 RARP 的区别是什么？, 4、路由器与交换机的区别是什么？, 5、什么是TCP三次握手、四次挥手？, 6、TCP是如何保证可靠传输的？, 7、基于UDP实现一个TCP协议, 8、为什么需要HTTPx2F2他解决了什么问题？, 9、HTTPx2F2存在什么问题为什么需要HTTPx2F3？, 10、CookieSessionToken的区别是什么？, 11、HTTPS只是比HTTP安全吗？, 12、浏览器输入www.baidu.com回车之后发生了什么, 13、对称加密和非对称加密有什么区别？, 14、简单介绍一下DNS？, 15、ping的原理是什么？, 16、什么是IPV6？和IPV4有什么区别？, 17、什么是正向代理和反向代理？, 18、什么是跨域访问问题如何解决？, 19、什么是CDN为什么他可以做缓存？, 消息队列, RabbitMQ –Kafaka, 1、简述RabbitMQ的架构设计, 2、介绍一下RabbitMQ有几种工作模式？, 3 、RabbitMQ如何确保消息发送 ？ 消息接收？, 4、RabbitMQ事务消息, 5、RabbitMQ如何实现延迟消息？, 6、RabbitMQ如何保证消息的顺序性？, 7、如何使用RabbitMQ解决分布式事务？, 8、如何防止RabbitMQ消息重复消费？, 9、如何解决消息队列的延时以及过期失效问题?消息队列满了之后该如何处理?有几百万的消息持续积压几小时说说如何解决?, 分布式, Cloud核心中间件100%, 一、Nacos, 1、注册中心如何选型？, 2、什么是Nacos主要用来作什么？, 3、Nacos是AP的还是CP的？, 4、Nacos如何实现的配置变化客户端可以感知到？, 5、Nacos能同时实现AP和CP的原理是什么？, 6、Nacos服务发现的原理, 7、Nacos注册中心原理, 二、Feign, Feign的调用原理：, Feign+Nacos注册中心原理：, Feign的底层调用源码大致流程, 远程调用的本质：, ElasticSearch, 1 、为什么要使用ElasticSearch？, 2 、ElasticSearch为什么快？, 3 、倒排索引是什么？, 4 、如何保证ES和数据库的数据一致性？, 微服务、分布式100%, 1、分布式和微服务的区别是什么？, 2、什么是微服务架构？优势？特点？, 3、负载均衡算法、类型, 4、分布式架构下Session 共享有什么方案, 5、CAP理论BASE理论, 6、分布式Id生成方案, 7、分布式锁的解决方案, 8、实现一个分布式锁需要考虑哪些问题？, 9、什么是分布式事务, 10、分布式事务解决方案, 11、 什么是TCC和2PC有什么区别？, 12、什么是柔性事务？, 13、如何基于本地消息表实现分布式事务？, 14、什么是Seata？他有哪几种模式？, 15、如何实现接口的幂等性, 1、token 机制, 2、各种锁机制, 3、各种唯一约束, 4、表防重, 16、微服务架构的服务治理有哪些实现方案？, 线程、并发100%, 1、什么是并发？, 2、并发和并行有什么区别？, 3、为什么要使用并发？, 4、并发编程有哪些缺点？, 5、上下文切换是什么？, 6、使用多线程可能会带来什么问题？, 7、简要总结线程与进程的关系？, 8、sleep()、wait()、join()、yield()的区别, 9、谈谈对线程安全的理解, 10、Thread和Runnable的区别, 11、谈谈对守护线程的理解, 12、ThreadLocal的原理和使用场景, 13、ThreadLocal内存泄露原因如何避免, 14、并发的三大特征, 15、JMM内存模型, 16、JVM存在的必要性, 17、谈谈Volatile关键字的理解, 1、验证可见性, 2、验证有序性, 3、不具备原子性, 18、为什么用线程池？解释下线程池参数？, 19、JUC线程池的工作原理, 20、线程池的五种状态是如何流转的, 21 、线程池为什么一定得是阻塞队列？, 22、线程发生异常会被移出线程池吗？, 23、线程池的核心线程数、最大线程数该如何设置？, 24、Tomcat是如何自定义线程池的？, 25、volatile变量和atomic变量有什么区别？, 缓存, Redis–100%, 1 、Redis是AP的还是CP的？, 2 、介绍一下Redis的集群方案？, 3 、什么是Redis的数据分片？, 4 、Redis为什么这么快？, 5、 Redis 的事务机制是怎样的？, 6 、Redis的持久化机制是怎样的？, 7、 Redis 的过期策略是怎么样的？, 8 、Redis的内存淘汰策略是怎么样的？, 会进行淘汰的 7 种其他策略。, 9、 Redis的LRU算法, 10、 Redis的淘汰策略的选择, 11、 什么是热Key问题如何解决热key问题, 12、 什么是大Key问题如何解决？, 13、 什么是缓存击穿、缓存穿透、缓存雪崩？, 14、 什么情况下会出现数据库和缓存不一致的问题？, 15、 如何解决Redis和数据库的一致性问题？, 有并发（读、写）的情况下仍然会出现缓存数据和数据库数据不一致问题因此还需要通过缓存数据的失效机制+主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）, 16、 Redis如何实现延迟消息？, 17、 除了做缓存Redis还能用来干什么？, 18、 如何用SETNX实现分布式锁？, 19、 什么是RedLock他解决了什么问题？, 20、 如何用Redisson实现分布式锁？, 热门领域概念–了解, 云计算, 1、什么是云计算？, 2、什么是公有云、私有云、混合云？, 3、什么是IaaS、PaaS、SaaS？, 4、什么是Serverless？, 场景题, 场景题—理解, 1、如果你的业务量突然提升100倍QPS你会怎么做？, 2、让你设计一个订单号生成服务该怎么做?, 3、订单到期关闭如何实现, 4、如何设计一个购物车功能？, 5、每天100w次登录请求4C8G机器如何做JVM调优？, 6、不用redis分布式锁 如何防止用户重复点击？, 7、让你设计一个秒杀系统你会考虑哪些问题？, 8、如果让你实现消息队列会考虑哪些问题？, 9、库存扣减如何避免超卖和少卖？, 10、如何用Redis实现朋友圈点赞功能？, 11、Redis的zset实现排行榜实现分数相同按照时间顺序排序怎么做？, 12、如何实现查找附近的人功能？, 13、消息队列使用拉模式好还是推模式好？为什么？, 14、如果让你实现一个Dubbo会考虑用哪些技术解决哪些问题？, 15、Kafka单分区单消费者实例如何提高吞吐量, 16、一个订单在1100超时关闭但在1100也支付成功了怎么办？, 17、一个支付单多个渠道同时支付成功了怎么办？, 18、如何解决消息重复消费、重复下单等问题？, 19、你是如何进行SQL调优的？, 20、不使用synchronized和Lock如何设计一个线程安全的单例？, 21、索引失效的问题是如何排查的有那些种情况？, 22、40亿个QQ号限制1G内存如何去重？, 23、从B+树的角度分析为什么单表2000万要考虑分表？, 24、线上接口如果响应很慢如何去排查定位问题呢？, 25、怎么做数据对账？, 26、MySQL千万级大表如何做数据清理？, 27、为什么MySQL用B+树MongoDB用B树？, 28、高并发的积分系统在数据库增加积分怎么实现？, 29、MySQL热点数据更新会带来哪些问题？, 30、和外部机构交互如何防止被外部服务不可用而拖垮, 31、MySQL 里有 2000W 数据Redis 中只存 20W 的数据如何保证 Redis 中的数据都是热点数据?, 项目上线问题排查–工作经验, 1、RT飙高问题排查过程, 2、CPU飙高问题排查过程, 3、数据库连接池满排查过程, 4、数据库CPU被打满排查过程, 5、OOM问题排查过程, 6、频繁FullGC问题排查, 7、Arthas统计方法耗时的原理是什么？, 8、慢SQL问题排查, 9、Load飙高问题排查过程, 人事面试–情商, 一、请介绍一下你自己, 二、为什么来深圳找工作？, 三、你为什么离开原来的公司？, 四、你最大的缺点是什么？, 五、你未来3-5年的职业规划是怎样的？, 六、你对薪资的要求？, 七、什么时候能入职？, 八、介绍一个你认为最熟悉的项目（项目经理）, 九、如果公司录用你你将怎样开展工作？, 十、你还有什么问题问我吗？, 十一、社保问题, 十二、上家公司薪资构成及到手多少钱, 十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？, 十四、压力面试：, 十五、电话面试：, 十六、你对加班的看法？, 十七、你朋友对你的评价？, 十八、如果通过这次面试我们单位录用了你但工作一段时间却发现你根本不适合这个职位你怎么办？, 十九、在完成某项工作时你认为领导要求的方式不是最好的自己还有更好的方法你应该怎么做？, 二十、如果你的工作出现失误给本公司造成经济损失你认为该怎么办？, 二十一、如果你做的一项工作受到上级领导的表扬但你主管领导却说是他做的你该怎样？, 二十二、谈谈你对跳槽的看法？, 二十三、工作中你难以和同事、上司相处你该怎么办？, 二十四、假设你在某单位工作成绩比较突出得到领导的肯定。但同时你发现同事们越来越孤立你你怎么看这个问题？你准备怎么办？, 二十五、你对于我们公司了解多少？, 二十六、请说出你选择这份工作的动机？, 二十七、你最擅长的技术方向是什么？, 二十八、你能为我们公司带来什么呢？, 二十九、最能概括你自己的三个词是什么？, 三十、你的业余爱好是什么？, 三十一、作为被面试者给我打一下分？, 三十二、你怎么理解你应聘的职位？, 三十三、喜欢这份工作的哪一点？, 三十四、说说你对行业、技术发展趋势的看法？, 三十五、说你的家庭？, 三十六、就你申请的这个职位你认为你还欠缺什么？, 三十七、你欣赏哪种性格的人？, 三十八、你通常如何处理別人的批评？, 三十九、你为什么愿意到我们公司来工作？, 四十、你和别人发生过争执吗？你是怎样解决的？, 四十一、你做过的哪件事最令自己感到骄傲？, 四十二、对这项工作你有哪些可预见的困难？, 四十三、怎样对待自己的失敗？, 四十四、什么会让你有成就感？, 四十五、眼下你生活中最重要的是什么？, 四十六、与上级意见不一是你将怎么办？, 四十七、你工作经验欠缺如何能胜任这项工作？, 四十八、你希望与什么样的上级共事？, 四十九、谈谈如何适应办公室工作的新环境？, 五十、为了做好你工作份外之事你该怎样获得他人的支持和帮助？, 五十一、如果你在这次面试中没有被录用你怎么打算？, 五十二、谈谈你过去做过的成功案例？, 五十三、谈谈你过去的工作经验中最令你挫折的事情？, 五十四、为什么我们要在众多的面试者中选择你？, 五十五、你并非毕业于名牌院校？, 五十六、怎样看待学历和能力？, 五十七、工作中学习到了些什么？, 五十八、想过创业吗？, 五十九、除了本公司外还应聘了哪些公司？, 六十、面试注意事项：, 基础写出的四类八种基本数据类整数小数浮点布尔字符和的区别符号的左右两边无论真或假都要执行符号的左边如果为假符号的右边不再执行提高了代码的执行效率的参数可以是什么类型枚举说出实例变量和局部变量的区别物理位置成员变量类中方法外局部变量方法中或方法定义的小括号里面内存位置成员变量在堆内存中局部变量通常在栈内存中栈帧生命周期成员变量随着对象创建而产生随着对象的消失而消失局部变量随着方法的调用而产生随着方法调用结束而消失有无默认值成员变量有默认值整数小数字符布尔引用数据类型局部变量没有默认值使用的时候必须先赋值关键字都能修饰什么都有什么特点修饰成员变量叫静态变量具有共享性节省内存空间修饰方法静态方法可以直接使用类名进行调用修饰代码块静态代码块给静态变量进行赋值修饰类静态内部类和的区别是重载要求在同一个类中方法名相同参数列表不同与返回值类型无关参数列表不同表现在个数不同数据类型顺序不同数据类型不同是重写要求发生在子父级的继承关系中方法名相同参数列表相同返回值类型是父类返回值类型本身或其子类异常等于父类本身异常类型或小于父类本身异常把控细节构造方法不能被重写因为构造方法要求方法名与类名保持一致返回值父类子类异常父类子类和的区别是权限修饰符表示最终的能修饰变量方法和类修饰变量变成了常量修饰方法变成了最终的方法不能被重写但是可以被正常调用修饰类变成的最终的类不能有子类但是可以被正常创建对象是一个代码块只能与我们的代码块连用表示无论代码是否发生异常里面的代码都要执行强制退出两种方式把控细节都没有返回值有返回值有返回值有返回值和都能用到哪些地方访问成员变量可以区分成员变量与局部变量重名问题如果本类没有这个成员变量也可以调用父类的成员变量可以区分本类成员变量与父类成员变量重名问题只能调用父类的成员变量访问成员方法可以调用本类的成员方法如果本类没有这个成员方法也可以调用父类的成员方法只能调用父类的成员方法访问构造器可以通过或参数让其本类的构造方法直接相互调用子类通过或参数调用父类的构造方法接口与抽象类的区别把控细节抽象类例子抽象类和普通类基本没有区别只是多了一个可以定义抽象方法成员变量静态变量常量抽象类中静态方法有方法的实现抽象类中构造方法抽象类中实例方法抽象类中定义一个抽象方法注意没有方法实现体接口例子接口中不能定义静态方法但是可以有静态方法的实现接口中不可以定义构造方法接口中不可以定义实例方法没有也没有关键字接口中不能定义变量只能有常量接口中所有的默认方法都是修饰且访问修饰符必须要是或者不写不写则使用默认注意默认指的不是抽象类中的访问修饰符四种都可以不写允许接口中有方法的实现但是必须用关键字修饰静态变量与实例变量的区别内存位置静态变量在方法区中实例变量在堆内存中生命周期静态变量随着文件加载而产生随着文件结束而结束实例变量随着对象的创建而产生随着对象的结束而结束调用方式静态变量既可以通过类名直接进行调用也可以通过对象名进行调用实例变量只能通过对象名进行访问和的区别是具体抛出一个异常对象在方法的内部后面有且只能有一个异常对象代码一旦遇到了证明出现了问题代码就会停止线程会异常退出是异常的声明在方法定义的小括号后面后面可以跟多个异常的类型方法有代码不一定发生异常与的区别是不可变的字符串序列因此该类不可以被继承也即没有子类相同点类类类不同点类中的大多数方法没有加关键字修饰而类中的大多数方法都是加了关键字修饰正因为如此在多线程操作的时候会比安全但是其效率会偏低和的区别既可以比较基本数据类型也可以比较引用数据类型比较基本数据类型比较的是具体的值比较引用数据类型比较是地址值只能比较引用数据类型重写之前比较的是引用数据类型的地址值重写之后根据重自定义写的规则比较的是引用数据类型的内容包装类拆箱装箱装箱将基本类型转换成包装类对象拆箱将包装类对象转换成基本类型的值区别以和为例是的包装类则是的一种基本数据类型变量必须实例化后才能使用而变量不需要实际是对象的引用当一个时实际上是生成一个指针指向此对象而则是直接存储数据值的默认值是的默认值是为什么要引入自动装箱和拆箱的功能主要是用于集合中集合如果要放整数的话只能放对象不能放基本类型因此需要将整数自动装箱成对象例子聪明出于勤奋天才在于积累一组两个对象比较结论两个对象比较地址一定不等则结果为二组类型属性值和属性值比较结论包装类和基本数据类型比较的时候将包装类自动拆箱为然后进行比较本质就是两个变量进行比较只要两个变量的值相等则结果就为三组类型变量值和类型的变量值比较结论堆中地址常量池中地址地址不等四组类型的变量值和类型的变量值范围在相等其它则不相等会创建新的对象异常结构图和的区别在中和都是表示程序运行过程中出现的问题它们的主要区别在于错误表示程序无法处理的严重问题通常是由系统内部错误引起的如内存溢出虚拟机错误等通常不允许被捕获和处理因为它们表示程序无法继续运行异常表示程序可以处理的问题通常是由程序逻辑错误或外部因素引起的如文件不存在空指针异常等可以被捕获和处理以便程序能够恢复正常运行或者给出友好的错误提示总结是严重的问题通常不需要程序员处理是可处理的问题需要程序员根据具体情况进行处理运行时异常和非运行时异常区别运行时异常包括诸如空指针异常数组越界等这些通常是由程序逻辑错误引起的并且可以被捕获和处理程序员可以根据具体情况进行处理以防止程序意外终止并恢复正常运行非运行时异常则是在编译阶段就会被检测到的异常例如文件找不到异常输入输出异常等这种异常如果未被捕获处理将无法通过编译编译器要求程序员必须对这种异常进行处理因为认为这类异常都是可以被修复的因此运行时异常与非运行时异常的主要区别在于它们的触发时机和处理方式运行时异常在程序运行时被触发而非运行时异常在编译阶段就被检测并处理的去重原理如果两个对象的值不同直接插入成功如果两个对象的值相同再比较两个对象的地址值如果地址值相同即同一个对象插入失败无需继续判断反之则会继续调用方法比较如果方法返回插入失败如果方法返回插入成功理解的键值存储设计是中的一个集合类它实现了接口在的内部实现中它维护了一个当我们向中添加元素时这些元素会被存储在的中而则是一个固定的对象这个固定的对象通常被称为它是一个定义了一个虚拟的对象作为的这样的设计背后的原因有以下几点简化代码由于所有的都是同一个对象这使得的内部实现更加简单性能考虑使用一个固定的对象作为可以减少内存分配和垃圾回收的开销明确性这种设计使得我们清楚地知道中的每个元素都是独立的不会与其他元素关联值得注意的是虽然的底层使用来支持其操作但它们之间存在一些区别例如存储的是键值对而其实也是存储的键值对但是键值对的是一个默认值集合与数组的区别集合与数组都是容器数组既可以存基本数据类型也可以存引用数据类型数组的长度固定不能发生改变集合只能存引用数据类型可以存任意的引用数据类型长度可变理解各自场景数组适合需要有序存储和快速访问数据的场景而集合则适用于需要灵活添加删除和修改元素的场景多线程的五种实现方式继承重写方法最后创建的子类对象调用方法开启线程任务例子实现接口重写方法创建的实现类对象通过的构造传递调用方法开启线程任务例子实现接口重写方法创建的实现类对象将的实现类对象传递到的构造方法中最后将传递到的构造方法中通过方法开启线程任务例子和接口有什么区别接口中也是一个函数式接口里面拥有一个方法接口的方法可以有返回值接口中的方法可以抛异常方法和方法都能抓异常抛异常抓异常抓异常使用线程池创建例子比如使用线程池工具类比如自定义线程池使用自带的异步编排方式例子使用异步编排开始执行一个任务把控细节其实不管是哪种方式创建底层都是通过实现接口方式创建线程值得注意的是无论是通过哪种方式创建线程底层都是依赖于操作系统的线程实现理解几种方式创建的有缺点继承类并重写方法这种方式的优点是编写简单如果需要访问当前线程无需使用方法但缺点是的单继承特性一个类继承了之后就不能再继承其它类了同时方法不能有返回值并且不能抛出异常实现接口并重写方法这种方式可以避免中的单继承带来的问题适合多个相同程序代码的线程去处理同一资源的情况但不能获取到线程执行的结果实现接口并重写方法与相比它可以处理更复杂的数据类型并且可以获取到线程执行的结果但是使用时比稍显复杂使用线程池例如框架来创建线程这种方式是一种十分高效的线程管理方式它可以根据系统资源和任务数量来创建适当数量的线程很好地做到了节省和管理系统资源但相比于前面的方式使用线程池需要更多的配置和编码工作多线程的生命周期源码中一共定义了钟状态新建线程对象刚给创建但未启动例子只要线程出来线程的名字线程的状态可运行线程已被启动可以被调度或正在被调度例子线程的状态线程的状态锁阻塞当前线程要获取的锁对象正在被其他线程占用此时该线程处于状态例子线程状态等待阻塞当前线程遇到了等方法例子使用或者的时候必须要要结合使用使用对象的方法时必要要有一个对象和如若不结合那么就会出现一个监视器对象状态异常任何一个对象中都有一个对象监视器锁管程技术使用或者都要结合使用不然就会出现监视器异常限时等待当前线程调用了时间时间时间等方法例子线程调用方法线程调用方法线程调用方法终止线程正常结束或异常提前退出例子和的区别速度和内部实现内部使用哈希表来存储元素因此它的查找插入和删除操作的时间复杂度都是而内部使用的是红黑树因此它的时间复杂度为排序方式不保证元素的顺序因为它是根据哈希值来存储和检索元素的而则可以保证元素的顺序因为它是根据元素的自然顺序或者比较器来进行排序的默认是升序接口实现了接口而实现了接口使用场景如果需要快速地插入删除和查找元素并且不关心它们的顺序那么可以使用如果需要对元素进行比较排序那么可以使用所学习的流一共分为几类流根据流向有输入流和输出流两种流根据类型分类有字节输入输出流和字符输入输出流字节输入流字节输出流字符输入流字符输出流把控细节字节流是万能流可以处理任意的文件字符流不是万能流基本上用来处理纯文本文件理解字符流和字节流是中的两种主要类它们在处理数据时有着明显的区别字符流主要是用于处理文本数据它支持写入和读取码元而字节流则主要用于处理二进制数据不支持写入或读取码元具体来说字符流是以字符为单位进行数据传输的一次可能读取多个字节的数据并将其转换为一个字符相反字节流则是以字节为单位进行数据传输每次只读取一个字节的数据此外两者的处理方式也有所不同字节流是一种按字节顺序存储和读取数据的方式而字符流则是按照字符顺序存储和读取数据因此只要是处理纯文本数据就优先考虑使用字符流否则使用字节流的三种遍历方式方式一增强方式二迭代方式三迭代例子聪明出于勤奋天才在于积累男武汉市方式一增强的的方式二迭代的的方式三迭代的的理解三种方式适合的场景有三种主要的遍历方式各自适应不同的场景需求遍历这种方式的每个元素都是对象其中包含了键值对当需要访问或操作每一个键值对时这是最佳选择例如你可以很容易地获取每个条目的和遍历这种方式通过遍历键的集合来访问中的元素这在你需要基于键执行某些操作而不需要关心对应的值的场景中很有用遍历这种方式是通过遍历值的集合来访问中的元素当你需要处理中所有的值而不考虑其对应的键的场景中这种方式很适用与的区别线程安全性不同是线程不安全的是线程安全的其中的方法大多数是的在多线程并发的情况下可以直接使用但是使用时必须自己增加同步处理库中的方法是否提供方法只有和方法有和三个方法其中和方法功能相同和是否允许值中和都不允许出现值中可以作为键这样的键只有一个可以有一个或多个键所对应的值为数组初始化和扩容机制初始化在不指定容量的情况下的默认容量为而在不指定容量的时候并不会提前构建指定长度大小的数组而是当第一次元素的时候才会去创建一个容量大小为的数组这点一定要注意扩容扩容时将容量变为原来的倍加而扩容时将容量变为原来的倍和的区别基于动态数组连续内存存储适合下标访问随机访问扩容机制因为数组长度固定超出长度存数据时需要新建数组然后将老数组的数据拷贝到新数组如果不是尾部插入数据还会涉及到元素的移动往后复制一份插入新元素使用尾插法并指定初始容量可以极大提升性能甚至超过需要创建大量的对象基于链表可以存储在分散的内存中适合做数据插入及删除操作不适合查询需要逐一遍历遍历必须使用不能使用循环因为每次循环体内通取得某一元素时都需要对重新进行遍历性能消耗极大另外不要试图使用等返回元素索引并利用其进行遍历使用对进行了遍历当结果为空时会遍历整个列表什么是反射什么是反射机制反射就是在程序运行时期动态的获取类信息并操作该类成员构造方法成员变量成员方法的过程这种动态获取类的信息以及动态调用对象的方法的功能来自于语言的反射的反射机制的实现要借助于个类其中代表的是类对象类的构造器对象类的属性对象类的方法对象通过这四个对象我们可以粗略的看到一个类的各个组成部分反射机制提供功能在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象在运行时判断任意一个类所具有的成员变量和方法在运行时调用任意一个对象的方法例子聪明出于勤奋天才在于积累获取任意一个对象所属的类构造任意一个类对象获取任意一个类中的构造方法获取任意一个类中的方法类中的方法获取任意一个类中的成员变量类中的成员变量调用任意一个对象的方法理解反射的场景反射主要用在以下几种场景框架开发反射是许多流行框架如等的基础通过反射机制可以简化开发过程提高代码的可重用性和扩展性例如框架中的依赖注入和动态代理等功能就是通过反射实现的动态代理利用反射机制可以在运行时动态生成代理类从而实现对目标对象的代理访问常见的应用场景如编程面向切面编程单元测试反射能够帮助我们编写出能够对任意对象进行操作的测试代码这在单元测试中非常有用例如框架就提供了一系列的反射来支持其功能实现动态装配通过反射我们可以在程序运行时动态地装载类这对于实现插件化架构或者热部署等功能非常有用服务任务调度在一些复杂的业务场景中服务任务的执行逻辑可能会根据前一个任务的执行结果而变化这时候就可以利用反射来实现这种动态的任务调度深拷贝和浅拷贝深拷贝和浅拷贝就是指对象的拷贝一个对象中存在两种类型的属性一种是基本数据类型一种是实例对象的引用浅拷贝是指对基本数据类型进行值传递对引用数据类型进行引用传递般的拷贝深拷贝是指对基本数据类型进行值传递对引用数据类型创建一个新的对象并复制其内容此为深拷贝浅拷贝例子聪明出于勤奋天才在于积累浅拷贝小米创建一个对象原对象设置引用类型属性打印原对象的属性值克隆一个对象克隆对象打印克隆对象的属性值浅拷贝由于会拷贝引用数据类型的地址因此修改拷贝对象的值其被拷贝对象的值也会跟着变化反之同理华为原对象的引用类型值克隆对象的引用类型值运行结果深拷贝例子聪明出于勤奋天才在于积累继续利用方法对该对象的引用类型变量再实现一次方法要想深克隆要不就是序列化和反序列化要不就是继续深拷贝小米深拷贝不会拷贝引用数据类型的地址而是会创建一个新对象空间因此修改拷贝对象的值其被拷贝对象的值不会跟着变化反之同理华为原对象的引用类型值克隆对象的引用类型值运行结果理解深拷贝和浅拷贝的作用和场景深拷贝和浅拷贝在编程中都有重要的应用场景深拷贝主要用于需要修改原对象但又不希望影响原对象的场景例如当您需要使用一个对象作为参数传递给函数同时又不想因为这个函数内部对对象的修改而改变原对象时就需要使用深拷贝来创建一个新的独立的对象副本此外当您从数据库中读取一些数据并想在此基础上做一些改动但又希望保持原数据的完整性时深拷贝也是一个理想的选择相反浅拷贝通常用于原始对象和拷贝对象需要共享相同数据的场景例如如果您有一个包含大量数据的对象并且您只想复制该对象的一部分数据到另一个新的对象中那么浅拷贝就非常适用因为它只复制了对象的引用而不是对象本身此外如果对象非常大并且只需要偶尔进行修改那么浅拷贝由于其较低的内存消耗可能会是更好的选择总的来说深拷贝和浅拷贝的选择取决于具体的应用场景和需求理解它们的区别对于正确处理对象和数组的复制至关重要集合类集合框架是什么说出集合框架的一些优点答每种编程语言中都有集合最初的版本包含几种集合类和随着集合的广泛使用提出了囊括所有集合接口和实现类算法的集合框架在保证线程安全的情况下使用泛型和并发集合类已经经历了很久集合框架的部分优点如下使用核心集合类降低开发成本而非实现我们自己的集合类使用经过严格测试的集合框架类代码质量会得到提高通过使用附带的集合类可以降低代码维护成本复用性和可操作性集合接口的常见实现类接口的实现类接口的实现类最常用的有和类实现了可变的数组可以根据索引位置对集合进行快速的随机访问类采用链表结构保存对象便于向集合中插入和删除对象但是如果将元素插入到集合的尾部其实原比快也是的一个常见实现类但是在该类中的大多数方法都加了关键字因此相比集合在多线程访问时是线程的安全的接口的实现类接口的实现类常用的有和它们的元素都不可重复底层是哈希表遍历元素和添加顺序大小顺序无关底层是红黑树元素按照大小顺序存储和遍历底层是哈希表双链表遍历元素可以体现添加时顺序顺序性是体现和不同之处接口的实现类接口的实现类常用的有和它们的都不可重复这里面的不可重复指的是容器中对于同一个只会存在一个哈希表底层是数组链表红黑树遍历元素和添加顺序大小顺序无关哈希表双链表遍历元素可以体现添加顺序红黑树元素按照大小顺序存储和遍历例子聪明出于勤奋天才在于积累和区别答在数据结构方面存储的是单列数据的集合而存储的是类型的数据集合在数据存储方面存储的数据是有序且可以重复的而中存储的数据是无序不同的子类也可以保证有序且值不会重复值可以重复三个接口存取元素时各有什么特点与具有相似性它们都是单列元素的集合所以它们有一个共同的父接口叫里面不允许有重复即相等的元素取元素时没法说取第几个只能通过循环或者迭代器逐一遍历各个元素表示有先后顺序的集合注意不是那种按年龄按大小按价格之类的排序当我们多次调用方法时每次加入的对象就像火车站买票有排队顺序一样按先来后到的顺序排序有时候也可以插队即调用方法就可以指定当前对象在集合中的存放位置一个对象可以被反复存储进中每调用一次方法这个对象就被插入进集合中一次其实并不是把这个对象本身存储进了集合中而是在集合中用一个索引变量指向这个对象当这个对象被多次时即相当于集合中有多个索引指向了这个对象除了通过迭代器逐一遍历各个元素还可以调用来明确说明取第几个与和不同它是双列的集合用方法存储一对不能存储重复的取则可以根据获得相应的即返回值为所对应的另外也可以获得所有的的集合还可以获得所有的的结合还可以获得和组合成的对象的集合为什么接口不继承接口首先提供的是键值对映射即和的映射而提供的是一组数据并不是键值对映射其次如果继承了接口那么所有实现了接口的类到底是用的键值对映射数据还是用的一组数据呢就我们平常所用的等都是键值对所以它继承完全没意义而且如果继承了接口的话还违反了面向对象的接口分离原则和之间有什么区别我们可以使用来遍历和集合而只能遍历只可以向前遍历而可以双向遍历从接口继承然后添加了一些额外的功能比如添加一个元素替换一个元素获取前面或后面元素的索引位置聪明出于勤奋天才在于积累正向遍历结果正向遍历反向遍历结果反向遍历插入元素插入元素替换元素替换元素集合框架中的泛型有什么优点类型安全通过知道使用泛型定义的变量的类型限制编译器可以在非常高的层次上验证类型假设没有泛型这些假设就只能在于程序员编码时候去考虑了消除强制类型转换消除源代码中的许多强制类型转换这使得代码更加可读并且减少了出错机会更高的效率在非泛型编程中将筒单类型作为引用类型传递时会引起装箱和拆箱操作这两个过程都是具有很大开销的引入泛型后就不必进行装箱和拆箱操作了所以运行效率相对较高接口提供了哪些不同的集合视图接口提供三个集合视图返回中包含的所有的一个视图此集合是受支持的的变化会在集合中反映出来反之亦然当一个迭代器正在遍历一个此集合时若被修改了除迭代器自身的移除操作以外迭代器的结果会变为不确定此集合支持元素查找和删除从此中删除元素会从中移除对应的映射它不支持和添加操作返回一个中包含的所有的一个视图这个受支持的的变化会在中反映出来反之亦然当一个迭代器正在遍历此时若被修改了除迭代器自身的移除操作以外迭代器的结果会变为不确定此集合支持元素查找和删除从此中删除元素会从中移除对应的映射它不支持和添加操作返回一个钟包含的所有映射的一个集合视图这个集合受支持的的变化会在中反映出来反之亦然当一个迭代器正在遍历此集合时若被修改了除迭代器自身的移除操作以及对迭代器返回的进行外迭代器的结果会变为未定义此集合支持元素查找和删除从此中删除元素会从中移除对应的映射它不支持和添加操作数据结构数组链表方法的流程理解问题一初始化大小选择的幂方好处初始化为的幂方主要是为了加快哈希计算以及减少哈希冲突具体来说当长度为的整数次幂时的操作结果等于此外在扩容时如果是的幂次方只需要进行左移操作这因为位操作的速度相对较快问题二处理为的情况注意在中的哈希码是在存储为的数据时会将该数据存储在一个特殊的桶中这个桶被称为桶或空桶具体来说当使用方法插入一个为的数据时会先检查当前桶数组的长度是否为如果是则直接将该数据存储到数组的第一个位置上如果不是则会遍历整个桶数组找到第一个空的位置然后将该数据存储到该位置上需要注意的是由于没有哈希码因此无法通过哈希函数计算得到对应的桶位置此外如果多个键都为它们会被存储在同一个桶中因为它们的哈希码都是相同的这种情况下可以使用方法来检查是否存在某个特定的键问题三扩容中的是指在进行扩容操作时的阈值即当中的元素个数达到时中的是指在进行扩容操作时的阈值即当中的元素个数达到时会自动进行扩容操作的值为其中是的容量是的负载因子具体来说当元素数量增加到阈值时会创建一个新的桶数组并将原来的元素重新计算哈希值后放入新的桶数组中问题四值和的区别在中是类的一个方法而的方法是类的一个方法它们的主要区别在于方法是中的一个通用方法用于获取对象的哈希码值任何对象都可以调用这个方法来获取其哈希码值而的方法是类的一个特有方法用于获取字符串的哈希码值只有字符串对象才能调用这个方法来获取其哈希码值对于同一个对象如果不改变内部属性的话每次调用必须返回相同数值这是因为如果每次调用返回不同的那么每次在中寻找这个对象的时候会找到其他桶去从而判定错误而的返回值要尽可能的散列开来意思是尽量减少不同对象的哈希码值相同的可能性在中如果要找到某个元素需要根据的值来求得对应数组中的位置这里的可以是任何对象因此我们需要使用对象的方法来获取其哈希码值而对于字符串类型的我们可以直接使用其自带的方法来获取其哈希码值数据结构数组链表红黑树方法流程注意细节基于哈希表的接口实现是以存储形式存在即主要用来存放键值对的实现不是同步的这意味着它不是线程安全的它的都可以为此外中的映射不是有序的之前由数组链表组成的数组是的主体链表则是主要为了解决哈希冲突两个对象调用的方法计算的哈希码值一致导致计算的数组索引值相同而存在的拉链法解决冲突以后在解决哈希冲突时有了较大的变化当链表长度大于阈值或者红黑树的边界值默认为并且当前数组的长度大于时此时此索引位置上的所有数据改为使用红黑树存储补充将链表转换成红黑树前会判断即使阈值大于但是数组长度小于此时并不会将链表变为红黑树而是选择进行数组扩容这样做的目的是因为数组比较小尽量避开红黑树结构这种情况下变为红黑树结构反而会降低效率因为红黑树需要进行左旋右旋变色这些操作来保持平衡同时数组长度小于时搜索时间相对要快些所以综上所述为了提高性能和减少搜索时间底层在阈值大于并且数组长度大于时链表才转换为红黑树具体可以参考方法当然虽然增了红黑树作为底层数据结构结构变得复杂了但是阈值大于并且数组长度大于时链表转换为红黑树时效率也变的更高效中的为什么要使用红黑树当元素个数小于一个阈值时链表整体的插入查询效率要高于红黑树当元素个数大于此阈值时链表整体的插入查询效率要低于红黑树此阈值在中为中的什么时候将链表转化为红黑树这个题很容易答错大部分答案就是当链表中的元素个数大于时就会把链表转化为红黑树但是其实还有另外一个限制当发现链表中的元素个数大于之后还会判断一下当前数组的长度如果数组长度小于时此时并不会转化为红黑树而是进行扩容只有当链表中的元素个数大于并且数组的长度大于等于时才会将链表转为红黑树上面扩容的原因是如果数组长度还比较小就先利用扩容来缩小链表的长度与中的不同点中使用了红黑树中链表的插入使用的头插法扩容转移元素的时候也是使用的头插法头插法速度更快无需遍历链表但是在多线程扩容的情况下使用头插法会出现循环链表的问题导致飙升中链表使用的尾插法中反正要去计算链表当前结点的个数反正要遍历的链表的所以直接使用尾插法的算法比中的更复杂算法越复杂生成的则更散列那么中的元素则更散列更散列则的查询性能更好中没有红黑树所以只能优化算法使得元素更散列而中增加了红黑树查询性能得到了保障所以可以简化一下算法毕竟算法越复杂就越消耗扩容的过程中中有可能会重新对进行哈希重新跟哈希种子有关系而中没有这部分逻辑中扩容的条件和中不一样除开判断是否大于阈值之外中还判断了是否为空不为空的时候才会进行扩容而中则没有该条件了中还多了一个和扩容过程中转移元素的逻辑不一样是每次转移一个元素是先算出来当前位置上哪些元素在新数组的低位上哪些在新数组的高位上然后在一次性转移底层是由两层嵌套数组来实现的对象中有一个属性类型为对象中有一个属性类型为是中的一个线程安全的哈希表数据结构它通过分割桶来实现并发访问的底层数据结构由数组链表和红黑树组成核心是基于数组实现的为了解决哈希冲突采用拉链法于是引入了链表结构为了解决链表过长造成的查询性能下降又引入了红黑树结构的图解说明地址流程当调用的方法时先根据计算出对应的的数组下标确定好当前应该插入到哪个对象中如果为空则利用自旋锁的方式在位置生成一个对象然后调用对象的方法对象的方法会先加锁然后也根据计算出对应的的数组下标然后将封装为对象放入该位置此过程和的的方法一样然后解锁在加锁的过程中逻辑比较复杂先通过自旋加锁如果超过一定次数就会直接阻塞等等加锁理解在中是一个核心的内部类它扮演着关键的角色每个实际上都是一个类型的数组这个数组中的每个元素都代表了一条链表的节点的主要特点包括拥有独立的锁每个对象都拥有一个独立的锁这可以确保在进行写操作时只需锁定对应的而其他的数据则可以被并行访问实现了分段锁技术通过使用段将划分为不同的部分就可以使用不同的锁来控制对哈希表的不同部分的修改从而允许多个修改操作并发进行结构复杂性由于支持并发操作因此的实现相对复杂整个就是由这些组成的总的来说是能够实现高效并发操作的关键因素之一流程当向中一个时首先根据计算对应的数组下标如果该位置没有元素则通过自旋的方法去向该位置赋值如果该位置有元素则会加锁加锁成功之后在判断该元素的类型如果是链表节点则进行添加节点到链表中如果是红黑树则添加节点到红黑树添加成功后判断是否需要进行树化这个方法的意思是的元素个数加但是这个操作也是需要并发安全的并且元素个数加成功后会继续判断是否要进行扩容如果需要则会进行扩容所以这个方法很重要同时一个线程在时如果发现当前正在进行扩容则会去帮助扩容如何保证并发主要利用操作分段思想主要使用了操作中的通过的方式修改对象的属性并发安全的给数组的某个位置赋值并发安全的获取数组某个位置的元素分段思想是为了提高的并发量分段数越高则支持的最大并发量越高程序员可以通过参数来指定并发量的内部类就是用来表示某一个段的每个就是一个小型的的当调用的方法是最终会调用到的方法而类继承了所以自带可重入锁当调用到的方法时会先利用可重入锁加锁加锁成功后再将待插入的插入到小型中插入完成后解锁理解原理全称是一种无锁算法被用于实现多线程同步的原子指令它的基本操作逻辑是如果内存位置的值与预期值相匹配那么就将该位置的值更新为新值否则就不做任何操作但是需要返回原来的值因此的核心是比较并替换这也是它的英文名称的由来在中常常用于实现原子类乐观锁的原理也是基于来实现的相对于使用互斥锁或来说是一种轻量级的实现方案因为它避免了线程阻塞和唤醒的开销可以有效提高程序的执行效率如何保证并发主要利用操作关键字操作的使用仍然和中的类似主要负责并发安全的修改对象的属性或数组某个位置的值主要负责在需要操作某个位置时进行加锁该位置不为空比如向某个位置的链表进行插入结点向某个位置的红黑树插入结点中其实仍然有分段锁的思想只不过中段数是可以控制的而中是数组的每一个位置都有一把锁理解是中一个线程安全的哈希表实现它通过以下几种方式来保证并发安全分段锁技术将数据分成多个段每个段都是一个独立的哈希表不同线程访问不同的段时不需要加锁从而提高了并发性能当需要对整个进行操作时只需要锁定整个对象即可无锁算法在更新元素值时使用了无锁算法避免了使用传统的锁带来的性能开销关键字中的一些变量使用了关键字修饰保证了多线程之间的可见性分段计数器中使用了一个分段计数器用于记录每个段中元素的个数这个计数器采用了原子操作保证了并发安全性综上所述通过分段锁技术无锁算法关键字和分段计数器等方式来保证并发安全高级建议会说一下的主要组成部分及其作用类加载器将字节码文件加载到内存中类加载器只管加载不管运行只要符合文件结构就会加载执行引擎也叫解释器负责解释命令其任务就是将字节码指令解释编译为对应平台上的本地机器指令本地接口本地接口本地接口的作用是融合不同的语言为所用栈也叫栈内存是程序的运行区用于存储局部变量表操作栈动态链接即引用比如方法区的成员变量方法出口等信息它随着线程的创建而创建随着线程结束而释放只要线程一结束该栈就结束对于栈来说不存在垃圾回收的问题垃圾回收只针对于堆和方法区栈中的数据以栈帧的形式存在是一个数据集是一个有关方法和运行期数据的集合当方法被调用时就产生了一个栈帧并被压入到栈中方法又调用了方法于是产生栈帧也被压入栈执行完毕后先弹出栈帧再弹出栈帧遵循先进后出原则堆存放的是实例对象一个实例只存在一个堆内存堆内存的大小是可以调节的堆内存分三部分永久区即存储的是运行环境必须的类信息被装载至此区域的数据是不会被垃圾回收掉的只有关闭释放此区域所占用的内存新生区老年代方法区方法区只是规范中定义的一个概念它用于存储已被虚拟机加载的类的信息类的名称方法信息字段信息常量静态变量即时编译器编译后的代码缓存等程序计数器每个线程都有一个程序计数器就是一个指针指向方法区中的方法字节码用来存储下一条将要执行的字节码指令的地址由执行引擎读取下一条指令说一下运行时数据区不同虚拟机的运行时数据区可能略微有所不同但都会遵从虚拟机规范虚拟机规范规定的区域分为以下个部分程序计数器当前线程所执行的字节码的行号指示器字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令分支循环跳转异常处理线程恢复等基础功能都需要依赖这个计数器来完成虚拟机栈用于存储局部变量表操作数栈动态链接方法出口等信息本地方法栈与虚拟机栈的作用是一样的只不过虚拟机栈是服务方法的而本地方法栈是为虚拟机调用方法服务的堆虚拟机中内存最大的一块是被所有线程共享的存放对象实例方法区用于存储已被虚拟机加载的类信息常量静态变量即时编译后的代码等数据什么是类加载器对于任意一个类都需要由加载它的类加载器和这个类本身一同确立在中的唯一性每一个类加载器都有一个独立的类名称空间类加载器就是根据指定全限定名称将文件加载到内存然后再转化为对象类加载器分类启动类加载器负责加载中下的某些包中的类比如该类加载器由实现不是子类扩展类加载器负责加载平台中扩展功能的一些包包括中或指定目录下的包应用程序类加载器也叫系统类加载器负责加载中指定的包及目录中或目录下的包或者文件用户自定义加载器的子类用户可以定制类的加载方式注意各种类加载器之间存在着逻辑上的父子关系但不是真正意义上的父子关系因为它们直接没有从属关系双亲委派模型双亲委派机制是虚拟机加载一个类时为该类确定类加载器的一种机制简单的来说如果一个类加载器收到了加载某个类的请求则该类加载器并不会去加载该类而是把这个请求委派给父类加载器每一个层次的类加载器都是如此因此所有的类加载请求最终都会传送到顶端的启动类加载器只有当父类加载器在其搜索范围内无法找到所需的类并将该结果反馈给子类加载器子类加载器会尝试去自己加载具体的来说例如有一个类需要加载在双亲委派机制下流程是怎么样的呢首先应用类加载器会判断之前是否加载过这个类如果加载过则返回如果没有加载过则会向上委托给扩展类加载器扩展类加载器同样会去判断之前是否加载过这个类如果加载过则返回如果没有加载过则继续向上委托给引导类加载器引导类加载器则会去目录下去查询是否有这个类注意不会在问是否加载过如果有这个类则加载如果没有就向下回传给扩展类加载器加载扩展类加载器去目录下去查询是否有这个类如果有这个类则加载如果没有这个类就向下回传给应用类加载器应用类加载器会去项目的类路径下下去查询是否有这个类如果有这个类则加载如果没有这个类就会抛出经典的流程理解双亲委派机制的主要作用包括防止重复加载同一个文件通过委托的方式如果一个类已经被加载过了就不会再次被加载从而保证了数据安全保证核心文件不能被篡改由于所有的类加载请求都需要经过父类加载器的检查因此可以确保核心文件不会被篡改即使有人尝试篡改由于父类加载器不会加载被篡改的文件所以即使加载了也不会是同一个对象这样保证了的执行安全性说一下类装载的执行过程类装载简单分为以下个步骤加载根据查找路径找到相应的文件然后导入验证检查加载的文件的正确性准备给类中的静态变量分配内存空间解析虚拟机将常量池中的符号引用替换成直接引用的过程符号引用就理解为一个标示而在直接引用直接指向内存中的地址初始化对静态变量和静态代码块执行初始化工作细节过程理解类从加载到卸载出内存的整个生命周期可以分为七个阶段加载验证准备解析初始化使用和卸载首先源文件通过编译器编译成文件也就是所说的字节码文件然后虚拟机执行类的加载过程这是类加载过程的第一个阶段在这个阶段的主要目的是将字节码从各个位置网络磁盘等转化为二进制字节流加载到内存中接着会为这个类在的方法区创建一个对应的对象这个对象就是这个类各种数据的访问入口具体来说加载阶段之后是验证阶段这一阶段的目的是确保加载的字节流符合虚拟机规范并且不会危害虚拟机自身的安全准备阶段则为类的静态变量分配存储空间并设置默认初始值解析阶段是将符号引用转换为直接引用的过程初始化阶段则是真正执行类中定义的静态代码块和静态变量的初始化逻辑使用阶段则是开始调用类的构造器创建对象和调用类的成员方法最后是卸载阶段当一个类不再被使用时会进行卸载操作以上就是类从加载到卸载的整个过程怎么判断对象是否可以被回收一般有两种方法来判断引用计数器为每个对象创建一个引用计数有对象引用时计数器引用被释放时计数当计数器为时就可以被回收它有一个缺点不能解决循环引用的问题可达性分析这个算法的基本思想就是通过一系列的称为的对象作为起点从这些节点开始向下搜索节点所走过的路径称为引用链当一个对象到没有任何引用链相连的话则证明此对象是不可用的哪些对象可以作为在语言中可以作为的对象包括下面几种虚拟机栈栈帧中的本地变量表中的引用对象方法区中的类静态属性引用的对象方法区中的常量引用的对象本地方法栈中方法的引用对象小技巧由于采用栈方式存放指针所以如果一个指针它保存了堆里面的对象但是自己又不存放在堆里面那他就可以作为一个中都有哪些引用类型强引用发生的时候不会被回收软引用有用但不是必须的对象在发生内存溢出之前会被回收弱引用有用但不是必须的对象在下一次时会被回收虚引用幽灵引用幻影引用无法通过虚引用获得对象用实现虚引用虚引用的用途是在时返回一个通知临死之前收到一个通知聪明出于勤奋天才在于积累软引用弱引用虚引用软引用测试会发现后软引用对象的值获仍然能够获取到软引用的值没有进行前软引用能得到对象软引用对象被垃圾回收了软引用对象的值弱引用测试会发现后弱引用对象的值获取不到软引用的值没有进行前软引用能得到对象进行垃圾回收软引用对象被垃圾回收了软引用对象的值虚引用测试会发现前弱引用对象的值都获取不到进行垃圾回收理解中主要有四种引用方式强引用软引用弱引用和虚引用各自的使用场景如下强引用是中最常见的引用方式只要还有一个强引用指向一个对象垃圾回收机制就不会回收这个对象强引用适用于大部分情况例如对象的正常赋值操作软引用是一种相对较强的引用只有当认为内存不足时才会对被软引用关联的对象进行垃圾回收因此软引用通常用于一些需要缓存但并非关键数据的情况例如缓存大图片弱引用的强度比软引用更弱只要垃圾回收机制运行无论是否内存不足都可能对被弱引用关联的对象进行回收弱引用一般用于维护一些非必须的对象例如缓存大对象虚引用是最弱的一种引用它并不会决定对象的生命周期虚引用主要用于跟踪对象被垃圾回收的状态或者在某些特殊需求下例如记录系统的运行状态或者监控对象的回收过程说一下有哪些垃圾回收算法标记复制算法该算法将内存平均分成两部分然后每次只使用其中的一部分当这部分内存满的时候会将内存中所有存活的对象复制到另一个内存中然后将之前的内存清空只使用这部分内存循环下去标记清除算法使用可达性算法标记出需要回收的对象且有根可达的就不会被标记清理回收被标记的对象标记整理算法标记无用对象让所有存活的对象都向一端移动然后直接清除掉端边界以外的内存分代算法根据对象存活周期的不同将内存划分为几块一般是新生代和老年代新生代基本采用复制算法老年代采用标记整理算法分代回收算法实际上是把复制算法和标记整理法的结合并不是真正一个新的算法一般分为老年代和新生代老年代就是很少垃圾需要进行回收的新生代就是有很多的内存空间需要回收所以不同代就采用不同的回收算法以此来达到高效的回收算法说一下有哪些垃圾回收器理解垃圾回收器的性能也是一个重要的评判标准包括吞吐量和停顿时间等吞吐量是指垃圾回收器在特定时间段内所能处理的对象数量而停顿时间则是指在执行垃圾回收时应用程序被暂停执行的时间垃圾回收器总体分为三大类串行并行并发最早的单线程串行垃圾回收器垃圾回收器的老年版本同样也是单线程的是的多线程版本和收集器类似是多线程的但是吞吐量优先的收集器可以牺牲等待时间换取系统的吞吐量是老生代版本使用的是复制的内存回收算法使用的是标记整理的内存回收算法一种以获得最短停顿时间为目标的收集器非常适用系统一种兼顾吞吐量和停顿时间的实现详细介绍一下垃圾回收器收集器是一种以获取最短回收停顿时间为目标的收集器它非常符合在注重用户体验的应用上使用它是虚拟机第一款真正意义上的并发收集器它第一次实现了让垃圾收集线程与用户线程基本上同时工作从名字中的这两个词可以看出收集器是一种标记清除算法实现的它的运作过程相比于前面几种垃圾收集器来说更加复杂一些整个过程分为四个步骤初始标记并发标记重新标记并发清理其中初始标记重新标记这两个步骤仍然需要初始标记仅仅只是枚举全部的对象速度很快并发标记阶段就是进行的过程采用三色标记算法这个过程耗时较长但是不需要停顿用户线程可以与垃圾收集线程一起并发运行因为用户程序继续运行可能会有导致已经标记过的对象状态发生改变而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录这个阶段的停顿时间一般会比初始标记阶段稍长一些但远比并发标记的时间短并发清理这个阶段清理删除掉标记阶段判断已经死亡的对象由于不需要移动存活对象因此这个阶段可以与用户线程同时发生初始标记迄今为止在进行根节点枚举这一步骤都是需要暂停用户线程的必须要保证在一个能够保证一致性的快照中得以进行这里的一致性指的是不会出现在分析过程中根节点集合的对象的引用关系还在不断地变化因为如果这点不能满足那么分析结果就不能保证那么对于目前的应用来说光是方法区的大小就有数百上千兆里面的类或者常量更是恒河数沙若是检查这里为起源的引用就需要消耗很多的时间所以虚拟机自当是有办法直接得到哪些地方存在着对象的引用在虚拟机中是使用的一组称为的数据结构来达存放这些引用一旦类加载完成的时候虚拟机就会把对象的偏移量数据计算出来并且在即时编译中也会在特定的位置记录下栈里的寄存器中存放哪些位置是引用这样收集器在扫描的时候就可以得知这些信息了并不需要真正的一个不漏的从方法区等开始查找从它的名字就可以看出它是一款优秀的垃圾收集器主要优点并发收集低停顿但是它有下面几个明显的缺点对资源敏感会和服务抢资源降低吞吐量当然这是所有并发收集器的缺点无法处理浮动垃圾在并发标记和并发清理阶段又产生垃圾这种浮动垃圾在本次收集中无法干掉他们只能等到下一次再清理了这一部分垃圾成为浮动垃圾它使用的回收算法标记清除算法会导致收集结束时会有大量空间碎片产生同样由于垃圾收集阶段用户程序还需要持续运行那就还需要预留足够的空间给用户线程使用因此垃圾回收器不能像其他的收集器那样等待老年代几乎完全被填满在进行垃圾收集如果运行期间预留的内存无法满足程序分配新对象的空间就会出现并发失败这时候虚拟机就启动默认的备预案冻结用户线程临时启用重新对老年代的垃圾收集这样就导致停顿时间很长了性能反而降低新生代垃圾回收器和老年代垃圾回收器都有哪些有什么区别新生代回收器老年代回收器整堆回收器新生代垃圾回收器一般采用的是复制算法复制算法的优点是效率高缺点是内存利用率低老年代回收器一般采用的是标记整理的算法进行垃圾回收简述分代垃圾回收器是怎么工作的分代回收器有两个分区老年代和新生代新生代默认的空间占比总空间的老年代的默认占比是新生代使用的是复制算法新生代里有个分区它们的默认占比是它的执行流程如下把存活的对象放入区清空和分区和分区交换变变每次在到移动时都存活的对象年龄就当年龄到达默认配置是时升级为老年代大对象也会直接进入老年代老年代当空间占用到达某个值之后就会触发全局垃圾收回一般使用标记整理的执行算法以上这些循环往复就构成了整个分代垃圾回收的整体执行流程垃圾回收器的比较三色标记所有的垃圾回收算法都要经历标记阶段如果线程在标记的时候暂停所有用户线程那就没三色标记什么事了但是这样会有一个问题用户线程需要等到线程标记完才能运行给用户的感觉就是很卡用户体验很差现在主流的垃圾收集器都支持并发标记什么是并发标记呢就是标记的时候不暂停或少暂停用户线程一起运行这势必会带来三个问题多标漏标垃圾收集器是如何解决这个问题的呢三色标记读写屏障把遍历对象过程中遇到的对象按照是否访问过这个条件标记成三种颜色白色尚未访问过黑色本对象已访问过而且本对象引用到的其他对象也全部访问过了灰色本对象已访问过但是本对象引用到的其他对象尚未全部访问完全部访问后会转换为黑色多标浮动垃圾线程正在标记此时用户代码中断开了对的引用但此时已经被标记成了灰色本轮不会被回收这就是所谓的多标多标的对象即成为浮动垃圾躲过了本次多标对程序逻辑是没有影响的唯一的影响是该回收的对象躲过了一次造成了些许的内存浪费漏标程序会出错漏标是如何产生的呢把标记完准备标记引用的对象这时用户线程执行代码代码中断开了对的引用改为对的引用但是已经被标记成黑色不会再次扫描而还是白色执行垃圾回收逻辑的时候会被回收程序就会出错了如何解决漏标问题先分析下漏标问题是如何产生的条件一灰色对象断开了白色对象的引用即灰色对象原来成员变量的引用发生了变化条件二黑色对象重新引用了该白色对象即黑色对象成员变量增加了新的引用知道了问题所在就知道如何解决了写屏障增量更新这种方式解决的是条件二即通过写后屏障记录下更新具体做法如下对象对的引用关系建立时将加入带扫描的集合中等待扫描当对象的成员变量的引用发生变化时比如新增引用我们可以利用写屏障将新的成员变量引用对象记录下来写后记录新引用的对象写屏障原始快照这种方式解决的是条件一带来的结果是依然能够标记到具体做法如下对象的引用关系变动的时候即给对象中的某个属性赋值时将之前的引用关系记录下来当对象的成员变量的引用发生变化时比如引用消失我们可以利用写屏障将原来成员变量的引用对象记录下来写前获取旧值记录原来的引用对象重标记的时候扫描旧的对象图这个旧的对象图即原始快照实际应用写屏障增量更新写屏障说一下调优的工具自带了很多监控工具都位于的目录下其中最常用的是和这两款视图监控工具用于对中的内存线程和类等进行监控自带的全能分析工具可以分析内存快照线程快照程序死锁监控内存的变化变化等常用的调优的参数都有哪些常用的调优参数有很多以下是一些常见的参数设置的初始堆大小设置的最大堆大小设置线程的栈大小设置新生代和老年代的比例设置区和区的比例在之前或在及以后设置永久代或元空间的最大大小设置并行垃圾收集器的线程数启用并发标记清除垃圾收集器启用垃圾收集器启用串行垃圾收集器这只是一小部分常用的调优参数具体使用哪些参数需要根据应用程序的需求和环境进行调整调优参数的选择和调整需要根据具体情况进行实验和评估你能保证执行吗不能虽然你可以调用或者但是没有办法保证的执行垃圾收集是由自动管理的过程它负责回收不再使用的内存资源根据一定的策略和算法来触发和执行操作虽然无法保证的执行但是你可以通过调整的参数和配置来影响的行为和性能例如可以调整堆大小选择合适的垃圾收集器调整线程数等来优化的性能和效果请注意在进行调优时需要仔细评估和测试不同的配置和参数以确保在特定的应用程序和环境中获得最佳的性能和内存管理怎么获取程序使用的内存堆使用的百分比可以通过类中与内存相关方法来获取剩余的内存总内存及最大堆内存通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间方法返回剩余空间的字节数方法总内存的字节数返回最大内存的字节数设计模式什么是设计模式有什么好处设计模式是一种被反复使用经过验证的解决特定问题的软件设计思想它是对软件设计中常见问题的一种抽象和总结提供了一套经验丰富的解决方案设计模式不是具体的实现代码而是关于类和对象之间交互和组织的一种结构化的描述设计模式的好处如下提高代码的重用性设计模式通过提供通用的解决方案可以使得代码更加可复用它们通过抽象和封装常见的问题和解决方法使得开发人员可以在不同的项目中重用已经验证的设计思想和实践提高代码的可维护性设计模式通过将代码分离成不同的组件和层次使得代码更模块化和可维护它们提供了清晰的结构和约定使得代码更易于理解调试和修改提高软件的可扩展性设计模式通过解耦松散耦合和抽象等方式使得软件系统更容易进行扩展和修改它们使得系统的各个部分之间的依赖关系更加灵活可以方便地添加新的功能和改变现有的实现提高团队协作效率设计模式提供了一种共享的设计语言和思想使得团队成员之间更容易理解和交流它们可以作为团队共享的设计原则和规范促进团队成员之间的合作和协作提高软件系统的可靠性设计模式通过经过验证和优化的解决方案减少了软件系统中的常见错误和问题它们提供了一种结构化的方法和实践可以帮助开发避免一些潜在的设计和实现问题综上所设计模式是一种被广泛应用的软件设计思想通过提供通用的解决方案提高了代码的重用性可维护性可扩展性和团队协作效率同时也提高了软件系统的可靠性设计模式的大基本原则有哪些设计模式的大基本原则是指软件设计中的基本原则和准则它们可以指导我们在使用设计模式时做出正确的设计决策这些原则包括单一职责原则一个类只负责一项职责一个类应该只有一个引起它变化的原因开放封闭原则软件实体类模块函数等应该对扩展开放对修改关闭通过抽象和多态来实现对软件实体的扩展而不是通过修改已有的代码里氏替换原则子类应该能够替换掉父类并且工作正常子类必须能够完全替代父类的行为依赖倒置原则高层模块不应该依赖于低层模块它们应该依赖于抽象抽象不应该依赖于具体实现具体实现应该依赖于抽象接口隔离原则客户端不应该依赖它不需要的接口类之间的依赖关系应该建立在最小的接口上迪米特法则一个对象应该对其他对象有尽可能少的了解只与其直接的朋友进行通信不需要了解朋友的朋友合成复用原则尽量使用对象组合和聚合而不是继承来达到复用的目的通过组合已有的对象来实现新的功能这些原则旨在指导我们进行良好的软件设计提高软件的可读性可维护性可扩展性和可测试性同时它们也是设计模式的基础设计模式的目的就是通过遵循这些原则来实现灵活可复用和可扩展的软件系统使用哪种设计模式可以提高代码可维护性有多种设计模式可以提高代码的可维护性以下是其中几种常见的设计模式单一职责原则将一个类或模块的功能限制在一个单一的责任范围内避免功能的混杂和耦合使得代码更容易理解和修改开放封闭原则通过抽象和多态来实现对软件实体的扩展而不是通过修改已有的代码这样可以避免修改已有代码带来的风险和影响提高代码的可维护性依赖倒置原则高层模块不应该依赖于低层模块它们应该依赖于抽象通过依赖注入等技术将依赖关系从高层模块中抽离出来使得代码更加灵活可扩展和可维护接口隔离原则客户端不应该依赖它不需要的接口通过定义细粒度的接口可以避免接口的臃肿和不必要的依赖关系提高代码的可维护性组合模式通过将对象组合成树状结构使得客户端可以一致地处理单个对象和组合对象这样可以减少代码的重复和冗余提高代码的可维护性策略模式将不同的算法封装为独立的策略对象并通过组合和委托来实现运行时的动态算法选择这样可以降低代码的复杂性使得算法的变化和扩展更加容易观察者模式通过定义一种一对多的依赖关系使得当一个对象状态发生变化时所有依赖于它的对象都会得到通知和更新这样可以减少对象之间的显式耦合提高代码的可维护性以上只是举例了几种常见的设计模式实际上许多设计模式都有助于提高代码的可维护性选择合适的设计模式取决于具体的情况和需求需要综合考虑项目的特点团队的技术水平和开发成本等因素使用哪种设计模式可以提高代码的复用性设计模式中的许多模式都可以提高代码的复用性以下是一些常用的设计模式它们有助于代码的复用工厂模式通过工厂类创建对象将对象的创建与使用分离提供了一种灵活的对象创建方式方便代码复用和扩展单例模式确保一个类只有一个实例并提供全局访问点可以在系统中复用同一个实例适配器模式将一个类的接口转换成客户端所期望的另一个接口使得原本不兼容的类可以一起工作提高代码的复用性装饰器模式动态地给一个对象添加额外的功能通过装饰器类包装原始对象可以在不修改原始对象的情况下进行功能扩展提高代码的复用性观察者模式定义了一种一对多的依赖关系当一个对象的状态发生变化时所有依赖它的对象都会得到通知可以实现松耦合的对象之间的消息传递提高代码的复用性策略模式定义一系列算法将每个算法封装起来并使它们可以互换使得算法可以独立于客户端变化提高代码的复用性模板方法模式定义一个算法的骨架将一些步骤延迟到子类中实现可以复用算法的结构而具体的实现可以在子类中灵活变化这只是一小部分常用的设计模式每个设计模式都有不同的应用场景和优势选择适合的设计模式可以提高代码的复用性可维护性和扩展性在实际开发中根据具体需求和情况选择合适的设计模式是很重要的你在工作中是如何使用设计模式的在实际软件开发中使用设计模式可以提高代码的可读性可维护性和可扩展性降低耦合度增加代码的复用性以下是一些常见的使用场景和设计模式示例在面向对象的编程中可以使用工厂模式来创建对象将对象的创建与使用分离提高代码的灵活性和可复用性当需要适配不兼容的接口时可以使用适配器模式进行接口转换使得原本不兼容的类可以一起工作如果需要在不修改原始对象的情况下动态地给对象添加额外的功能可以使用装饰器模式当需要实现一对多的依赖关系实现事件驱动的消息传递时可以使用观察者模式在涉及多种算法选择和切换的情况下可以使用策略模式来封装和切换不同的算法实现当需要定义一个算法的骨架而将一些具体步骤延迟到子类中实现时可以使用模板方法模式这些只是一些示例实际使用设计模式的情况会根据具体的需求和应用场景而有所不同在软件开发中根据具体问题的复杂性和需求的变化选择合适的设计模式可以提高代码的质量和可维护性单例模式的多种写法单例模式是一种创建型设计模式它确保一个类只有一个实例并提供全局访问点以下是几种常见的单例模式的实现方式懒汉式线程不安全懒汉式线程安全饿汉式双重检查锁定静态内部类以上是几种常见的单例模式的实现方式每种方式都有其优缺点选择合适的实现方式取决于具体的需求和场景需要考虑线程安全性延迟加载性能等方面的因素如何破坏单例模式破坏单例模式的方法主要有以下几种反射破坏通过反射机制可以访问私有构造函数并创建多个实例可以构造函数中添加逻辑来防止反射破坏单例模式序列化与反序列化破坏当一个单例类被序列化后再次反序列化会创建一个新的实例可以通过在单例类中添加方法返回已有的实例从而避免破坏多线程环境下的破坏在多线程环境下如果没有合适的同步机制可能会创建多个实例可以使用双重检查锁定或者静态内部类等线程安全的方式来防止破坏克隆破坏如果单例类实现了接口并重写了方法可以通过克隆对象创建多个实例可以在方法中抛出异常阻止克隆破坏破坏单例模式需要在特殊情况下有意识地使用上述方法一般情况下单例模式是为了保证全局唯一性和访问性不建议破坏为什么说枚举是实现单例最好的方式枚举是实现单例模式最好的方式之一原因如下线程安全性枚举实例的创建是由在加载枚举类的时候保证的因此在多线程环境下也能保证单例的唯一性枚举的实例创建是线程安全的无需担心并发访问导致的多实例问题反射安全性枚举类的实例是在枚举类加载的时候被创建的而且枚举类不支持通过反射来创建实例即使使用反射强制访问枚举类的私有构造函数也无法创建新的实例因为枚举类的构造函数默认是私有的序列化安全性枚举类默认实现了接口因此可以安全地进行序列化和反序列化枚举实例在序列化和反序列化过程中保持单例的状态不会创建新的实例简洁性和可读性使用枚举实现单例模式非常简洁只需定义一个枚举类型枚举值即为单例实例同时使用枚举实现的单例模式也更易于理解和维护综上所述由于枚举具有线程安全反射安全序列化安全以及简洁可读的特性因此被认为是实现单例模式最好的方式之一不使用锁如何实现线程安全的单例除了使用如双重检查锁定来实现线程安全的单例模式还有其他几种方式可以实现线程安全的单例而不需要使用锁以下是其中两种常见的方式饿汉式在饿汉式中单例实例在类加载时就被创建因此不存在并发访问的问题由于实例的创建是在静态初始化阶段完成的所以可以保证线程安全性静态内部类在静态内部类中单例实例的创建是在调用方法时进行的利用了类加载的特性实现了懒加载由于静态内部类只有在被使用时才会被加载所以也能保证线程安全性这些方式都不需要显式地使用锁因此可以避免锁带来的性能开销不过需要注意的是这些方式在某些特殊情况下如序列化反射等可能仍然存在安全问题需要进行适当的处理来防止破坏单例模式什么是享元模式有哪些具体应用享元模式是一种结构型设计模式其目的是通过共享对象来减少内存使用和提高性能享元模式通过将对象的状态划分为内部状态和外部状态来实现对象的共享具体用场景和示例文字编辑器在文字编辑器中每个字符都是一个对象但是字符的属性如字体颜色等可以作为内部状态进行共享而文字的位置等属性可以作为外部状态进行传递线程池在线程池中每个线程对象可以看作是一个享元对象线程的内部状态如线程状态标识等是可以共享的而外部状态如任务是不同的通过外部传入资源池在数据库连接池连接池等资源管理中可以使用享元模式来共享和复用资源对象提高资源的利用率游戏中的角色在游戏中角色的外观动作等可以作为内部状态进行共享而角色的位置血量等信息可以作为外部状态总的来说享元模式适用于存在大量细粒度对象的场景通过共享内部状态来减少对象的开销提高系统的性能和资源利用率框架必会中和的区别在中和是两种不同的参数占位符使用方式占位符占位符是使用预编译的方式进行参数传递在语句中使用可以将参数值安全地替换到语句中并自动进行参数类型转换和防止注入攻击使用占位符时会将参数值作为一个整体传递给数据库因此可以有效地防止注入问题例如在上述示例中会被替换为具体的参数值并且会根据参数类型进行合适的转换占位符占位符是使用字符串拼接的方式进行参数传递在语句中使用可以将参数值直接拼接到语句中不进行预编译和参数类型转换使用占位符时需要注意潜在的安全风险因为参数值直接拼接到语句中可能会导致注入攻击例如在上述示例中会被替换为具体的参数值但不会进行参数类型转换和安全检查总结使用占位符可以提供更安全和可靠的参数传递方式适用于大多数情况使用占位符可以提供更灵活的参数传递方式但需要注意安全性和潜在的注入问题在选择使用还是时需要根据具体的需求和安全考虑来决定一般来说推荐使用占位符除非有特殊的需求需要使用占位符的编程步骤是什么样的创建通过创建通过执行数据库操作调用提交事务调用关闭会话编程有哪些不足之处是如何解决这些问题的编程在某些方面存在一些不足之处而通过提供一种更高级的抽象层来解决这些问题以下是编程的一些不足之处以及是如何解决这些问题的繁琐的代码编程需要编写大量的重复代码包括连接数据库创建和释放资源处理结果集等这使得代码冗长难以维护和理解通过提供一个简洁的配置文件和映射文件将数据库操作的细节抽象出来使得开发者只需关注语句和参数映射大大减少了繁琐的代码量与代码的耦合在编程中语句通常直接嵌入在代码中导致与代码紧密耦合不易于维护和修改使用了面向的思想将语句与代码分离通过映射文件将语句与对象进行映射使得与代码解耦提高了代码的可维护性和可读性手动参数设置和结果集处理在编程中需要手动设置参数并处理结果集包括类型转换结果集遍历等增加了开发的工作量和出错的可能性通过提供参数映射和结果集映射的功能自动处理参数设置和结果集转换开发者只需定义映射关系会自动完成参数设置和结果集处理简化了开发过程缺乏对象关系映射支持编程需要手动将数据库查询结果映射到对象中缺乏对对象关系映射的支持增加了开发的复杂性提供了强大的对象关系映射功能可以将查询结果自动映射到对象中支持一对一一对多多对一等复杂的关系映射简化了数据操作的过程缺乏缓存支持编程没有内置的缓存机制每次查询都需要访问数据库降低了性能提供了一级缓存和二级缓存的支持一级缓存是在同一个会话中的缓存可以减少对数据库的访问二级缓存是在多个会话中的缓存可以共享缓存结果提高了查询性能总的来说通过提供简洁的配置和映射文件解耦与代码自动处理参数和结果集支持对象关系映射和缓存等功能弥补了编程的不足之处提供了更便捷高效和可维护的数据库访问解决方案使用的接口调用时有哪些要求接口方法名和中定义的每个的相同接口方法的输入参数类型和中定义的每个的的类型相同接口方法的输出参数类型和中定义的每个的的类型相同文件中的即是接口的类路径中一级缓存与二级缓存在中存在一级缓存和二级缓存两种缓存机制一级缓存一级缓存是默认开启的缓存机制也被称为本地缓存一级缓存的作用范围是在同一个内部即在同一个会话期间多次执行相同的查询语句第一次查询结果会被缓存到一级缓存中后续的查询会直接从缓存中获取结果而不再去查询数据库一级缓存是基于对象引用的方式实现的因此在同一个会话期间如果对查询结果进行了修改例如更新插入删除等操作则会清空一级缓存以保证数据的一致性二级缓存二级缓存是的全局缓存机制作用范围是在同一个的中即多个共享同一个的缓存二级缓存可以跨越多个会话当多个会话执行相同的查询语句时第一个会话的查询结果会被缓存到二级缓存中后续的会话可以直接从缓存中获取结果而不再去查询数据库二级缓存是基于序列化的方式实现的因此要求缓存的对象必须是可序列化的默认情况下二级缓存是关闭的需要在的配置文件中显式配置开启需要注意的是一级缓存和二级缓存是独立的互不影响二级缓存是可选的可以根据需要选择是否开启二级缓存的使用需要注意数据的一致性和并发访问的问题特别是在多线程环境下总结一级缓存是在同一个会话期间的缓存而二级缓存是在同一个的命名空间中的缓存一级缓存是默认开启的二级缓存是可选的在实际应用中可以根据需求选择合适的缓存机制来提高查询性能理解一级缓存指的就是在中有一个数据区域是结构这个区域就是一级缓存区域一级缓存中的是由语句条件等信息组成一个唯一值一级缓存中的就是查询出的结果对象二级缓存指的就是同一个下的二级缓存中也有一个结构具体的结构和一级缓存是一样的和的结构都相同但是生命周期比一级缓存的生命周期要长在插入操作时如何返回主键在中可以通过以下几种方式来获取插入操作后生成的主键使用数据库的自增主键如果你的表使用了数据库的自增主键如的则在执行插入操作后可以通过来获取最后插入的主键在的映射文件中可以使用元素来配置获取主键的语句例如在执行插入操作后会自动执行中配置的语句并将获取到的主键值设置到对应的属性中使用数据库的序列如果你的表使用了数据库的序列如的序列则可以通过调用序列的函数来获取下一个序列值作为主键在的映射文件中可以使用元素来配置获取序列值的语句例如在执行插入操作前会先执行中配置的语句并将获取到的序列值设置到对应的属性中使用数据库的触发器如果你的表使用了数据库的触发器在触发器中可以获取插入操作后生成的主键并将其设置到对应的列中在中执行插入操作后可以通过查询插入的记录来获取主键例如执行插入操作获取插入后的主键根据你所使用的数据库和表的配置选择适合的方式来获取插入操作后的主键简述的插件运行原理如何编写一个插件答只支持针对这种接口的插件使用的动态代理为需要拦截的接口生成代理对象以实现接口方法拦截功能每当执行这种接口对象的方法时就会进入拦截方法具体就是的方法拦截那些你指定需要拦截的方法编写插件实现的接口并复写方法然后在给插件编写注解指定要拦截哪一个接口的哪些方法即可在配置文件中配置编写的插件执行具体的业务逻辑理解这段代码是一个注解用于拦截和处理数据库操作它使用了框架的面向切面编程功能下面是对这段代码的解释这是一个自定义注解用于定义拦截器的行为这是一个自定义注解用于指定拦截的方法签名表示拦截的目标类型是类表示拦截的方法名分别为和表示拦截的方法参数类型为和表示将这个类作为组件进行管理表示在拦截到方法调用后执行具体的业务逻辑这段代码的作用是在执行数据库查询更新或批量操作时拦截并添加额外的逻辑通过使用注解可以定义多个拦截规则每个规则对应一个或多个方法签名当拦截到符合条件的方法调用时会执行方法即执行具体的业务逻辑请注意这只是代码片段的一部分无法直接运行要完整地理解这段代码的功能需要结合完整的上下文和项目结构什么是容器框架的核心是容器容器创建对象将它们装配在一起配置它们并管理它们的完整生命周期容器使用依赖注入来管理组成应用程序的组件容器通过读取提供的配置元数据来接收对象进行实例化配置和组装的指令该元数据可以通过注解或代码提供是框架的两大核心之一就是控制反转简单的来说就是将创建对象的权利交由框架进行管理会根据配置文件去创建实例对象以及管理依赖以前创建对象的时机都是自己把握主动权在自己的手上现在可以使用的反射机制进行自动生产根据配置文件在运行时动态的去创建对象以及管理对象并调用对象的方法依赖注入是的一种具体实现方式就是通过容器获取对象并进行属性的赋值是一种思想而是一种实现如何实现一个容器配置文件配置包扫描路径递归包扫描获取文件反射确定需要交给管理的类对需要注入的类进行依赖注入配置文件中指定需要扫描的包路径定义一些注解分别表示访问控制层业务服务层数据持久层依赖注入注解获取配置文件注解从配置文件中获取需要扫描的包路径获取到当前路径下的文件信息及文件夹信息我们将当前路径下所有以结尾的文件添加到一个集合中进行存储遍历这个集合获取在类上有指定注解的类并将其交给容器定义一个安全的用来存储这些对象遍历这个容器获取到每一个类的实例判断里面是有有依赖其他的类的实例然后进行递归注入什么是依赖注入可以通过多少种方式完成依赖注入在依赖注入中您不必创建对象但必须描述如何创建它们您不是直接在代码中将组件和服务连接在一起而是描述配置文件中哪些组件需要哪些服务由容器将它们装配在一起通常依赖注入可以通过三种方式完成即构造函数注入注入接口注入在中仅使用构造函数和注入理解注解属于构造函数注入和方法注入两种方式的结合它通过注解的方式自动将匹配的依赖项注入到对象的字段中具体来说当使用注解时容器会自动查找与该注解匹配的并将其注入到被注解的字段中如果存在多个匹配的则会抛出异常可以通过设置注解来指定具体的和的区别是的子接口提供了更完整的功能继承因此支持国际化统一的资源文件访问方式提供在监听器中注册的事件同时加载多个配置文件载入多个有继承关系上下文使得每一个上下文都专注于一个特定的层次比如应用的层采用的是延迟加载形式来注入的即只有在使用到某个时调用才对该进行加载实例化这样我们就不能发现一些存在的的配置问题如果的某一个属性没有注入加载后直至第一次使用调用方法才会抛出异常它是在容器启动时一次性创建了所有的这样在容器启动时我们就可以发现中存在的配置错误这样有利于检查所依赖属性是否注入启动后预载入所有的单实例通过预载入单实例确保当你需要的时候你就不用等待因为它们已经创建好了相对于基本的唯一的不足是占用内存空间当应用程序配置较多时程序启动较慢通常以编程的方式被创建还能以声明的方式创建如使用和都支持的使用但两者之间的区别是需要手动注册而则是自动注册构造函数注入和注入构造函数注入和注入是依赖注入中两种常见的方式用于将依赖对象注入到目标对象中它们在注入方式和使用方式上有所不同构造函数注入构造函数注入是通过目标对象的构造函数来接收依赖对象的注入依赖对象在创建目标对象时通过构造函数的参数传递进来一旦目标对象被创建其依赖对象就不能再改变构造函数注入可以保证目标对象在创建时就具备了必要的依赖使得目标对象的状态是完整和一致的示例使用进行用户操作注入注入是通过目标对象的方法来接收依赖对象的注入依赖对象通过方法设置到目标对象中可以在任何时候通过调用方法来改变目标对象的依赖对象注入可以提供更灵活的依赖注入方式允许在运行时动态地改变依赖对象示例使用进行用户操作总结构造函数注入适用于那些在目标对象创建时就必须具备依赖对象的情况可以保证目标对象的依赖是不可变的注入适用于那些依赖对象可以在运行时动态改变的情况提供了更大的灵活性在选择注入方式时应根据具体的需求和设计考虑使用哪种方式或者在需要时结合两种方式使用提供了哪些配置方式基于配置所需的依赖项和服务在格式的配置文件中指定这些配置文件通常包含许多定义和特定于应用程序的配置选项它们通常以标签开头例如基于注解配置您可以通过在相关的类方法或字段声明上使用注解将配置为组件类本身而不是使用来描述装配默认情况下容器中未打开注解装配因此您需要在使用它之前在配置文件中启用它例如基于配置目前使用主流的配置是通过使用和来实现注解扮演与元素相同的角色类允许通过简单地调用同一个类中的其他方法来定义间依赖关系注解例如中的的作用域有哪些默认每个容器中只有一个的实例单例的模式由自身来维护该对象的生命周期是与容器一致的但在第一次被注入时才会创建每次请求都会创建一个新的实例被定义为在每个请求中创建一个单例对象也就是说在单个请求中都会复用这一个单例对象与范围类似确保每个中有一个的实例在过期后会随之失效被定义为在的生命周期中复用一个单例对象全局作用域和应用相关当你的应用部署在容器中工作时它包含很多如果你想要声明让所有的共用全局的存储变量的话那么这全局变量需要存储在中全局作用域与中的作用域效果相同组件扩展了对象的作用域在一次配置文件修改之后有效深入谈谈对的理解容器概念控制反转依赖注入容器实际上就是个里面存的是各种对象在里配置的节点在项目启动的时候会读取配置文件里面的节点根据全限定类名使用反射创建对象放到里扫描到打上上述注解的类还是通过反射创建对象放到里这个时候里就有各种对象了接下来我们在代码里需要用到里面的对象时再通过注入等注解里节点内的属性项目启动的时候会读取节点属性根据注入也会扫描这些注解根据类型或注入就是对象名控制反转没有引入容器之前对象依赖于对象那么对象在初始化或者运行到某一点的时候自己必须主动去创建对象或者使用已经创建的对象无论是创建还是使用对象控制权都在自己手上引入容器之后对象与对象之间失去了直接联系当对象运行到需要对象的时候容器会主动创建一个对象注入到对象需要的地方通过前后的对比不难看出来对象获得依赖对象的过程由主动行为变为了被动行为控制权颠倒过来了这就是控制反转这个名称的由来全部对象的控制权全部上缴给第三方容器所以容器成了整个系统的关键核心它起到了一种类似粘合剂的作用把系统中的所有对象粘合在一起发挥作用如果没有这个粘合剂对象与对象之间会彼此失去联系这就是有人把容器比喻成粘合剂的由来依赖注入获得依赖对象的过程被反转了控制被反转之后获得依赖对象的过程由自身管理变为了由容器主动注入依赖注入是实现的方法就是由容器在运行期间动态地将某种依赖关系注入到对象之中将一个类声明为的的注解有哪些我们一般使用注解自动装配要想把类标识成可用于注解自动装配的的类采用以下注解可实现通用的注解可标注任意类为组件如果一个不知道属于哪个层可以使用注解标注对应持久层即层主要用于数据库相关操作对应服务层主要涉及一些复杂的逻辑需要用到层对应控制层主要用户接受用户请求并调用层返回数据给前端页面的方式中的生命周期扫描生成并注册到中合并得到加载类实例化前实例化实例化后属性填充执行各种初始化前初始化初始化后放入单例池使用对象销毁容器关闭时调用中方法其中在实例化前后以及初始化前后程序员都可以通过或者接口的子接口进行扩展是容器中用于描述对象定义的接口什么是的自动装配有哪些方式的自动装配是容器在初始化时自动根据一定的规则将依赖注入到中的过程开启自动装配只需要在配置文件中定义属性属性有六种装配的方式缺省情况下自动配置是通过属性手动设定手动装配以或的方式明确指定属性值都是手动装配需要通过属性来连接根据的属性名称进行自动装配的属性名称是会将为的通过方法进行自动装配根据的类型进行自动装配的属性的类型为会将类型通过方法进行自动装配类似不过是应用于构造器的参数如果一个与构造器参数的类型形相同则进行自动装配否则导致失效构造函数的参数的类型为会将类型通过构造方法进行自动装配如果有默认的构造器则通过方式进行自动装配否则使用方式进行自动装配但是已将该值废弃如果有默认的构造器则通过方式进行自动装配否则使用方式进行自动装配由上级标签的属性确定自动装配可以在字段方法构造函数上使用相比自带的自动注入方式更加灵活中出现同名怎么办如果是在不同的注解中定义的同一个那么会直接报错如果是和出现同名那么的会生效扫描进来不会生效原因就是扫描进来的定义是最先被注册的而默认又是支持重写也即为因此底层就会以后解析的生成一个新且名字仍然是然后注册到中因此对于来说同一个的值以最后一次为准怎么解决循环依赖问题什么是循环依赖这里不会对的生命周期进行详细的描述只描述一下大概的过程的生命周期指的就是在中是如何生成的被管理的对象叫做的生成步骤如下扫描得到根据得到的去生成首先根据推断构造方法根据推断出来的构造方法反射得到一个对象暂时叫做原始对象填充原始对象中的属性依赖注入如果原始对象中的某个方法被了那么则需要根据原始对象生成一个代理对象把最终生成的代理对象放入单例池源码中叫做中下次时就直接从单例池拿即可可以看到对于中的的生成过程步骤还是很多的并且不仅仅只有上面的步还有很多很多比如回调初始化等等不详细讨论可以发现在中构造一个包括了这个步骤第步构造方法反射得到一个原始对象后需要给对象中的属性进行依赖注入那么这个注入过程是怎样的比如上文说的类类中存在一个类的属性所以当类生成了一个原始对象之后就会去给属性去赋值此时就会根据属性的类型和属性名去中去获取类所对应的单例如果此时中存在对应的那么直接拿来赋值给属性如果此时中不存在对应的则需要生成一个对应的然后赋值给属性问题就出现在第二种情况如果此时类在中还没有生成对应的那么就需要去生成就会经过的的生命周期那么在创建类的的过程中如果类中存在一个类的属性那么在创建的的过程中就需要类对应的但是触发类的创建的条件是类在创建过程中的依赖注入所以这里就出现了循环依赖创建依赖了属性触发创建依赖了属性需要但还在创建过程中从而导致创建不出来也创建不出来如何解决循环依赖底层最终解决靠的是四个其中三个缓存还有一个是判断有没有提前进行过的以及一个判断当前对象是否处于正在创建中缓存某个对应的经过了完整生命周期的也即我们平时说的单例池缓存提前通过原始对象进行了之后得到的代理对象原始对象还没有进行属性注入和后续的等生命周期缓存的是一个也就是一个表达式在创建一个时在每个的生成过程中都会提前暴露一个表达式并保存到三级缓存中这个表达式可能用到也可能用不到如果没有出现循环依赖依赖本那么这个表达式无用本按照自己的生命周期执行执行完后直接把本放入中即可如果出现了循环依赖依赖了本则从三级缓存中获取表达式并执行表达式得到一个之后的代理对象如果有的话如果无需则直接得到一个原始对象并把得到的对象放入二级缓存其实还要一个缓存就是它用来记录某个原始对象是否进行过了这个作用是去判断是不是出现了循环依赖也即是不是某个类是不是在创建中中的单例的线程安全问题中的默认是单例模式的框架并没有对进行多线程的封装处理如果是有状态的那就需要开发人员自己来进行线程安全的保证最简单的办法就是改变的作用域把改为这样每次请求就相当于是这样就可以保证线程的安全了有状态就是有数据存储功能无状态就是不会保存数据和层本身并不是线程安全的只是如果只是调用里面的方法而且多线程调用一个实例的方法会在内存中复制变量这是自己的线程的工作内存是安全的会操作数据库是带有状态的比如说数据库事务的事务管理器使用为不同线程维护了一套独立的副本保证线程之间不会互相影响是如何保证事务获取同一个的不要在中声明任何有状态的实例变量或类变量如果必须如此那么就使用把变量变为线程私有的如果的实例变量或类变量需要在多个线程之间共享那么就只能使用等这些实现线程同步的方法了什么是即面向切面编程它与面向对象编程相辅相成提供了与不同的抽象软件结构的视角在中我们以类作为我们的基本单元而中的基本单元是切面谈谈对的理解系统是由许多不同的组件所组成的每一个组件各负责一块特定功能除了实现自身核心功能之外这些组件还经常承担着额外的职责例如日志事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去这些系统服务经常被称为横切关注点因为它们会跨越系统的多个组件当我们需要为分散的对象引入公共行为的时候则显得无能为力也就是说允许你定义从上到下的关系但并不适合定义从左到右的关系例如日志功能日志代码往往水平地散布在所有对象层次中而与它所散布到的对象的核心功能毫无关系在设计中它导致了大量代码的重复而不利于各个模块的重用将程序中的交叉业务逻辑比如安全日志事务等封装成一个切面然后注入到目标对象具体业务逻辑中去可以对某个对象或某些对象的功能进行增强比如对象中的方法进行增强可以在执行某个方法之前额外的做一些事情在某个方法执行之后额外的做一些事情有哪些实现方式实现的技术主要分为两大类静态代理指使用框架提供的命令进行编译从而在编译阶段就可生成代理类因此也称为编译时增强编译时编织特殊编译器实现类加载时编织特殊的类加载器实现动态代理在运行时在内存中临时生成动态代理类因此也被称为运行时增强动态代理通过反射来接收被代理的类并且要求被代理的类必须实现一个接口动态代理的核心是接口和类动态代理如果目标类没有实现接口那么会选择使用来动态代理目标类是一个代码生成的类库可以在运行时动态的生成某个类的子类注意是通过继承的方式做的动态代理因此如果某个类被标记为那么它是无法使用做动态代理的框架中用到了哪些设计模式工厂设计模式简单工厂由一个工厂类根据传入的参数动态决定应该创建哪一个产品类中的就是简单工厂模式的体现根据传入一个唯一的标识来获得对象但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定工厂方法实现了接口的是一类叫做的其特点是会在使用调用获得该时会自动调用该的方法所以返回的不是这个而是这个方法的返回值单例模式保证一个类仅有一个实例并提供一个访问它的全局访问点对单例的实现中的单例模式完成了后半句话即提供了全局的访问点但没有从构造器级别去控制单例这是因为管理的是任意的对象适配器模式定义了一个适配接口使得每一种有一种对应的适配器实现类让适配器代替执行相应的方法这样在扩展时只需要增加一个适配器类就完成了的扩展了装饰器模式动态地给一个对象添加一些额外的职责就增加功能来说模式相比生成子类更为灵活中用到的装饰器模式在类名上有两种表现一种是类名中含有另一种是类名中含有代理模式切面在应用运行的时刻被织入一般情况下在织入切面时容器会为目标对象创建动态的创建一个代理对象就是以这种方式织入切面的织入把切面应用到目标对象并创建新的代理对象的过程观察者模式的事件驱动模型使用的是观察者模式中模式常用的地方是的实现策略模式框架的资源访问接口该接口提供了更强的资源访问能力框架本身大量使用了接口来访问底层资源模板方法模式父类定义了骨架调用哪些方法及顺序某些特定方法由子类实现中等以结尾的对数据库操作的类它们就使用到了模板模式事务实现方式有哪些以及原理编程式事务管理这意味着你可以通过编程的方式管理事务这种方式带来了很大的灵活性但很难维护声明式事务管理这种方式意味着你可以将事务管理和业务代码分离你只需要通过注解或者配置管理事务注解就是声明式事务首先事务这个概念是数据库层面的只是基于数据库中的事务进行了扩展以及提供了一些能让程序员更加方便操作事务的方式比如我们可以通过在某个方法上增加注解就可以开启事务这个方法中所有的都会在一个事务中执行统一成功或失败在一个方法上加了注解后会基于这个类生成一个代理对象会将这个代理对象作为当在使用这个代理对象的方法时如果这个方法上存在注解那么代理逻辑会先把事务的自动提交设置为然后再去执行原本的业务逻辑方法如果执行业务逻辑方法没有出现异常那么代理逻辑中就会将事务进行提交如果执行业务逻辑方法出现了异常那么则会将事务进行回滚当然针对哪些异常回滚事务是可以配置的可以利用注解中的属性进行配置默认情况下会对和进行回滚事务的隔离级别事务隔离级别就是数据库的隔离级别外加一个默认级别未提交读提交读不可重复读可重复读可串行化注意数据库的配置隔离级别是而配置的隔离级别是请问这时隔离级别是以哪一个为准以配置的为准如果设置的隔离级别数据库不支持效果取决于数据库事务定义的传播规则多个事务方法相互调用时事务如何在这些方法间传播方法是一个事务的方法方法执行过程中调用了方法那么方法有无事务以及方法对事务的要求不同都会对方法的事务具体执行造成影响同时方法的事务对方法的事务执行也有影响这种影响具体是什么就由两个方法所定义的事务传播类型所决定默认的事务传播类型如果当前没有事务则自己新建一个事务如果当前存在事务则加入这个事务当前存在事务则加入当前事务如果当前没有事务就以非事务方法执行当前存在事务则加入当前事务如果当前事务不存在则抛出异常创建一个新事务如果存在当前事务则挂起该事务以非事务方式执行如果当前存在事务则挂起当前事务不使用事务如果当前事务存在则抛出异常如果当前事务存在则在嵌套事务中执行否则的操作一样开启一个事务和的区别是新建一个事务并且新开启的这个事务与原有事务无关而则是当前存在事务时我们把当前事务称之为父事务会开启一个嵌套事务称之为一个子事务在情况下父事务回滚时子事务也会回滚而在情况下原有事务回滚不会影响新开启的事务和的区别情况下调用方存在事务时则被调用方和调用方使用同一事务那么被调用方出现异常时由于共用一个事务所以无论调用方是否其异常事务都会回滚而在情况下被调用方发生异常时调用方可以其异常这样只有子事务回滚父事务不受影响事务什么时候会失效事务的原理是进行了切面增强那么失效的根本原因是这个不起作用了常见情况有如下几种发生自调用类里面使用调用本类的方法通常省略此时这个对象不是代理类而是该类的实例对象本身解决方法很简单让那个变成该类的的代理类实例对象即可方法不是的数据库不支持事务没有被管理异常被吃掉事务不会回滚或者抛出的异常没有被定义默认为工作原理了解吗流程说明重要用户发送请求至前端控制器收到请求调用处理器映射器处理器映射器找到具体的处理器可以根据配置注解进行查找生成处理器及处理器拦截器如果有则生成一并返回给调用处理器适配器经过适配调用具体的处理器也叫后端控制器执行完成返回将执行结果返回给将传给视图解析器解析后返回具体根据进行渲染视图即将模型数据填充至视图中响应用户简单介绍的核心组件也就是处理器它直接应对着中的也就是层它的具体表现形式有很多可以是类也可以是方法在层中标注的所有方法都可以看成是一个只要可以实际处理请求就可以是处理器映射器根据用户请求的资源来查找的在中会有很多请求每个请求都需要一个处理具体接收到一个请求之后使用哪个进行这就是需要做的事适配器因为中的可以是任意的形式只要能处理请求就但是需要的处理方法的结构却是固定的都是以和为参数的方法如何让固定的处理方法调用灵活的来进行处理呢这就是要做的事情是用来干活的工具用于根据需要干的活找到相应的工具是使用工具干活的人其它组件都是用来干活的在干活的过程中难免会出现问题出问题后怎么办呢这就需要有一个专门的角色对异常情况进行处理在中就是具体来说此组件的作用是根据异常设置之后再交给方法进行渲染用来将类型的视图名和解析为类型的视图是用来渲染页面的也就是将程序返回的参数填入模板里生成也可能是其它类型文件这里就有两个关键问题使用哪个模板用什么技术规则填入参数这其实是主要要做的工作需要找到渲染所用的模板和所用的技术也就是视图的类型进行渲染具体的渲染过程则交由不同的视图自己完成是根据查找但有的处理完后并没有设置也没有设置这时就需要从获取了如何从中获取就是要做的事情了在容器里只可以配置一个所以所有到的转换规则都要在一个里面全部实现解析视图需要两个参数一是视图名另一个是视图名是处理器返回的是从哪里来的这就是要做的事情用于从解析出就是之类表示一个区域有了这个就可以对不同区域的用户显示不同的结果主要有两个地方用到了一是视图解析的时候二是用到国际化资源或者主题的时候用于解析主题中一个主题对应一个文件里面存放着跟当前主题相关的所有资源如图片样式等的主题也支持国际化同一个主题不同区域也可以显示不同的风格中跟主题相关的类有和主题是通过一系列资源来具体体现的要得到一个主题的资源首先要得到资源的名称这是的工作然后通过主题名称找到对应的主题可以理解为一个配置文件这是的工作最后从主题中获取资源就可以了用于处理上传请求处理方法是将普通的包装成后者可以直接调用方法获取如果上传多个文件还可以调用得到结构的此组件中一共有三个方法作用分别是判断是不是上传请求将包装成处理完后清理上传过程中产生的临时资源用来管理的主要用在中传递参数注解有什么用注解标记一个类为控制器会将扫描到该注解的类然后扫描这个类下面带有注解的方法根据注解信息为这个方法生成一个对应的处理器对象在上面的和组件中讲到过当然除了添加注解这种方式以外你还可以实现提供的或者接口对应的实现类也会被作为一个处理器对象和有什么区别注解在基础上增加了注解更加适合目前前后端分离的架构下提供返回例如数据格式当然返回什么样的数据格式根据客户端的请求头来决定和注解的不同之处在哪里可注解在类和方法上仅可注册在方法上可进行等请求方法是的请求方法的特例目的是为了提高清晰度和两个注解的区别两个注解都用于方法参数获取参数值的方式不同注解的参数从请求携带的参数中获取而注解从请求的中获取返回格式使用什么注解可以使用注解或者使用包含注解的注解当然还是需要配合相应的支持格式化的实现类例如默认使用什么是拦截器以及如何使用它拦截器是一种用于拦截和处理请求的组件它可以在请求的前后进行处理并对请求进行修改或添加额外的功能拦截器可以用于实现一些通用的功能例如身份验证日志记录性能监控等以下是使用拦截器的步骤创建拦截器类创建一个实现接口的拦截器类拦截器类可以包含在应用程序的任何位置例如包下的一个单独类或者一个独立的模块实现拦截器方法在拦截器类中实现和等方法方法在请求处理之前执行可以进行一些前置处理例如身份验证权限检查等方法在请求处理之后视图渲染之前执行可以对模型数据进行处理或添加额外的功能方法在整个请求完成之后执行可以进行一些资源清理或日志记录等操作配置拦截器在配置文件如配置文件或配置类中配置拦截器通过注册拦截器类的方式将其添加到拦截器链中可以指定拦截器的拦截路径模式或排除路径以确定哪些请求会被拦截测试拦截器启动应用程序并发送请求进行测试拦截器将根据配置的规则拦截相应的请求并执行拦截器方法通过使用拦截器您可以在请求的前后进行处理实现一些通用的功能和逻辑拦截器提供了一种灵活的方式来对请求进行拦截和处理使您能够在应用程序中添加额外的功能和行为为什么要用在使用框架进行开发的过程中需要配置很多框架包的依赖如等而这些配置通常都是重复添加的而且需要做很多框架使用及环境参数的重复配置如开启注解配置日志等致力于弱化这些不必要的操作提供默认配置当然这些默认配置是可以按需修改的快速搭建开发和运行应用以下是使用的一些好处自动配置使用基于类路径和应用程序上下文的智能默认值当然也可以根据需要重写它们以满足开发人员的需求创建项目时可以选择选择需要的功能将为你管理依赖关系项目可以打包成文件可以使用命令从命令行将应用程序作为独立的应用程序运行在开发应用程序时会配置一个嵌入式服务器以便它可以作为独立的应用程序运行是默认的当然你也可以配置或包括许多有用的非功能特性例如安全和健康检查自动配置原理自动配置类由各个提供使用定义配置类放到下使用扫描下的配置类使用导入自动配置类详细流程原理分析参考毕业精讲课中如何实现对不同环境的属性配置文件的支持支持不同环境的属性配置文件切换通过创建文件其中是具体的环境标识名称例如用于开发环境用于测试环境用于环境如果要想使用文件则在文件中添加如果要想使用文件则在文件中添加的核心注解是哪个它主要由哪几个注解组成的启动类上面的注解是它也是的核心注解主要组合包含了以下个注解组合了注解实现配置文件的功能打开自动配置的功能也可以关闭某个自动配置的选项如关闭数据源自动配置功能组件扫描你如何理解中的使用使用如果需要引入等框架需要到中定义需要的就是定义一个的包写一个配置类将这些定义在里面然后在包的中写入该配置类会按照约定来加载该配置类开发人员只需要将相应的包依赖进应用进行相应的属性配置使用默认配置时不需要配置就可以直接进行代码开发使用对应的功能了比如的工作原理是什么在启动的时候会干这几件事情在启动时会去依赖的包中寻找文件然后根据文件中配置的包去扫描项目所依赖的包根据配置加载类根据注解的条件进行自动配置并将注入总结一下其实就是在启动的时候按照约定去读取的配置信息再根据配置信息对资源进行初始化并注入到容器中这样启动完毕后就已经准备好了一切资源使用过程中直接注入对应资源即可什么是嵌入式服务器为什么要使用嵌入式服务器节省了下载安装应用也不需要再打包然后放到目录下再运行只需要一个安装了的虚拟机就可以直接在上面部署应用程序了已经内置了运行方法时会去启动并利用的机制加载断路器的作用是什么断路器是一种用于构建弹性容错和容灾机制的开源库它提供了一种通过隔离和控制远程服务调用的方式以防止由于服务故障或延迟而导致的级联故障断路器的作用如下故障隔离断路器通过将远程服务调用封装在一个独立的断路器中可以隔离故障的影响范围当远程服务发生故障或延迟时断路器可以快速失败并返回预定义的默认值而不会影响整个系统的稳定性容错处理断路器可以在远程服务不可用时提供备用方案通过配置降级逻辑可以在远程服务故障时返回预先定义的备用数据以保证系统的可用性和稳定性自动恢复断路器具备自我修复的能力它会定期尝试恢复远程服务的调用以检查其可用性当远程服务恢复正常时断路器会逐渐恢复对该服务的调用并重新建立正常的调用链路实时监控断路器提供了实时监控和度量功能可以收集和展示远程服务调用的各项指标如调用次数失败率响应时间等这些指标可以帮助开发人员和运维人员了解系统的健康状况并进行故障排查和性能优化通过使用断路器可以有效地处理分布式系统中的服务故障和延迟问题提高系统的容错性和可用性它是构建弹性和可靠微服务架构的重要组件之一的核心组件有哪些以及作用服务注册与发现注册每个服务都向登记自己提供服务的元数据包括服务的地址端口号版本号通信协议等将各个服务维护在了一个服务清单中双层第一层是服务名第二层是实例名是服务地址加端口同时对服务维持心跳剔除不可用的服务集群各节点相互注册每个实例中都有一样的服务清单发现注册的服务之间调用不需要指定服务地址而是通过服务名向注册中心咨询并获取所有服务实例清单缓存到本地然后实现服务的请求访问服务间发起请求的时候基于做负载均衡从个服务的多台机器中选择台被调用方的服务地址有多个也是通过发起请求来进行的调用只不过是通过调用服务名的地址来实现的虽然说不用去具体请求服务实例的地址或域名了但是每调用一个接口都还要手动去发起请求发起请求是通过的线程池来的不同的服务不同的线程池实现了不同服务调的隔离通过统计接口超时次数返回默认值实现服务熔断和降级如果前端移动端要调后端系统统从关进由关转发请求给对应的服务通过与进行整合将自身注册为下的应用从下获取所有服务的实例来进行服务的路由还提供了一套过滤器机制开发者可以自己指定哪些规则的请求需要执行校验逻辑只有通过校验逻辑的请求才会被路由到具体服务实例上否则返回错误提示提供服务器端和客户端服务器存储后端的默认实现使用因此它轻松支持标签版本的配置环境以及可以访问用于管理内容的各种工具这个还是静态的需要得配合实现动态的配置更新如何注册服务在框架中使用服务需要进行以下步骤来注册和启用组件添加依赖在项目的构建配置文件如中添加所需的依赖例如可以添加依赖来使用服务注册与发现组件配置文件在应用程序的配置文件如或中配置服务的相关属性具体的配置内容取决于所使用的组件例如使用服务注册与发现时需要指定服务器的地址和端口等信息注解标记在应用程序的主类上添加相应的注解来启用服务具体的注解取决于所使用的组件例如使用服务注册与发现时可以在主类上添加注解运行环境确保应用程序运行的环境中包含了所需的组件的运行实例例如如果使用服务注册与发现需要确保服务器正常运行下面是一个使用服务注册与发现的示例添加依赖配置文件主类上添加注解通过以上步骤你就可以在应用程序中注册和启用服务了具体的步骤和配置内容可能会根据所使用的组件而有所不同你可以根据具体的需求和文档进行相应的配置和操作微服务优点是什么每个服务都足够内聚代码易于理解提高开发效率一项服务只做一件事微服务可以由小团队单独开发微服务是松耦合的是有功能意义的服务可以用不同的语言开发面向接口编程易于与第三方集成微服务只是业务逻辑的代码不会和一起使用或其它界面组合可灵活搭配连接公共库和独立库微服务的缺点是什么分布式系统的责任多服务运维难度随着服务的增加运维压力也在增加系统部署依赖服务间通信成本数据一致性系统集成测试性能监控是什么是框架中的一个组件用于在分布式系统中实现消息总线功能它建立在和之上提供了一种方便的方式来在微服务架构中进行消息传递和事件广播的主要功能是通过消息代理将分布式系统中的各个微服务实例连接起来使它们能够方便地进行消息的发送和接收它使用轻量级的消息代理如或作为中间件实现了消息的广播和订阅机制使用可以实现以下功能配置中心的刷新通过发送特定的消息可以触发所有微服务实例重新加载配置信息从而实现配置的动态更新事件广播可以将事件消息广播给所有微服务实例用于实现系统内的事件驱动机制监控和管理可以通过消息传递的方式实现对微服务实例的监控和管理例如获取实例的健康状态查看日志等使用了发布订阅模式其中一个微服务实例作为消息的生产者将消息发送到消息代理而其他微服务实例作为消息的消费者订阅感兴趣的消息并进行相应的处理通过这种方式可以实现微服务之间的解耦和灵活的消息传递需要注意的是并不是用于高频率的数据传输或大规模的消息通信而是用于在分布式系统中进行配置更新事件广播和管理操作对于更复杂的消息通信需求可以结合使用等组件来实现总之提供了一种简单而强大的方式来实现分布式系统中的消息总线功能实现了微服务之间的解耦和灵活的消息传递它是构建基于的分布式系统的重要工具之一什么是服务熔断什么是服务降级概念不同服务熔断其实很好理解就是一个断开的过程下游的服务因为某种原因突然变得不可用或响应过慢上游服务为了保证自己整体服务的可用性不再继续调用目标服务直接返回快速释放资源如果目标服务情况好转则恢复调用服务降级降低级别的意思它是指程序在出现问题时仍能保证有限功能可用的一种机制因此对于降级是一种退而求其次的选择而熔断却是整体不可用触发原因不太一样服务熔断一般是某个服务下游服务故障引起而服务降级一般是从整体负荷考虑管理层次不太一样服务熔断是一个框架层次的处理每个服务都要考虑无业务层级之分服务降级是业务层次的处理比如降级一般是从最非核心服务开始服务熔断是服务降级的一种特殊情况他是防止服务雪崩而采取的措施系统发生异常或者延迟或者流量太大都会触发该服务的服务熔断措施链路熔断返回兜底方法这是对局部的一种保险措施服务降级是对系统整体资源的合理分配区分核心服务和非核心服务对某个服务的访问延迟时间异常等情况做出预估并给出兜底方法这是一种全局性的考量对系统整体负荷进行管理其实一句话降级是一种设计思想在层面就是一个接口而熔断是降级的不同实现方式在层面就是这个接口的一个实现类熔断和降级的关系负载均衡的意义是什么负载均衡是指将网络或计算资源分配给多个服务器或设备以达到提高系统性能可扩展性和可靠性的目的它在分布式系统中起到重要的作用具有以下几个重要的意义提高系统性能负载均衡将请求均匀地分配给多个服务器避免了单个服务器过载的情况通过合理地分配负载可以充分利用系统的资源提高系统的吞吐量和响应速度实现高可用性通过将请求分发到多个服务器即使其中某个服务器发生故障或不可用仍然可以继续提供服务负载均衡器能够检测到故障服务器并将请求转发到其他正常工作的服务器从而实现系统的高可用性和容错性支持系统扩展随着用户量和业务需求的增加单个服务器可能无法满足系统的需求负载均衡器可以根据实际情况动态地添加或删除服务器实现系统的水平扩展通过增加服务器数量可以提高系统的处理能力和并发性能优化资源利用负载均衡器可以根据服务器的负载情况智能地分配请求使每个服务器的负载相对均衡这样可以避免某些服务器过载而其他服务器处于空闲状态的情况最大限度地提高资源的利用率简化系统管理通过使用负载均衡器可以将多个服务器组织成一个逻辑集群对外提供统一的入口这样可以简化系统的管理和维护工作减少对客户端的影响提高系统的可维护性和可管理性总之负载均衡在分布式系统中具有重要的意义它能够提高系统性能可用性和可扩展性优化资源利用简化系统管理通过合理地分配负载负载均衡器能够实现高效稳定和可靠的系统运行和有什么联系和区别和是两个相互关联但又有不同重点的项目框架是一个用于简化和加速应用程序开发的框架它提供了一种约定优于配置的方式通过自动配置和默认值可以快速搭建和部署独立的可执行的应用程序使得开发者可以更专注于业务逻辑的实现而无需手动配置复杂的配置文件是一个用于构建分布式系统的工具集合它基于提供了一系列的开箱即用的分布式系统模块和服务包含了多个组件如服务注册与发现服务调用断路器网关配置中心等这些组件提供了分布式系统开发中常用的功能和解决方案联系和区别联系是框架的一部分它为应用程序提供了快速开发的能力而是构建分布式系统的工具集合基于提供了一系列分布式系统模块和服务区别主要关注于简化和加速单个应用程序的开发提供了自动配置快速启动等特性而主要关注于构建分布式系统提供了服务注册与发现服务调用负载均衡断路器等组件用于处理分布式系统中的各种挑战综上所述和是相互关联的为应用程序提供了快速开发的能力而则在此基础上提供了构建分布式系统的工具和解决方案使用可以快速搭建单个应用程序而使用可以在分布式系统中构建和管理多个相互协作的微服务必会什么是线程池线程池有哪些线程池就是事先将多个线程对象放到一个容器中当使用的时候就不用线程而是直接去池中拿线程即可节省了开辟子线程的时间提高的代码执行效率在的中提供了生成多种线程池的静态方法然后调用他们的方法即可创建一个可缓存线程池如果线程池长度超过处理需要可灵活回收空闲线程若无可回收则新建线程这种类型的线程池特点是工作线程的创建数量几乎没有限制其实也有限制的数目为这样可灵活的往线程池中添加线程如果长时间没有往线程池中提交任务即如果工作线程空闲了指定的时间默认为分钟则该工作线程将自动终止终止后如果你又提交了新的任务则线程池重新创建一个工作线程在使用时一定要注意控制任务的数量否则由于大量线程同时运行很有会造成系统瘫痪创建一个指定工作线程数量的线程池每当提交一个任务就创建一个工作线程如果工作线程数量达到线程池初始的最大数则将提交的任务存入到池队列中是一个典型且优秀的线程池它具有线程池提高程序效率和节省创建线程时所耗的开销的优点但是在线程池空闲时即线程池中没有可运行任务时它不会释放工作线程还会占用一定的系统资源创建一个单线程化的即只创建唯一的工作者线程来执行任务它只会用唯一的工作线程来执行任务保证所有任务按照指定顺序优先级执行如果这个线程异常结束会有另一个取代它保证顺序执行单工作线程最大的特点是可保证顺序地执行各个任务并且在任意给定的时间不会有多个线程是活动的创建一个定长的线程池而且支持定时的以及周期性的任务执行例如延迟秒执行这种线程池底层全部是对象的实现阿里规范手册中规定线程池采用自定义的实际开发也是对象有哪些参数都有什么作用怎么设定核心线程数和最大线程数拒绝策略有哪些重点参数与作用共个参数核心线程数在中有一个与它相关的配置默认为当为时核心线程会一直存活哪怕是一直空闲着而当为时核心线程空闲时间超过时会被回收最大线程数线程池能容纳的最大线程数当线程池中的线程达到最大时此时添加任务将会采用拒绝策略默认的拒绝策略是抛出一个运行时错误值得一提的是当初始化时用的工作队列为时这个值将无效存活时间当非核心空闲超过这个时间将被回收同时空闲核心线程是否回收受影响的单位任务队列常用有三种队列即无界队列有界队列线程工厂是一个接口用来创建通过线程工厂可以对线程的一些属性进行定制默认直接新建线程也是一个接口只有一个方法当线程池中的资源已经全部使用添加新线程被拒绝时会调用的法默认是抛出一个运行时异常线程池大小设置需要分析线程池执行的任务的特性密集型还是密集型每个任务执行的平均时长大概是多少这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系如果是密集型主要是执行计算任务响应时间很快一直在运行这种任务的利用率很高那么线程数的配置应该根据核心数来决定核心数最大同时执行线程数加入核心数为那么服务器最多能同时执行个线程过多的线程会导致上下文切换反而使得效率降低那线程池的最大线程数可以配置为核心数如果是密集型主要是进行操作执行操作的时间较长这是出于空闲状态导致的利用率不高这种情况下可以增加线程池的大小这种情况下可以结合线程的等待时长来做判断等待时间越高那么线程数也相对越多一般可以配置核心数的倍一个公式线程池设定最佳线程数目线程池设定的线程等待时间线程时间线程时间数目这个公式的线程时间是预估的程序单个线程在上运行的时间通常使用测试大量运行次数求出平均值拒绝策略直接抛出异常默认策略用调用者所在的线程来执行任务丢弃阻塞队列中靠最前的任务并执行当前任务直接丢弃任务当然也可以根据应用场景实现接口自定义饱和策略如记录日志或持久化存储不能处理的任务常见线程安全的并发容器有哪些采用写时复制实现线程安全采用分段锁的方式实现线程安全原子类了解多少原理是什么中的包提供了一组原子类用于在多线程环境中执行原子操作而无需使用显式的锁这些原子类使用特殊的指令来确保操作的原子性从而避免了使用锁带来的性能开销这些原子类的实现依赖于底层硬件架构提供的原子操作指令通常这些指令在现代处理器上是硬件级别的支持确保对内存的读写是原子的这使得在不使用锁的情况下可以在多线程环境中执行某些操作而不会导致竞态条件以下是一些常见的包中的原子类以及它们的一些实现原理这些类使用操作实现原子性是一种乐观锁定机制它尝试原子地将一个值更新为新值但只有在当前值等于预期值时才成功否则它会重新尝试操作是由处理器提供的原子性操作指令支持的类使用实现的实现通常依赖于底层处理器的指令这些类提供了对数组元素的原子性访问它们也使用操作但应用于数组的特定位置这些类提供了对对象字段的原子性更新它们使用了反射和操作来实现总体来说原子类的实现依赖于底层硬件提供的原子性操作指令这通常是现代处理器架构的一部分这使得原子类能够在无锁的情况下执行一些基本的原子操作提高了多线程环境中的性能在高并发的情况下原子类是一种有用的工具能够提供线程安全的操作而无需显式地使用锁底层实现是什么底层是什么有什么区别原理方法级的同步是隐式即无需通过字节码指令来控制的它实现在方法调用和返回操作之中可以从方法常量池中的方法表结构中的访问标志区分一个方法是否同步方法当方法调用时调用指令将会检查方法的访问标志是否被设置如果设置了执行线程将先持有虚拟机规范中用的是管程一词然后再执行方法最后再方法完成无论是正常完成还是非正常完成时释放代码块的同步是利用和这两个字节码指令它们分别位于同步代码块的开始和结束位置当执行到指令时当前线程试图获取对象的所有权如果未加锁或者已经被当前线程所持有就把锁的计数器当执行指令时锁计数器当锁计数器为时该锁就被释放了如果获取对象失败该线程则会进入阻塞状态直到其他线程释放锁原理的存储结构一个类型状态值用于锁的状态变更一个双向链表用于存储等待中的线程获取锁的过程本质上是通过来获取状态值修改如果当场没获取到会将该线程放在线程等待链表中释放锁的过程修改状态值调整等待链表大量使用自旋因此根据特性建议使用在低锁冲突的情况下与的区别的加锁和解锁都是由代码配合方法调用操作系统的相关方法实现的而的加锁和解锁的过程是由管理的当一个线程使用获取锁时若锁被其他线程占用着那么当前只能被阻塞直到成功获取锁而则提供超时锁和可中断等更加灵活的方式在未能获取锁的条件下提供一种退出的机制一个锁内部可以有多个实例即有多路条件队列而只有一路条件队列同样也提供灵活的阻塞方式在未获得通知之前可以通过中断线程以及设置等待时限等方式退出条件队列对线程的同步仅提供独占模式而即可以提供独占模式也可以提供共享模式关键字接口类自动加锁和释放锁需要手动调用方法释放锁层面的锁层面的锁非公平锁可以选择公平或者非公平锁锁是一个对象并且锁的信息保存在了对象中代码中通过类型的标识有一个锁升级的过程无数据库对数据库去重的关键字是什么在数据库中可以使用关键字来进行去重操作关键字用于查询语句的子句中用于返回唯一的结果集去除重复的行例如以下是使用关键字进行去重的示例上述示例中和是要查询的列名是要查询的表名查询结果将返回去重后的唯一行需要注意的是关键字会对查询结果的所有列进行去重如果只想对部分列进行去重可以指定相应的列名多表连接有哪些方式怎么用的这些连接都有什么区别连接方式左连接右连接内连接使用方法左连接右连接内连接其中可以省略区别内连接在两张表进行连接查询时只保留两张表中完全匹配的结果集在两张表进行连接查询时会返回左表所有的行即使在右表中没有匹配的记录在两张表进行连接查询时会返回右表所有的行即使在左表中没有匹配的记录索引的基本原理索引用来快速地寻找那些具有特定值的记录如果没有索引一般来说执行查询时遍历整张表索引的原理就是把无序的数据变成有序的查询把创建了索引的列的内容进行排序对排序结果生成倒排表在倒排表内容上拼上数据地址链在查询的时候先拿到倒排表内容再取出数据地址链从而拿到具体数据说一下索引的优势和劣势优势唯一索引可以保证数据库表中每一行数据的唯一性索引可以加快数据查询速度减少查询时间劣势创建索引和维护索引要耗费时间索引需要占物理空间除了数据表占用数据空间之外每一个索引还要占用一定的物理空间给表中的数据进行增删改的时候索引也要动态的维护聚簇和非聚簇索引的区别都是树的数据结构聚簇索引将数据存储与索引放到了一块并且是按照一定的顺序组织的找到索引也就找到了数据数据的物理存放顺序与索引顺序是一致的即只要索引是相邻的那么对应的数据一定也是相邻地存放在磁盘上的非聚簇索引叶子节点不存储数据存储的是数据行地址也就是说根据索引查找到数据行的位置再去磁盘查找数据这个就有点类似一本书的目录比如我们要找第三章第一节那我们先在这个目录里面找找到对应的页码后再去对应的页码看文章优势查询通过聚簇索引可以直接获取数据相比非聚簇索引需要第二次查询非覆盖索引的情况下效率要高聚簇索引对于范围查询的效率很高因为其数据是按照大小排列的聚簇索引适合用在排序的场合非聚簇索引不适合劣势维护索引很昂贵特别是插入新行或者主键被更新导致要分页的时候建议在大量插入新行后选在负载较低的时间段通过优化表因为必须被移动的行数据可能造成碎片使用独享表空间可以弱化碎片表因为使用随机作为主键使数据存储稀疏这就会出现聚簇索引有可能有比全表扫面更慢所以建议使用的作为主键如果主键比较大的话那辅助索引将会变的更大因为辅助索引的叶子存储的是主键值过长的主键值会导致非叶子节点占用占用更多的物理空间中一定有主键主键一定是聚簇索引不手动设置则会使用索引没有索引则会使用数据库内部的一个行的隐藏来当作主键索引在聚簇索引之上创建的索引称之为辅助索引辅助索引访问数据总是需要二次查找非聚簇索引都是辅助索引像复合索引前缀索引唯一索引辅助索引叶子节点存储的不再是行的物理位置而是主键值使用的是非聚簇索引没有聚簇索引非聚簇索引的两棵树看上去没什么不同节点的结构完全一致只是存储的内容不同而已主键索引树的节点存储了主键辅助键索引树存储了辅助键表数据存储在独立的地方这两颗树的叶子节点都使用一个地址指向真正的表数据对于表数据来说这两个键没有任何差别由于索引树是独立的通过辅助键检索无需访问主键的索引树如果涉及到大数据量的排序全表扫描之类的操作的话还是占优势些因为索引所占空间小这些操作是需要在内存中完成的索引的数据结构各自优劣索引的数据结构和具体存储引擎的实现有关在中使用较多的索引有索引树索引等存储引擎的默认索引实现为树索引对于哈希索引来说底层的数据结构就是哈希表因此在绝大多数需求为单条记录查询的时候可以选择哈希索引查询性能最快其余大部分场景建议选择索引树树是一个平衡的多叉树从根节点到每个叶子节点的高度差值不超过而且同层级的节点间有指针相互链接在树上的常规检索从根节点到叶子节点的搜索效率基本相当不会出现大幅波动而且基于索引的顺序扫描时也可以利用双向指针快速左右移动效率非常高因此树索引被广泛应用于数据库文件系统等场景哈希索引哈希索引就是采用一定的哈希算法把键值换算成新的哈希值检索时不需要类似树那样从根节点到叶子节点逐级查找只需一次哈希算法即可立刻定位到相应的位置速度非常快如果是等值查询那么哈希索引明显有绝对优势因为只需要经过一次算法即可找到相应的键值前提是键值都是唯一的如果键值不是唯一的就需要先找到该键所在位置然后再根据链表往后扫描直到找到相应的数据如果是范围查询检索这时候哈希索引就毫无用武之地了因为原先是有序的键值经过哈希算法后有可能变成不连续的了就没办法再利用索引完成范围查询检索哈希索引也没办法利用索引完成排序以及这样的部分模糊查询这种部分模糊查询其实本质上也是范围查询哈希索引也不支持多列联合索引的最左匹配规则树索引的关键字检索效率比较平均不像树那样波动幅度大在有大量重复键值情况下哈希索引的效率也是极低的因为存在哈希碰撞问题索引的设计原则查询更快占用空间更小适合索引的列是出现在子句中的列或者连接子句中指定的列基数较小的表索引效果较差没有必要在此列建立索引使用短索引如果对长字符串列进行索引应该指定一个前缀长度这样能够节省大量索引空间如果搜索词超过索引前缀长度则使用索引排除不匹配的行然后检查其余行是否可能匹配不要过度索引索引需要额外的磁盘空间并降低写操作的性能在修改表内容的时候索引会进行更新甚至重构索引列越多这个时间就会越长所以只保持需要的索引有利于查询即可定义有外键的数据列一定要建立索引更新频繁字段不适合创建索引若是不能有效区分数据的列不适合做索引列如性别男女未知最多也就三种区分度实在太低对于那些查询中很少涉及的列重复值比较多的列不要建立索引对于定义为和的数据类型的列不要建立索引中树和树的区别非叶子节点数据不同树的非叶子节点的数据都在叶子节点中出现过也就是叶子节点中的数据都在非叶子节点冗余一份树中非叶子节点中元素不会冗余树非叶子节点只存放指针不存放数据树所有节点叶子节点都存放数据叶子节点数据不同树叶子节点存放数据树所有节点非叶子节点存放数据数据遍布整个树结构时间复杂度不同由于树的数据都存在叶子节点因此树的时间复杂度固定为而树的数据分布在每个节点中因此时间复杂度不固定最好为叶子节点连接不同树的叶子节点通过有序的双向链表相连树叶子节点不相连区间查询效率不同因为第点的原因所以树去范围查询效率更快而树范围查询比较慢因此存在大量范围查询的场景适合使用树而对大量单个查询的场景可以考虑树中的锁类型有哪些基于锁的属性分类共享锁排他锁基于锁的粒度分类行级锁表级锁页级锁引擎记录锁间隙锁临键锁共享锁共享锁又称读锁简称锁当一个事务为数据加上读锁之后其他事务只能对该数据加读锁而不能对数据加写锁直到所有的读锁释放之后其他事务才能对其进行加持写锁共享锁的特性主要是为了支持并发的读取数据读取数据的时候不支持修改避免出现重复读的问题排他锁排他锁又称写锁简称锁当一个事务为数据加上写锁时其他请求将不能再为数据加任何锁直到该锁释放之后其他事务才能对数据进行加锁排他锁的目的是在数据修改时候不允许其他人同时修改也不允许其他人读取避免了出现脏数据和脏读的问题表锁表锁是指上锁的时候锁住的是整个表当下一个事务访问该表的时候必须等前一个事务释放了锁才能进行对表进行访问特点粒度大加锁简单容易冲突行锁行锁是指上锁的时候锁住的是表的某一行或多行记录其他事务访问同一张表时只有被锁住的记录不能访问其他的记录可正常访问特点粒度小加锁比表锁麻烦不容易冲突相比表锁支持的并发要高记录锁记录锁也属于行锁中的一种只不过记录锁的范围只是表中的某一条记录记录锁是说事务在加锁后锁住的只是表的某一条记录精准条件命中并且命中的条件字段是唯一索引加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题也避免了在修改的事务未提交前被其他事务读取的脏读问题页锁页级锁是中锁定粒度介于行级锁和表级锁中间的一种锁表级锁速度快但冲突多行级冲突少但速度慢所以取了折衷的页级一次锁定相邻的一组记录特点开销和加锁时间界于表锁和行锁之间会出现死锁锁定粒度界于表锁和行锁之间并发度一般间隙锁属于行锁中的一种间隙锁是在事务加锁后其锁住的是表记录的某一个区间当表的相邻之间出现空隙则会形成一个区间遵循左开右闭原则间隙锁只会出现在可重复读的事务级别中触发条件防止幻读问题事务并发的时候如果没有间隙锁就会发生如下图的问题在同一个事务里事务的两次查询出的结果会不一样比如表里面的数据为那么会形成以下几个间隙区间区间区间区间区间区间代表负无穷大代表正无穷大临建锁也属于行锁的一种并且它是的行锁默认算法总结来说它就是记录锁和间隙锁的组合临键锁会把查询出来的记录锁住同时也会把该范围查询内的所有间隙空间也会锁住触发条件范围查询并命中查询命中了索引结合记录锁和间隙锁的特性临键锁避免了在范围查询时出现脏读重复读幻读问题加了临键锁之后在范围区间内数据不允许被修改和插入什么是死锁怎么解决死锁是指两个或多个事务在同一资源上相互占用并请求锁定对方的资源从而导致恶性循环的现象有四个必要条件互斥条件请求和保持条件环路等待条件不剥夺条件解决死锁思路一般就是切断环路尽量避免并发形成环路如果不同程序会并发存取多个表尽量约定以相同的顺序访问表可以大大降低死锁机会在同一个事务中尽可能做到一次锁定所需要的所有资源减少死锁产生概率对于非常容易产生死锁的业务部分可以尝试使用升级锁定颗粒度通过表级锁定来减少死锁产生的概率如果业务处理不好可以用分布式事务锁或者使用乐观锁死锁与索引密不可分解决索引问题需要合理优化索引的约束有哪些约束字段的内容一定不能为约束字段唯一性一个表允许有多个约束约束字段唯一不可重复一个表只允许存在一个用于预防破坏表之间连接的动作也能防止非法数据插入外键用来让两张表的数据之间建立连接从而保证数据的一致性和完整性用于控制字段的值范围保证字段值满足某一个条件保存数据时如果未指定该字段的值则采用默认值关心过业务系统里面的耗时吗统计过慢查询吗对慢查询都怎么优化过在业务系统中除了使用主键进行的查询其他的都会在测试库上测试其耗时慢查询的统计主要由运维在做会定期将业务中的慢查询反馈给我们慢查询的优化首先要搞明白慢的原因是什么是查询条件没有命中索引是了不需要的数据列还是数据量太大所以优化也是针对这三个方向来的首先分析语句看看是否了额外的数据可能是查询了多余的行并且抛弃掉了可能是加载了许多结果中并不需要的列对语句进行分析以及重写分析语句的执行计划然后获得其使用索引的情况之后修改语句或者修改索引使得语句可以尽可能的命中索引如果对语句的优化已经无法进行可以考虑表中的数据量是否太大如果是的话可以进行横向或者纵向的分表事务的基本特性和隔离级别事务基本特性分别是原子性指的是一个事务中的操作要么全部成功要么全部失败一致性指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态比如转账给块钱假设只有块支付之前我们数据库里的数据都是符合约束的但是如果事务执行成功了我们的数据库数据就破坏约束了因此事务不能成功这里我们说事务提供了一致性的保证隔离性指的是一个事务的修改在最终提交前对其他事务是不可见的持久性指的是一旦事务提交所做的修改就会永久保存到数据库中隔离性有个隔离级别分别是读未提交可能会读到其他事务未提交的数据也叫做脏读用户本来应该读取到的用户应该是结果读取到了其他事务还没有提交的事务结果读取结果这就是脏读读已提交两次读取结果不一致叫做不可重复读不可重复读解决了脏读的问题他只会读取已经提交的事务用户开启事务读取用户查询到再次读取发现结果在同一个事务里同一个查询读取到不同的结果叫做不可重复读可重复复读这是的默认级别就是每次读取结果都一样但是有可能产生幻读串行一般是不会使用的他会给每一行读取的数据加锁会导致大量超时和锁竞争的问题脏读某个事务已更新一份数据另一个事务在此时读取了同一份数据由于某些原因前一个了操作则后一个事务所读取的数据就会是不正确的不可重复读在一个事务的两次查询之中数据不一致这可能是两次查询过程中间插入了一个事务更新的原有的数据幻读在一个事务的两次查询中数据笔数不一致例如有一个事务查询了几列数据而另一个事务却在此时插入了新的几列数据先前的事务在接下来的查询中就会发现有几列数据是它先前所没有的中靠什么保证的原子性由日志保证它记录了需要回滚的日志信息事务回滚时撤销已经执行成功的一致性由其他三大特性保证程序代码要保证业务上的一致性隔离性由来保证持久性由内存来保证修改数据同时在内存和记录这次操作宕机的时候可以从恢复的刷盘会在系统空闲时进行中的是什么多版本并发控制读取数据时通过一种类似快照的方式将数据保存下来这样读锁就和写锁不冲突了不同的事务会看到自己特定版本的数据版本链只在和两个隔离级别下工作其他两个隔离级别和不兼容因为总是读取最新的数据行而不是符合当前事务版本的数据行而则会对所有读取的行都加锁聚簇索引记录中有两个必要的隐藏列用来存储每次对某条聚簇索引记录进行修改的时候的事务每次对哪条聚簇索引记录有修改的时候都会把老版本写入日志中这个就是存了一个指针它指向这条聚簇索引记录的上一个版本的位置通过它来获得上一个版本的记录信息注意插入操作的日志没有这个属性因为它没有老版本已提交读和可重复读的区别就在于它们生成的策略不同开始事务时创建维护当前活动的事务即未提交的事务排序生成一个数组访问数据获取数据中的事务对比如果在的左边比都小可以访问在左边意味着该事务已经提交如果在的右边比都大或者就在中不可以访问获取取上一版本重新对比在右边意味着该事务在生成之后出现在中意味着该事务还未提交已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的而可重复读隔离级别则在第一次读的时候生成一个之后的读都复用之前的这就是的通过版本链实现多版本可并发读写写读通过生成策略的不同实现不同的隔离级别和的区别先说结论因为操作会对结果去重且排序所以从速度来说会更胜一筹建两张表分别插入几条数据这两张表唯一的不同就是数据中一个是王五一个是老六使用可以看出没有去重查出了两个张三和李四使用由此可见张三和李四被去重了然后我们再来看下两个也就是和的性能分析使用性能分析使用性能分析通过性能分析可得出比多做了操作由此得结论去重并排序直接返回合并的结果不去重也不排序比性能好主键使用自增还是为什么如果是单机的话选择自增如果是分布式系统优先考虑但还是最好公司自己有一套分布式唯一生产方案自增数据存储空间小查询效率高但是如果数据量过大会超出自增长的值范围多库合并也有可能出现问题适合大量数据的插入和更新操作但它是无序的插入数据效率慢占用空间大数据库飙升的话要怎么处理呢排查过程使用命令观察确定是导致还是其他原因如果是导致的查看情况确定是不是有消耗资源的在运行找出消耗高的看看执行计划是否准确索引是否缺失数据量是否太大处理掉这些线程同时观察使用率是否下降进行相应的调整比如说加索引改改内存参数重新跑其他情况也有可能是每个消耗资源并不多但是突然之间有大量的连进来导致飙升这种情况就需要跟应用一起来分析为何连接数会激增再做出相应的调整比如说限制连接数等什么是存储过程有哪些优缺点存储过程就是一些编译好了的语句这些语句代码像一个方法实现一些功能对单表或多表的增删改查然后给这些代码块取一个名字在用到这个功能的时候调用即可优点存储过程是一个预编译的代码块执行效率比较高存储过程在服务器端运行减少客户端的压力允许模块化程序设计只需要创建一次过程以后在程序中就可以调用该过程任意次类似方法的复用一个存储过程替代大量语句可以降低网络通信量提高通信速率可以一定程度上确保数据安全缺点调试麻烦可移植性不灵活存在重新编译问题了解什么是表分区吗表分区的好处有哪些表分区是指根据一定规则将数据库中的一张表分解成多个更小的容易管理的部分从逻辑上看只有一张表但是底层却是由多个物理分区组成存储更多数据分区表的数据可以分布在不同的物理设备上从而高效地利用多个硬件设备和单个磁盘或者文件系统相比可以存储更多数据优化查询在语句中包含分区条件时可以只扫描一个或多个分区表来提高查询效率涉及和语句时也可以在多个分区上并行处理最后汇总结果分区表更容易维护例如想批量删除大量数据可以清除整个分区避免某些特殊的瓶颈例如的单个索引的互斥访问主从同步原理主从同步的过程的主从复制中主要有三个线程一条线程和中的两条线程主节点主从复制的基础是主库记录数据库的所有变更记录到是数据库服务器启动的那一刻起保存所有修改数据库结构或内容的一个文件主节点线程当有变动时线程读取其内容并发送给从节点从节点线程接收内容并将其写入到文件中从节点的线程读取文件内容对数据更新进行重放最终保证主从数据库的一致性注主从节点使用文件偏移量来定位主从同步的位置从节点会保存其已接收到的偏移量如果从节点发生宕机重启则会自动从的位置发起同步由于默认的复制方式是异步的主库把日志发送给从库后不关心从库是否已经处理这样会产生一个问题就是假设主库挂了从库处理失败了这时候从库升为主库后日志就丢失了由此产生两个概念全同步复制主库写入后强制同步日志到从库所有的从库都执行完成后才返回给客户端但是很显然这个方式的话性能会受到严重影响半同步复制和全同步不同的是半同步复制的逻辑是这样从库写入日志成功后返回确认给主库主库收到至少一个从库的确认就认为写操作完成简述和的区别不支持事务但是每次查询都是原子的支持表级锁即每次操作是对整个表加锁存储表的总行数一个表有三个文件索引文件表结构文件数据文件采用非聚集索引索引文件的数据域存储指向数据文件的指针辅索引与主索引基本一致但是辅索引不用保证唯一性支持的事务支持事务的四种隔离级别支持行级锁及外键约束因此可以支持写并发不存储总行数一个引擎存储在一个文件空间共享表空间表大小不受操作系统控制一个表可能分布在多个文件里也有可能为多个设置为独立表空表大小受操作系统文件大小限制一般为受操作系统文件大小的限制主键索引采用聚集索引索引的数据域存储数据文件本身辅索引的数据域存储主键的值因此从辅索引查找数据需要先通过辅索引找到主键值再访问主键索引树索引最好使用自增主键防止插入数据时为维持树结构文件的大调整简述中索引类型及对数据库的性能的影响普通索引允许被索引的数据列包含重复的值唯一索引可以保证数据记录的唯一性主键是一种特殊的唯一索引在一张表中只能定义一个主键索引主键用于唯一标识一条记录使用关键字来创建联合索引索引可以覆盖多个数据列如像索引全文索引通过建立倒排索引可以极大的提升检索效率解决判断字段是否包含的问题是目前搜索引擎使用的一种关键技术可以通过创建全文索引索引可以极大的提高数据的查询速度通过使用索引可以在查询的过程中使用优化隐藏器提高系统的性能但是会降低插入删除更新表的速度因为在执行这些写操作时还要操作索引文件索引需要占物理空间除了数据表占数据空间之外每一个索引还要占一定的物理空间如果要建立聚簇索引那么需要的空间就会更大如果非聚集索引很多一旦聚集索引改变那么所有非聚集索引都会跟着变执行计划怎么看执行计划就是的执行查询的顺序以及如何使用索引查询返回的结果集的行数是一个有顺序的编号是查询的顺序号有几个就显示几行的顺序是按出现的顺序增长的列的值越大执行优先级越高越先执行列的值相同则从上往下执行列的值为最后执行表示查询中每个子句的类型表示此查询不包含查询或子查询表示此查询是最外层的查询包含子查询子查询中的第一个表示此查询是的第二或随后的查询中的第二个或后面的查询语句取决于外面的查询的结果子查询中的第一个取决于外面的查询即子查询依赖于外层查询的结果衍生表示导出表的子句的子查询表示该语句查询的表优化的重要字段也是我们判断性能和优化程度重要指标他的取值类型范围通过索引一次命中匹配一行数据表中只有一行记录相当于系统表唯一性索引扫描对于每个索引键表中只有一条记录与之匹配非唯一性索引扫描返回匹配某个值的所有只检索给定范围的行使用一个索引来选择行一般用于只遍历索引树表示全表扫描这个类型的查询是性能最差的查询之一那么基本就是随着表的数量增多执行效率越慢执行效率最好是避免和它表示在执行该语句的时候可能用到的索引信息仅仅是可能实际不一定会用到此字段是在当前查询时所真正使用到的索引他是的子集表示查询优化器使用了索引的字节数这个字段可以评估组合索引是否完全被使用这也是我们优化时评估索引的重要指标查询优化器根据统计信息估算该返回结果集需要扫描读取的行数这个值相关重要索引优化之后扫描读取的行数越多说明索引设置不对或者字段传入的类型之类的问题说明要优化空间越大返回结果的行占需要读到的行列的值的百分比就是百分比越高说明需要查询到数据越准确百分比越小说明查询到的数据量大而结果集很少表示对结果集进行外部排序不能通过索引顺序达到排序效果一般有都建议优化去掉因为这样的查询资源消耗大延时大覆盖索引扫描表示查询在索引树中就可查找所需数据不用扫描表数据文件往往说明性能不错查询有使用临时表一般出现于排序分组和多表的情况查询效率不高建议优化使用了过滤效率较高常见优化手段尽量选择较小的列将中用的比较频繁的字段建立索引子句中避免使用避免在索引列上使用计算和等操作当只需要一行数据的时候使用保证单表数据不超过适时分割表针对查询较慢的语句可以使用来分析该语句具体的执行情况避免改变索引列的类型选择最有效的表名顺序字句中写在最后的表是基础表将被最先处理在子句中包含多个表的情况下你必须选择记录条数最少的表作为基础表避免在索引列上面进行计算能用关联查询的不要用子查询尽量缩小子查询的结果网络不看快速学为什么适合做网络编程是一个基于的高性能网络编程框架它被广泛用于构建可扩展的高性能的网络应用程序以下是一些原因说明为什么适合做网络编程强大的抽象和组件提供了一组强大的抽象和可重用的组件如事件模型处理器链编解码器等这些组件使得网络编程变得更加简单和灵活开发者可以根据需求自由组合和定制高性能采用了基于事件驱动的异步非阻塞模型利用了的特性能够处理大量的并发连接它的线程模型和内存管理机制也经过优化能够最大限度地提高网络应用程序的性能和吞吐量完善的协议支持提供了丰富的协议支持包括等它内置了许多常用的协议编解码器可以轻松地进行协议的解析和编码简化了网络应用程序的开发过程可扩展性的设计非常灵活支持自定义的协议编解码器和处理器它提供了丰富的扩展点和钩子函数可以方便地进行功能扩展和定制满足各种复杂的业务需求成熟稳定是一个成熟稳定的开源项目经过了广泛的实际应用和验证它拥有活跃的社区和强大的生态系统提供了大量的文档示例和工具使得开发者能够快速上手并解决问题综上所述具有强大的抽象和组件高性能完善的协议支持可扩展性和成熟稳定等特点使其成为一种优秀的选择用于网络编程性能好的原因是什么是一个高性能的网络应用框架其性能好的原因主要有以下几点异步非阻塞使用异步非阻塞的模型可以处理大量的并发连接而不需要为每个连接分配一个线程这种模型减少了线程切换的开销提高了系统的吞吐量和响应速度高度可定制化提供了丰富的可定制化选项可以根据应用的需求进行灵活的配置开发者可以自定义编解码器处理器链线程模型等以适应不同的网络应用场景零拷贝支持零拷贝技术可以避免数据在内存之间的多次拷贝减少了内存的使用和数据传输的开销提高了性能内存管理优化使用了内存池技术可以重用内存减少了频繁的内存分配和回收操作提高了内存的利用率和性能模块化设计的设计模块化各个功能模块之间解耦可以根据需要选择性地使用特定的模块避免了不必要的性能损耗总的来说的高性能得益于其异步非阻塞的模型可定制化的设计零拷贝技术内存管理优化和模块化架构等多个方面的优势这些特性使得成为开发高性能网络应用的理想选择的零拷贝是怎么实现的实现零拷贝主要依赖于以下两个技术零拷贝文件传输使用了操作系统提供的零拷贝机制例如下的和系统调用这些系统调用可以直接将文件数据从磁盘读取到网络套接字或者从一个套接字传输到另一个套接字而无需经过用户空间和内核空间之间的数据拷贝零拷贝内存传输使用了直接内存缓冲区来实现零拷贝内存传输直接内存缓冲区是一种直接分配在堆外内存的缓冲区可以通过操作系统的文件描述符直接读写数据避免了数据在用户空间和内核空间之间的拷贝通过使用这些零拷贝技术在进行数据传输时可以避免将数据从一个缓冲区拷贝到另一个缓冲区从而减少了数据拷贝的次数和数据在内存之间的传输开销这样可以提高数据传输的效率和性能需要注意的是零拷贝并不是在所有情况下都能完全避免数据拷贝在某些情况下仍然需要进行少量的数据拷贝操作例如数据的解码和编码过程但是相比传统的拷贝方式的零拷贝机制可以最大程度地减少数据拷贝的次数提高了性能能不能说一说的无锁化设计的无锁化设计是指在多线程环境下尽量减少对共享数据的锁使用以避免锁竞争和线程阻塞从而提高系统的并发性能在实现无锁化设计时主要采用了以下几种技术并发容器使用了并发容器来替代传统的线程安全集合类例如使用替代使用替代这些并发容器底层使用了等无锁算法来实现线程安全原子操作使用了原子操作来实现对共享数据的无锁访问原子操作是一种不可中断的操作可以保证在多线程环境下对共享数据的操作是原子性的使用了提供的原子类如等来实现无锁访问事件驱动模型的核心思想是基于事件驱动的模型通过事件的发布和订阅来实现线程间的解耦和通信这种模型避免了线程间的锁竞争每个线程只需要处理自己感兴趣的事件大大提高了系统的并发性能非阻塞使用了非阻塞的模型通过异步的方式处理网络操作避免了线程在等待完成时的阻塞提高了系统的并发性能通过这些无锁化设计的技术手段在多线程环境下能够更好地利用计算资源提高系统的并发性能和可伸缩性同时无锁化设计也减少了线程间的竞争和线程阻塞避免了潜在的死锁和性能瓶颈问题的线程模型是怎么样的的线程模型是基于事件驱动的它采用了多线程池的架构来处理网络请求和事件以下是的线程模型的主要特点线程池这个线程池用于处理新的连接请求通常会绑定到一个端口并且负责接受客户端的连接每个线程都会监听一个独立的套接字用于接受客户端的连接请求线程池一旦连接建立客户端的请求会被传递给线程池中的一个进行处理线程池负责处理事件如读取和写入数据以及执行用户定义的业务逻辑通常会有多个线程每个线程都会处理多个连接通过事件循环来处理这些连接上的事件事件循环每个线程都包含一个它负责处理一个或多个连接上的事件会持续地从事件队列中获取事件然后执行相应的操作比如读取数据处理请求写入数据等每个连接都会被分配到一个特定的确保了事件的顺序性和线程的安全性任务队列使用任务队列来存储需要处理的事件这些事件可以是读写操作用户自定义的任务或其他事件这些事件会被从队列中取出并执行总体来说的线程模型允许多个连接共享同一个线程避免了线程创建和销毁的开销提高了系统的性能和效率通过事件驱动的方式能够高效地处理大量的并发连接适用于构建高性能可扩展的网络应用程序需要注意的是具体的线程数目和配置可以根据应用程序的需求进行调整如何解决粘包拆包的问题的提供了多种解决粘包和拆包问题的机制帮助开发者处理在网络传输过程中可能出现的数据分片问题这些机制可以确保数据在发送和接收时能够正确地分割和组装从而避免粘包和拆包的困扰以下是解决粘包和拆包问题的一些常见方法固定长度解码器这个解码器会根据指定的固定长度对接收到的数据进行切割无论数据内容如何都会按照固定长度进行拆分从而确保每个数据包的长度是一致的行尾分隔符解码器适用于基于文本协议的场景该解码器会根据行尾分隔符如换行符将数据切分为不同的数据包这样每个数据包都会包含一行完整的文本分隔符解码器类似于行尾分隔符解码器但可以自定义分隔符开发者可以指定特定的字节序列作为分隔符用于切分数据自定义解码器还允许开发者根据具体的协议和业务需求创建自定义的解码器这样可以更灵活地处理数据的分割和组装这些解码器通常作为中的一部分用于解决数据在网络传输过程中可能引发的粘包和拆包问题开发者可以根据自己的需求选择合适的解码器或者结合多种解码器来处理不同类型的数据需要注意的是虽然这些解码器可以很好地处理大部分粘包和拆包问题但在一些复杂的情况下可能仍需要开发者进行额外的处理和调优的为什么好用的在网络编程中被认为非常好用有以下几个方面的优势内存管理优化的实现了内存池技术能够有效地管理内存的分配和释放这可以减少频繁的内存分配和垃圾回收从而提高性能和减少延迟零拷贝技术的支持零拷贝技术这意味着在数据传输过程中可以避免不必要的数据拷贝减少了和内存的负担提高了数据传输的效率支持多种数据类型的提供了多种类型的如堆内存缓冲区和直接内存缓冲区可以根据需要选择合适的类型来优化性能灵活的的提供了丰富的操作方法可以轻松地进行数据读写切片复制等操作使得处理数据变得更加方便和灵活与集成的与紧密集成可以方便地在不同的处理器如编码器解码器处理器等之间传递数据简化了数据处理的流程可扩展性和定制性允许开发者基于自己的需求扩展和定制的行为从而实现更高级别的功能和优化综上所述的在性能内存管理数据传输效率以及灵活性方面的优势使得它成为了网络编程中一个非常实用和强大的工具无论是处理小规模数据还是大规模数据的都能够有效地提升网络应用的性能和可靠性说说的对象池技术的对象池技术是一种用于管理和重用对象的机制旨在提高内存使用效率和性能在网络编程中频繁地创建和销毁对象可能会导致内存碎片化和额外的垃圾回收开销从而影响应用程序的性能引入了对象池技术来缓解这些问题在中对象池主要用于管理两种类型的对象字节缓冲区和通道处理上下文以下是关于对象池技术的一些关键点对象池的是用于处理网络数据的字节缓冲区通过使用对象池可以重用已经分配的字节缓冲区避免频繁地创建和销毁这些对象这有助于减少内存分配和垃圾回收的开销提高数据传输效率和应用程序性能对象池中的代表了处理器如编码器解码器处理器等与之间的关联关系通过使用对象池可以在数据处理过程中重用上下文对象减少上下文对象的创建和销毁开销从而提高数据处理的效率资源回收和管理的对象池技术能够自动地管理对象的生命周期和资源回收当对象不再需要时它们会被返回到对象池以便稍后重用这有助于避免内存泄漏和资源浪费配置和定制允许开发者根据应用程序的需求进行对象池的配置和定制开发者可以设置池的大小对象的生存时间等参数以适应不同的场景和负载综上所述的对象池技术是一项重要的功能能够有效地提高网络应用程序的内存使用效率和性能特别是在处理大规模数据和高并发情况下通过重用对象能够降低资源开销提高数据传输效率并且在一定程度上减少内存碎片化问题有哪些序列化协议并不直接提供序列化协议但它可以与各种序列化协议进行集成序列化是将对象转换为可在网络上传输或持久化存储的格式的过程可以与多种序列化协议一起使用以根据应用程序的需要进行数据的编码和解码以下是一些常见的序列化协议可以与一起使用自带的序列化自带了一套对象序列化机制可以将对象转换为字节流进行传输但是这种序列化方式在性能和灵活性方面可能存在问题因此在高性能网络应用中可能不是首选是一种轻量级的数据交换格式易于阅读和编写适用于各种编程语言可以与库如等一起使用将对象转换为格式进行传输是一种由开发的高效的二进制序列化协议具有很高的性能和紧凑的数据表示可以与集成使用生成的类来进行对象的编码和解码是一种基于二进制的轻量级序列化格式具有高性能和紧凑的数据表示它可以与一起使用实现数据的传输和解析是由开发的一种跨语言的序列化协议支持多种编程语言并具有高性能和可扩展性可以与一起使用实现对象的序列化和反序列化是另一种由开发的序列化框架旨在提供紧凑的二进制格式和动态数据模型可以与一起使用实现数据的编码和解码这些序列化协议可以根据应用程序的需求进行选择根据性能数据大小跨语言支持等因素来决定使用哪种协议的灵活性使得它能够与各种序列化协议集成以实现高效的网络通信中用了哪些设计模式在中使用了许多设计模式来实现高效的网络通信和处理以下是一些中使用的设计模式工厂模式使用工厂模式来创建不同类型的通道处理器和其他组件隐藏了对象创建的细节使代码更具可维护性和扩展性装饰器模式的处理器链机制使用了装饰器模式每个处理器都可以在收到数据处理数据和传递数据时添加额外的逻辑这使得用户可以轻松地定制数据的处理流程观察者模式中的事件和事件监听器机制使用了观察者模式通道状态变化数据读写等事件可以被观察而用户可以注册相应的监听器来处理这些事件责任链模式的处理器链本质上就是一个责任链每个处理器负责特定的任务可以在链中按顺序处理数据将复杂的处理逻辑拆分成独立的模块单例模式中的一些关键组件如线程池事件循环都使用了单例模式确保只有一个实例存在从而节省资源并确保一致性模板方法模式的一些类提供了模板方法定义了通用的处理流程和步骤而将具体的实现细节留给子类来实现策略模式中的一些组件如编码器和解码器可以根据不同的业务需求进行替换这种灵活性符合策略模式的思想适配器模式中的适配器可以帮助用户将不同的数据格式协议等转换成统一的格式以适应不同的通信需求这些设计模式的使用使得能够提供高度灵活高性能和可扩展的网络通信框架满足各种不同应用场景的需求的缺省端口是多少怎么修改默认端口为可以通过在安装包目录下中的元素的属性来修改端口有哪几种运行模式优化这三种模式的不同之处如下一个线程处理一个请求缺点并发量高时线程数较多浪费资源版本或更低版本中在系统中默认使用这种方式利用的异步处理可以通过少量的线程处理大量的请求中默认使用的是必须修改配置来启动即从操作系统层面解决阻塞问题或在或以上的系统中启动默认使用这种方式有几种部署方式利用的自动部署把应用拷贝到目录生产环境不建议放在该目录中在启动时会加载目录下的应用并将编译后的结果放入目录下使用控制台部署在主页点击进入应用管理控制台可以指定一个应用的路径或文件修改文件部署在文件中增加节点可以部署应用增加自定义的部署文件在路径下增加文件内容是节点可以部署应用容器是如何创建类实例用到了什么原理当容器启动时会读取在目录下所有的应用中的文件然后对文件进行解析并读取注册信息然后将每个应用中注册的类都进行加载并通过反射的方式实例化有时候也是在第一次请求时实例化在注册时加上如果为正数则在一开始就实例化如果不写或为负数则第一次请求实例化如何优化作为服务器它的处理性能直接关系到用户体验下面是几种常见的优化措施掉对的监视把提前编辑成有富余物理内存的情况加大使用的的内存服务器所能提供内存硬盘的性能对处理能力有决定性影响对于高并发情况下会有大量的运算那么的速度会直接影响到处理速度内存在大量数据处理的情况下将会有较大的内存容量需求可以用等参数对内存不同功能块进行划分我们之前就遇到过内存分配不足导致虚拟机一直处于从而导致处理能力严重下降硬盘主要问题就是读写性能当大量文件进行读写时磁盘极容易成为性能瓶颈最好的办法还是利用下面提到的缓存利用缓存和压缩对于静态页面最好是能够缓存起来这样就不必每次从磁盘上读这里我们采用了作为缓存服务器将图片文件都进行了缓存有效地减少了后端的访问另外为了能加快网络传输速度开启压缩也是必不可少的但考虑到已经需要处理很多东西了所以把这个压缩的工作就交给前端的来完成除了文本可以用压缩其实很多图片也可以用图像处理工具预先进行压缩找到一个平衡点可以让画质损失很小而文件可以减小很多曾经我就见过一个图片从多压缩到几十自己几乎看不出来区别采用集群单个服务器性能总是有限的最好的办法自然是实现横向扩展那么组建集群是有效提升性能的手段我们还是采用了来作为请求分流的服务器后端多个共享来协同工作优化线程数优化找到增加和属性使大于等于如下其中可用于请求处理的最大线程数默认是初始线程数即最小空闲线程数最大空闲线程数超过的会被关闭当所有可以使用的处理请求的线程数都被使用时可以放到处理队列中的请求数超过这个数的请求将不予处理默认使用线程池优化在中增加节点然后配置的属性如下其中线程池中线程的命名前缀线程池的最大线程数线程池的最小空闲线程数超过最小空闲线程数时多的线程会等待这个时间长度然后关闭线程优先级注当并发用户量大的时候单个进程确实可能打开过多的文件句柄这时会报错误可使用下面步骤检查查看的进程记录号假设进程为查看当前进程为的文件操作数使用命令查看每个用户允许打开的最大文件数启动速度优化删除没用的应用因为启动每次都会部署这些应用关闭和随机数优化设置参数内存优化因为启动起来后就是一个进程所以这块可以参照部分的优化思路堆内存相关参数比如说虚拟机初始化时的最小堆内存虚拟机可使用的最大堆内存与设成一样的值避免因为频繁的导致性能大起大落新生代占整个堆内存的最大值另外还有方法区参数调整注意版本垃圾收集器等优化相关参数请看手把手教你设置调优参数熟悉的哪些配置表示一个应用程序通常为文件关于的具体信息见规范标签该应用的文档基准目录也称为或者是文件的路径可以使绝对路径也可以使用相对于所属的的路径表示此应用程序的的前缀这样请求的为这个属性非常重要如果为则会自动检测应用程序的和目录的变化自动装载新的应用程序我们可以在不重启的情况下改变应用程序如果希望为该应用使用一个对象设为该符合平台的约定缺省值为提供的临时目录的路径用于的临时读写利用属性可以访问该目录如果没有指定使用下一个合适的目录如果该值为和的输出被重定向到应用的如果没有指定缺省值为与这个关联的记录的调试信息的详细程度数字越大输出越详细如果没有指定缺省为表示一个虚拟主机标签指定主机名应用程序基本目录即存放应用程序的目录如果为则会自动将文件解压否则不解压直接从文件中运行应用程序表示日志调试和错误信息标签指定使用的类名此类必须实现接口指定文件的前缀指定文件的后缀如果为则文件名中要加入时间如下例计算机网络选择原理必须搞清楚选择性学习介绍一下七层模型当然我很乐意为您介绍一下七层模型七层模型是一个用于描述计算机网络通信协议的框架它由国际标准化组织于年制定并发布该模型将网络通信过程分解为七个不同的层次每个层次都负责特定的功能从物理连接到应用程序的交互以实现数据在不同设备之间的传输和交换以下是每个层次的简要介绍物理层这是最底层的层次负责处理物理媒介和电信号传输它定义了连接硬件设备的标准例如电缆类型电压规范等数据链路层此层负责在直接相连的两个设备之间传输数据帧通过物理地址地址进行寻址和识别它还处理错误检测和校正确保可靠的数据传输网络层网络层负责在不同网络之间路由数据包通过地址进行寻址它处理数据包的传输路径选择和逻辑寻址以实现跨网络的通信传输层传输层负责在端到端的通信中提供数据传输的可靠性和错误检测它管理数据的分段传输控制流量控制等常见的传输层协议包括传输控制协议和用户数据报协议会话层会话层负责建立管理和终止应用程序之间的会话连接它处理会话的控制和同步确保数据正确传输并在需要时进行恢复表示层表示层负责数据的格式化加密压缩等处理以确保不同系统间数据的交换和解释能够无障碍地进行应用层应用层是最顶层的层次直接为用户提供网络服务和应用程序它包含了各种应用如电子邮件文件传输远程访问等通过这种分层的方式模型帮助网络工程师和开发者更好地理解和设计网络协议通信和应用然而需要注意的是实际网络协议不一定都严格按照这七层模型来设计而是根据实际需求和技术进行了调整和扩展什么是的粘包拆包是一种常用的传输层协议用于在计算机网络上可靠地传输数据在通信中粘包和拆包是两个可能出现的问题涉及到数据的传输和接收过程中的数据分割和组合粘包粘包指的是在发送端将多个小数据包连续发送而接收端却可能一次性接收到了多个小数据包这些数据包粘在一起无法准确分辨出每个数据包的界限这可能是因为发送端的数据写入缓冲区比较快而接收端读取数据的速度较慢导致多个数据包被一次性读取粘包会导致接收端无法正确解析数据从而影响数据的处理和解释拆包拆包指的是在发送端将一个大数据包分割成多个小数据包发送而接收端却可能无法正确地将这些小数据包组合成完整的大数据包这可能是因为发送端的数据分割不当或者接收端没有足够的信息来确定如何正确组合这些小数据包拆包会导致接收端无法还原原始数据从而造成数据的错误或丢失为了解决粘包和拆包问题通常需要在应用层设计一些协议或者采用一些技术手段例如消息长度字段在消息的开头加入一个固定长度的字段用来表示后续消息的长度接收端可以根据这个字段来准确地分割和组合数据包消息分隔符在消息的末尾加入一个特定的分隔符接收端通过识别分隔符来分割数据包使用固定长度消息将所有消息都固定到同样的长度不足的部分用填充数据补齐应用层协议设计在应用层定义明确的消息格式和协议确保发送端和接收端都按照相同的规则进行数据的分割和组合总之处理粘包和拆包问题需要在应用层进行合适的设计和处理以确保数据在传输过程中能够正确地分割和组合保证通信的可靠性和准确性与的区别是什么和都是用于在网络通信中解决地址和物理地址之间映射关系的协议但它们的功能和应用场景有所不同用于将一个已知的地址解析成对应的物理地址在一个局域网中当主机需要与另一个主机通信时它会先检查自己的缓存表看是否已经有目标地址对应的地址如果没有它就会发送一个请求广播询问局域网内是否有响应该地址的主机目标主机收到该请求后会发送一个响应包含自己的地址这样请求主机就可以得到目标主机的地址从而建立通信与相反它用于将已知的物理地址解析成对应的地址主要应用于无盘工作站等设备在启动时需要获取自己的地址但是这些设备没有预设地址只有地址设备启动时会发送一个请求广播请求分配一个地址服务器会收到请求后查找地址对应的地址然后将地址发送回设备使设备能够配置自己的地址总结区别解析地址到地址而解析地址到地址主要用于常规网络通信而主要用于无盘设备等特殊情况下的地址配置请求由需要通信的主机发出而请求由需要获取地址的设备发出需要注意的是随着网络技术的发展和在现代网络中的使用逐渐减少因为有更高级的技术和协议来管理地址和地址的映射关系如和的邻居发现协议路由器与交换机的区别是什么路由器和交换机是网络中常见的两种设备它们在网络中扮演不同的角色有以下区别功能与工作层次路由器路由器位于网络的边缘连接不同的网络或子网主要负责在不同网络之间转发数据包它能够基于目标地址决定数据包的最佳路径从而实现网络之间的通信交换机交换机通常位于局域网内部它通过学习地址来建立和维护一个地址表然后根据地址表将数据包直接从源端口转发到目标端口从而实现局域网内部设备之间的通信转发决策路由器路由器通过查看数据包的目标地址来进行转发决策选择最佳路径将数据包从一个网络传送到另一个网络交换机交换机通过查看数据包的源地址来决定将数据包发送到哪个目标端口以实现局域网内部设备之间的直接通信广播域和碰撞域路由器路由器能够隔离不同网络之间的广播域和碰撞域这意味着在不同网络间的广播消息不会被传播到其他网络交换机交换机也能够隔离广播域但在同一个交换机内部所有设备共享一个碰撞域因此在交换机内部通信不会发生碰撞网络范围路由器路由器通常用于连接不同的网络可以跨越不同的物理位置和地理区域交换机交换机通常用于连接同一局域网内的设备限制在一个相对较小的网络范围内总之路由器和交换机在网络中扮演不同的角色分别用于实现不同的通信需求路由器负责不同网络之间的数据包转发而交换机则负责同一网络内部设备之间的数据包交换什么是三次握手四次挥手当然我可以解释一下三次握手和四次挥手的概念三次握手三次握手是在建立连接时使用的一种协议用于确保客户端和服务器之间的通信能够稳定地开始这个过程涉及三个步骤第一步客户端向服务器发送一个带有同步标志的数据包请求建立连接客户端进入状态第二步服务器收到客户端的请求后会发送一个带有和确认标志的数据包表示同意建立连接服务器进入状态第三步客户端收到服务器的响应后发送一个带有标志的数据包给服务器确认连接已建立双方都进入已建立连接的状态可以开始进行数据传输这三步握手过程确保了双方都同意建立连接并且双方都准备好了进行数据传输四次挥手四次挥手是在关闭连接时使用的一种协议用于确保双方能够安全地终止连接这个过程涉及四个步骤第一步一方通常是客户端向另一方通常是服务器发送一个带有结束标志的数据包表示希望关闭连接发送方进入状态第二步接收方收到关闭请求后发送一个带有标志的数据包作为确认发送方进入状态等待接收方的确认第三步接收方准备好关闭连接时会发送一个带有标志的数据包表示同意关闭连接接收方进入状态第四步发送方收到接收方的关闭确认后发送一个带有标志的数据包作为确认双方都进入连接已关闭的状态这四步挥手过程确保双方都完成了数据传输并且同意关闭连接避免了数据丢失或不完整的情况总之三次握手和四次挥手是确保通信的可靠性和完整性的重要步骤分别用于建立和关闭连接是如何保证可靠传输的传输控制协议保证可靠传输的主要方式包括以下几个方面三次握手在建立连接时发送方首先发送一个同步标志的数据包给接收方接收方收到后确认收到这个并发送一个带有确认和标志的数据包给发送方最后发送方再发送一个带有标志的数据包作为确认这三步握手确保双方都同意建立连接减少了连接错误的可能性序列号和确认机制使用序列号来标识每个发送的数据包接收方根据序列号确认收到的数据包如果发送方未收到确认会重新发送数据包直到接收到确认为止这保证了数据的可靠传输避免了数据包丢失的情况数据分段和重组将应用层传输的大块数据分割成小的数据段进行传输接收方根据序列号将这些数据段重新组装成完整的数据如果发现某个数据段丢失会要求重新发送该数据段确保数据的完整性流量控制利用滑动窗口机制进行流量控制确保发送方不会发送过多的数据导致接收方无法及时处理这防止了拥塞并保持了传输的平稳超时重传如果发送方在一定时间内没有收到确认会认为数据包丢失然后会重新发送这些数据包这样即使数据包在传输过程中丢失也能够通过超时重传来确保数据的到达四次挥手在关闭连接时发送方和接收方都要确认关闭防止数据的丢失或不完整通过上述机制可以有效地保证数据的可靠传输确保数据在传输过程中不会丢失重复或无序基于实现一个协议是一种无连接的不可靠的传输协议而是一种面向连接的可靠的传输协议基于实现一个协议是不可行的因为缺乏提供的许多关键特性如可靠的数据传输流量控制拥塞控制等然而你可以使用来实现一种类似的协议提供一些基本的可靠性和有序性下面是一个简单的示例展示了如何使用实现一个基于可靠传输的简化协议序号和确认机制在数据包中添加序号字段和确认字段发送方将每个数据包分配一个唯一的序号并等待接收方发送确认消息接收方收到数据包后发送确认消息确认收到的最后一个有序数据包的序号发送方根据接收到的确认消息确定哪些数据包已经被成功接收超时重传发送方需要设置一个定时器在发送数据包后启动计时器如果在一定时间内没有收到确认消息发送方会假设数据包丢失并重新发送该数据包接收方在收到重复的数据包时可以丢弃重复的数据流量控制发送方和接收方可以使用滑动窗口机制来进行流量控制发送方根据接收方的可接受窗口大小来确定发送的数据量并根据接收方发送的确认消息调整发送窗口的大小拥塞控制由于本身不提供拥塞控制机制你可以基于实现一些简单的拥塞控制策略如慢启动和拥塞避免这可以包括动态调整发送窗口大小和控制发送速率以避免网络拥塞需要注意的是尽管你可以使用实现一些类似的特性但由于的本质特点它仍然无法提供与完全相同的可靠性和性能在实际应用中如果需要可靠的数据传输和其他高级特性建议使用协议而不是基于的自定义协议为什么需要他解决了什么问题是协议的下一代版本旨在改进性能和效率它解决了存在的一些问题并引入了一些新的特性和优化以提供更快的网页加载速度更高的效率和更好的用户体验以下是解决的一些问题多路复用在中每个请求都需要使用单独的连接导致了高延迟和低效率使用二进制分帧层通过在单个连接上同时发送多个请求和响应实现了多路复用这意味着可以并发处理多个请求减少了延迟提高了效率头部压缩在中每个请求和响应的头部都需要重复发送浪费了带宽和资源引入了头部压缩机制使用了压缩算法可以显著减少头部的大小减少了数据传输量提高了效率服务器推送在中客户端需要发送多个请求来获取网页中的所有资源例如脚本样式表和图片等而支持服务器推送服务器可以主动将与请求的资源相关的其他资源一起推送给客户端减少了额外的请求延迟提高了页面加载速度流量控制引入了流量控制机制可以对数据流进行控制防止发送方发送过多的数据导致接收方无法处理这有助于平衡发送和接收之间的速度差异提高了性能和稳定性优先级支持请求的优先级设置可以告知服务器哪些请求更重要服务器可以相应地优先处理重要的请求提高了用户体验总体而言在性能效率和用户体验方面有了显著的改进它通过多路复用头部压缩服务器推送流量控制和优先级等特性减少了延迟提高了吞吐量加快了网页加载速度提供了更好的性能和效率存在什么问题为什么需要尽管在性能和效率方面带来了显著的改进但它仍然存在一些问题这些问题促使了的出现以下是一些存在的问题依赖于协议是在协议之上构建的而协议在高延迟和不可靠的网络环境下存在一些问题当出现丢包或网络拥塞时使用的拥塞控制机制会导致连接的延迟增加从而影响性能队头阻塞使用多路复用技术但在一个连接上的多个请求和响应共享同一个传输通道如果其中一个请求或响应出现延迟或丢失将会阻塞后续的请求和响应这被称为队头阻塞这可能导致其他请求受到影响影响了整体性能部署复杂性的实施相对复杂需要对服务器和客户端进行更新以支持新的协议这可能导致一些兼容性和部署问题使得采用变得相对困难为了解决这些问题应运而生它采用了全新的传输协议基于协议而不是以提供更好的性能和可靠性以下是为什么需要的一些原因解决的问题作为传输层协议克服了的一些问题如连接建立的延迟队头阻塞和拥塞控制机制使用自己的拥塞控制算法可以更快地适应网络状况的变化并提供更好的性能减少延迟使用协议通过减少握手时间和降低队头阻塞的影响可以显著减少延迟这对于实时通信视频流和移动应用等对低延迟要求较高的场景非常重要更好的并发性在一个连接上可以同时处理多个请求和响应避免了队头阻塞的问题这提供了更好的并发性和吞吐量提高了性能更好的适应性的部署相对简单因为它使用了现有的协议它可以更容易地通过和防火墙适应多样化的网络环境总的来说通过引入协议解决了存在的一些问题如的限制和队头阻塞它提供了更好的性能更低的延迟和更好的并发性同时具有更好的适应性和部署简单性的区别是什么和都是用于在应用程序中管理用户身份验证和状态的方式但它们在实现和使用上有一些区别以下是它们之间的主要区别是一小段文本信息由服务器发送到用户的浏览器并存储在用户的本地计算机上主要用于在浏览器和服务器之间存储少量数据通常用于身份验证用户偏好设置跟踪用户活动等存储在客户端可以在浏览器中设置过期时间以及作用域可以限定在特定的域名或路径下可以被浏览器禁用或删除且可能存在安全性问题如跨站点脚本攻击和跨站请求伪造攻击是服务器端存储的用户信息通过一个唯一的会话标识与客户端进行关联当用户访问服务器时服务器会创建一个新的并分配一个唯一的将用户数据存储在服务器上而不是在用户的浏览器中数据存储在服务器上通常在内存数据库或缓存中因此相对安全但会占用服务器资源常用于存储敏感信息如用户身份验证状态购物车内容等是一种令牌通常是一个加密的字符串用于验证用户身份和授权在基于令牌的身份验证中用户在登录后会收到一个令牌将其保存在客户端通常是本地存储或中并在每次请求时将令牌发送给服务器服务器使用密钥验证令牌的有效性从而确定用户身份和权限令牌可以在客户端存储不需要在服务器上维护会话状态因此适用于分布式系统和无状态应用总结起来是在客户端存储的小段文本数据通常用于存储用户偏好和跟踪用户活动是服务器端存储的用户数据通过唯一的会话标识与客户端关联常用于存储敏感信息是一种令牌用于验证用户身份和授权适用于无状态应用和分布式系统选择使用哪种方法取决于应用程序的需求和安全性考虑只是比安全吗不仅仅是比更安全而且它提供了一系列安全性和保护机制以确保在通信中的数据保密性完整性和身份验证以下是相对于的主要安全改进数据加密使用或协议对传输的数据进行加密这意味着在数据从客户端发送到服务器的过程中第三方无法轻易地截取窃听或篡改数据加密保护了用户的敏感信息如登录凭据支付信息等身份验证通过使用数字证书对服务器进行身份验证数字证书由受信任的证书颁发机构签发用于证明服务器的身份这样用户可以确信他们正在与合法的服务器通信而不是被冒充的恶意服务器数据完整性使用加密算法和消息认证码来确保数据在传输过程中没有被篡改或损坏接收方可以验证数据的完整性以确保数据的原始性和完整性信任度和安全指示浏览器在使用连接时会显示安全指示如绿色锁图标网站名称旁边的安全标签等这些指示向用户传达了对网站的信任和数据的保护帮助用户识别安全的网站并减少受到网络攻击的风险防止窃听和篡改的加密机制防止了中间人攻击其中攻击者可以窃听篡改或伪造通信内容通过加密和身份验证提供了更高的安全性使得中间人攻击变得更加困难总而言之不仅仅是比更安全它通过加密通信身份验证数据完整性和安全指示等机制提供了更高级别的保护确保用户的数据在传输过程中得到保密完整和安全因此在涉及敏感信息传输的场景中使用是非常重要和推荐的浏览器输入回车之后发生了什么当在浏览器中输入并按下回车之后以下是大致的步骤和过程域名解析浏览器首先会将解析为地址它会检查本地缓存如果找到了对应的地址则跳过后续步骤如果没有找到则浏览器会向本地计算机的解析器发送查询请求查询本地计算机的解析器会收到浏览器发送的查询请求并尝试解析域名操作系统或浏览器会向本地计算机的解析器发送查询请求以获取该域名对应的地址解析过程如果本地解析器的缓存中没有目标域名的地址它会执行以下步骤递归查询本地解析器向根域名服务器发送查询请求根服务器会返回顶级域名服务器的地址迭代查询本地解析器继续向顶级域名服务器发送查询请求获得次级域名服务器的地址继续迭代这个过程会一直持续下去直到本地解析器获取了目标域名的地址响应缓存本地解析器在解析域名后会将结果缓存一段时间这样如果再次有相同域名的查询就可以直接从缓存中获取结果加快访问速度记录类型查询可以返回多种类型的记录包括记录将域名映射到地址记录将域名映射到地址记录将域名指向另一个域名记录指定邮件服务器的地址记录指定管理特定区域的域名服务器在互联网中起着至关重要的作用它不仅使人们能够通过易于记忆的域名访问网站还支持电子邮件域名注册等多种互联网服务然而由于其核心的分布式特性也需要关注安全性和性能方面的问题的原理是什么是一种常用的网络工具用于测试主机之间的连通性和测量网络延迟它基于互联网控制报文协议来实现以下是的基本工作原理发送请求当用户在命令行中执行命令并指定目标主机的地址或域名时操作系统会创建一个请求报文封装报文请求报文包含一个特定的标识符和序列号以及一些其他的控制信息操作系统将报文封装在数据包中设置目标地址为目标主机的地址发送数据包操作系统将封装好的数据包发送到本地网络接口通过网络传输到目标主机目标主机的响应目标主机接收到请求后会检查目标地址是否与自己匹配如果匹配则生成一个响应报文返回响应数据包目标主机将响应报文封装在数据包中并将数据包发送回源主机的地址源主机接收响应源主机接收到响应后会检查标识符和序列号是否与发送的请求匹配如果匹配则认为目标主机可达并计算往返时间的原理基于协议它通过发送请求并接收响应来测试主机之间的连通性命令通常用于诊断网络问题测量网络延迟和检查主机的可达性通过比较发送请求和接收响应之间的时间差可以估计网络的延迟情况什么是和有什么区别互联网协议第版是互联网上的一种网络协议用于为设备分配唯一的地址以及进行数据包传输它是互联网协议第版的继任者的引入主要是为了解决地址空间不足支持更多的设备连接以及提供更好的网络性能和安全性等问题主要的区别如下地址空间最显著的区别是提供了远远超过的地址空间使用位地址最多支持约亿个不同的地址而采用位地址可支持的地址数量极其庞大约为个这解决了中地址短缺的问题使每个设备都能够拥有唯一的地址地址表示地址使用冒号分隔的组进制数表示例如为了缩短表示允许省略前导零以及连续的零块则使用点分十进制表示例如自动配置支持更强大的自动地址配置机制设备可以通过路由器通告协议自动获取地址和其他网络配置信息从而简化了网络设置安全性在设计时考虑了更多的安全性特性包括内置的互联网协议安全支持可以更轻松地实现网络通信的加密和认证移动性支持更好地支持移动设备有助于实现无缝漫游和移动地址的更改流量控制和质量服务引入了更灵活和精细的流量控制和质量服务机制有助于提供更稳定和高效的网络传输在中由于地址短缺常常需要使用来将多个设备共享单个公共地址在中地址数量充足减少了对的需求有助于简化网络配置尽管带来了许多优势但由于网络基础设施的升级以及应用程序和设备的适配等问题目前全球网络仍然广泛使用然而随着时间的推移的推广和采用逐渐增加以满足不断增长的互联网连接需求什么是正向代理和反向代理正向代理和反向代理是两种常见的代理服务器配置用于在客户端和目标服务器之间进行中间转发和处理正向代理正向代理是位于客户端和目标服务器之间的代理服务器当客户端发送请求时请求首先被发送到正向代理服务器然后由代理服务器转发请求到目标服务器并将响应返回给客户端客户端通常需要配置代理服务器的地址和端口以便与目标服务器通信正向代理的主要功能包括隐藏客户端的真实地址客户端的请求被代理服务器转发目标服务器只能看到代理服务器的地址无法直接获取客户端的真实地址访问控制和过滤代理服务器可以实施访问控制策略限制客户端对目标服务器的访问它还可以过滤请求和响应对流量进行审查和修改缓存代理服务器可以缓存目标服务器的响应以减轻目标服务器的负载并提高响应速度加速和优化代理服务器可以对请求和响应进行优化例如压缩加密负载均衡等以提供更快的访问速度和更好的性能反向代理反向代理是位于目标服务器和客户端之间的代理服务器当客户端发送请求时请求首先被发送到反向代理服务器然后由代理服务器将请求转发到一个或多个目标服务器最后将目标服务器的响应返回给客户端客户端不需要知道目标服务器的存在只需要与反向代理服务器通信反向代理的主要功能包括负载均衡反向代理可以将请求分发到多个目标服务器以平衡服务器负载提高系统的可扩展性和容错性安全性和保护反向代理可以充当防火墙保护目标服务器免受恶意请求和攻击例如攻击缓存和加速反向代理可以缓存目标服务器的响应以提供更快的访问速度和更好的性能加密和解密反向代理可以处理加密和解密减轻目标服务器的负载总结正向代理是代理客户端的请求代表客户端与目标服务器通信而反向代理是代理目标服务器的响应代表目标服务器与客户端通信两者在网络架构中扮演不同的角色提供不同的功能和优势什么是跨域访问问题如何解决跨域访问问题是由浏览器的同源策略引起的同源策略是一种安全机制它限制了一个网页中的脚本只能访问同源相同协议域名和端口的资源防止恶意网站通过脚本访问其他网站的数据当网页中的代码尝试从一个源域请求另一个源的资源时浏览器会发出跨域请求如果目标资源的服务器没有正确配置跨域访问策略浏览器会阻止该请求从而导致跨域访问问题为了解决跨域访问问题可以采取以下方法服务器端设置响应头目标服务器可以在响应中设置特定的响应头来允许跨域访问常见的响应头是它指定允许访问资源的域服务器可以设置该头为特定的域名或使用通配符表示允许任意域名进行访问例如设置响应头请求时添加额外的头信息发起跨域请求时可以在请求中添加一些额外的头信息例如头用于告知服务器请求的来源服务器可以根据该头信息来判断是否允许跨域访问并设置相应的响应头使用代理可以在自己的服务器上设置代理将跨域请求转发到目标服务器客户端与自己的服务器进行通信而自己的服务器与目标服务器进行通信从而避免了浏览器的跨域限制是一种跨域访问的解决方案它通过在页面中动态创建标签将跨域请求转换为对一个包含回调函数的的请求服务器返回的响应会被包裹在回调函数中从而实现跨域数据的获取代理可以使用代理服务器将跨域请求发送到代理服务器代理服务器再将请求发送到目标服务器并将响应返回给客户端这样客户端与代理服务器之间是同源的避免了跨域问题需要注意的是解决跨域访问问题需要在目标服务器上进行配置或采取相应的措施因为同源策略是由浏览器实施的安全机制另外一些高级的跨域访问场景可能需要更复杂的解决方案如使用跨域资源嵌入等什么是为什么他可以做缓存全称为内容分发网络是一种分布式网络架构旨在加速网站和应用程序的内容传输提高用户访问体验和性能通过将内容部署到全球各地的服务器节点上使用户可以从距离更近的服务器获取所需的资源从而减少延迟和网络拥塞的工作原理如下缓存服务器会缓存网站的静态资源如图片文件等将这些资源复制到分布在全球各地的服务器节点上就近访问当用户访问网站时请求会被路由到距离用户最近的节点该节点会检查是否有所需的缓存内容如果有缓存就直接返回缓存的资源减少了从源服务器请求资源的时间和延迟动态负载均衡如果节点没有所需的缓存内容它会根据一定的负载均衡算法将请求转发到源服务器从中获取内容这样可以分担源服务器的负载提高整体性能内容更新当源服务器的内容发生变化时会根据设置的策略进行内容更新新的内容会被传送到节点从而保持内容的最新状态之所以能够做缓存主要是因为它能够将静态资源复制到分布在各地的服务器节点上并将这些资源保存在节点的缓存中这样做带来了以下优势降低延迟用户从距离更近的节点获取资源减少了数据传输的时间从而降低了延迟提高了网站的响应速度减轻源服务器负载缓存静态资源的节点可以减轻源服务器的负载使其能够更专注地处理动态请求提高了整体的性能和稳定性抵御突发流量节点可以分散突发的用户请求使源服务器不容易被突发的大量访问所压垮提高可用性的分布式架构提高了内容的可用性即使某个节点发生故障仍然可以从其他节点获取内容总的来说通过缓存静态资源就近访问负载均衡等方式显著地改善了网站和应用程序的性能提高了用户体验同时降低了源服务器的负载消息队列简述的架构设计的服务节点队列是的内部对象用于存储消息中消息只能存储在队列中生产者投递消息到队列消费者从队列中获取消息并消费多个消费者可以订阅同一个队列这时队列中的消息会被平均分摊轮询给多个消费者进行消费而不是每个消费者都收到所有的消息进行消费注意不支持队列层面的广播消费如果需要广播消费可以采用一个交换器通过路由绑定多个队列由多个消费者来订阅这些队列的方式交换器生产者将消息发送到由交换器将消息路由到一个或多个队列中如果路由不到或返回给生产者或直接丢弃或做其它处理路由生产者将消息发送给交换器的时候一般会指定一个用来指定这个消息的路由规则这个路由需要与交换器类型和绑定键联合使用才能最终生效在交换器类型和绑定键固定的情况下生产者可以在发送消息给交换器时通过指定来决定消息流向哪里通过绑定将交换器和队列关联起来在绑定的时候一般会指定一个绑定键这样就可以指定如何正确的路由到队列了交换器和队列实际上是多对多关系就像关系数据库中的两张表他们通过做关联多对多关系表在投递消息时可以通过和对应就可以找到相对应的队列信道信道是建立在之上的虚拟连接当应用程序与建立连接的时候客户端紧接着可以创建一个信道每个信道都会被指派一个唯一的处理的每条指令都是通过信道完成的信道就像电缆里的光纤束一条电缆内含有许多光纤束允许所有的连接通过多条光线束进行传输和接收介绍一下有几种工作模式是一种流行的消息中间件它支持多种工作模式以满足不同的消息传递需求以下是中常见的几种工作模式简单模式也被称为点对点模式在这种模式下有一个生产者将消息发送到队列然后有一个消费者从队列中接收和处理消息应用场景将发送的电子邮件放到消息队列然后邮件服务在队列中获取邮件并发送给收件人工作队列模式在多个消费者之间分配任务竞争的消费者模式一个生产者对应多个消费者一般适用于执行资源密集型任务单个消费者处理不过来需要多个消费者进行处理应用场景一个订单的处理需要有多个订单可以同时放到消息队列然后让多个消费者同时处理这样就是并行了而不是单个消费者的串行情况发布订阅模式一次向许多消费者发送消息一个生产者发送的消息会被多个消费者获取也就是将消息将广播到所有的消费者中应用场景更新商品库存后需要通知多个缓存和多个数据库这里的结构应该是一个类型交换机扇出两个个消息队列分别为缓存消息队列数据库消息队列一个缓存消息队列对应着多个缓存消费者一个数据库消息队列对应着多个数据库消费者路由模式有选择地接收消息发送消息到交换机并且要指定路由消费者将队列绑定到交换机时需要指定路由仅消费指定路由的消息应用场景如在商品库存中增加了台促销活动消费者指定为只有此促销活动会接收到消息其它促销活动不关心也不会消费此的消息主题模式根据主题来接收消息将路由和某模式进行匹配此时队列需要绑定在一个模式上匹配一个词或多个词只匹配一个词应用场景同上促销活动可以接收主题为的消息如等发布者确认与发布者进行可靠的发布确认发布者确认是扩展可以实现可靠的发布在通道上启用发布者确认后将异步确认发送者发布的消息应用场景对于消息可靠性要求较高比如钱包扣款而一旦我们使用了消息队列我们基本都要保证消息的百分百投递因此建议使用的时候尽量选择该模式这种模式用的很少如何确保消息发送消息接收即消息百分百投递问题发送方确认机制信道需要设置为模式则所有在信道上发布的消息都会分配一个唯一一旦消息被投递到可持久化的消息需要写入磁盘信道会发送一个确认给生产者包含消息唯一如果消息和队列是可持久化的那么确认消息会在将消息写入磁盘之后发出如果发生内部错误从而导致消息丢失会发送一条未确认消息给生产者所有被发送的消息都将被即或者被一次但是没有对消息被的快慢做任何保证并且同一条消息不会既被又被发送方确认模式是异步的生产者应用程序在等待确认的同时可以继续发送消息当确认消息到达生产者生产者的回调方法会被触发来处理该确认消息如果因为自身内部错误导致消息丢失就会发送一条消息生产者应用程序同样可以在回调方法中处理该消息接口只确认是否正确到达中成功到达则回调接口消息失败返回时回调接收方确认机制消费者在声明队列时可以指定参数当时会等待消费者显式发回信号后才从内存或者磁盘持久化消息中移去消息否则消息被消费后会被立即删除消费者接收每一条消息后都必须进行确认消息接收和消息确认是两个不同操作只有消费者确认了消息才能安全地把消息从队列中删除不会为未的消息设置超时时间它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开这么设计的原因是允许消费者消费一条消息的时间可以很长保证数据的最终一致性如果消费者返回之前断开了链接会重新分发给下一个订阅的消费者可能存在消息重复消费的隐患需要去重消息队列本身可以进行消息持久化即使挂了重启后也能恢复数据如果要进行消息持久化那么需要对以下种实体均配置持久化声明时设置持久化并且不自动删除声明时设置持久化并且不自动删除发送消息时通过设置持久化消息事务消息通过对信道的设置实现通知服务器开启事务模式服务端会返回发送消息可以是多条可以是消费消息提交提交事务回滚事务消费者使用事务手动提交以事务提交或回滚为准不支持事务的也就是说你即使在收到消息之后在回滚事务也是于事无补的队列已经把消息移除了如果其中任意一个环节出现问题就会抛出异常用户可以拦截异常进行事务回滚或决定要不要重复消息事务消息会降低的性能如何实现延迟消息本身并不直接支持延迟消息的功能但可以通过结合使用的一些特性来实现延迟消息的效果下面介绍两种常见的实现方式利用消息的过期时间和死信队列这种方式可以通过设置消息的过期时间来实现延迟消息的效果具体步骤如下创建一个普通的交换机和队列用于接收延迟消息设置队列的消息过期时间可以通过设置队列的参数或通过单独设置消息的属性设置队列的死信交换机和死信路键将过期的消息发送到指定的死信交换机和路由键创建一个死信交换机和队列用于处理过期的消息将队列绑定到死信交换机上指定合适的路由键发送延迟消息时将消息发送到普通的交换机和队列消息会在指定的过期时间后发送到死信交换机和队列从而实现延迟消息的效果使用的延迟插件社区提供了一个延迟插件可以直接实现延迟消息的功能具体步骤如下下载并安装插件启用延迟插件通过的管理界面或命令行工具进行配置创建一个延迟交换机和队列将延迟插件应用到交换机上发送延迟消息时将消息发送到延迟交换机和队列同时设置消息的延迟时间延迟交换机会根据消息的延迟时间将消息发送到指定的目标队列从而实现延迟消息的效果需要注意的是以上两种方式都是通过消息的过期时间来实现延迟消息的因此在使用时需要根据实际需求和性能考虑合适的延迟时间设置另外延迟消息的实现可能会增加系统的复杂性和消息的处理延迟需要根据具体业务场景进行评估和选择如何保证消息的顺序性消息队列中的若干消息如果是对同一个数据进行操作这些操作具有前后的关系必须要按前后的顺序执行否则就会造成数据异常举例比如通过进行两个数据库的数据同步由于对数据库的数据操作是具有顺序性的如果操作顺序搞反就会造成不可估量的错误比如数据库对一条数据依次进行了插入更新删除操作这个顺序必须是这样如果在同步过程中消息的顺序变成了删除插入更新那么原本应该被删除的数据就没有被删除造成数据的不一致问题举例场景一个有多个去消费这样就会造成顺序的错误从里面读取数据是有序的但是每个的执行时间是不固定的无法保证先读到消息的一定先完成操作这样就会出现消息并没有按照顺序执行造成数据顺序错误一个对应一个但是里面进行了多线程消费这样也会造成消息消费顺序错误解决方案拆分多个每个一个就是多一些而已确实是麻烦点这样也会造成吞吐量下降可以在消费者内部采用多线程的方式取消费一个对应一个或者就一个但是对应一个然后这个内部用内存队列做排队然后分发给底层不同的来处理一个对应一个采用多线程如何使用解决分布式事务分布式事务不同的服务操作不同的数据源库或表保证数据一致性的问题解决采用消息最终一致性的解决方案解决分布式事务问题分布式事务场景电商项目中的商品库和库数据同步问题电商项目中支付订单库存一系列操作进行状态更改等在互联网应用中基本都会有用户注册的功能在注册的同时我们会做出如下操作收集用户录入信息保存到数据库向用户的手机或邮箱发送验证码等等如果是传统的集中式架构实现这个功能非常简单开启一个本地事务往本地数据库中插入一条用户数据发送验证码提交事物但是在分布式架构中用户和发送验证码是两个独立的服务它们都有各自的数据库那么就不能通过本地事物保证操作的原子性这时我们就需要用到消息队列来为我们实现这个需求在用户进行注册操作的时候我们为该操作创建一条消息当用户信息保存成功时把这条消息发送到消息队列验证码系统会监听消息一旦接受到消息就会给该用户发送验证码如何防止消息重复消费保证消息幂等性和保证接口幂等性一样等任何队列不保证消息不重复如果业务需要消息不重复消费则需要消费端处理业务消息要保持幂等性方式一的做消息去重版本目前不支持设置过期时间中操作判断是否已经操作过消费忽略重复消费方式二的原子操作自增大于返回值大于则说明消费过可以是消息的取值或者如果消息设计合理直接用做消费忽略重复消费方式三数据库去重表设计一个去重表某个字段使用的做唯一索引因为存在唯一索引所以重复消费会失败方式四数据库主键唯一约束但是注意不能把主键设置为了自增因此需要生成一个唯一的全局作为主键方式五利用消息队列自带的判断消息唯一性在消费端机制如果判断该消息已经处理过一次判断是否已经处理过一次消息消息已重复处理拒绝再次接收拒绝消息该消息不是重复的方式六利用机制生产者消费者接收到的消息为消息为代表是重复的如何解决消息队列的延时以及过期失效问题消息队列满了之后该如何处理有几百万的消息持续积压几小时说说如何解决方案分析该问题其本质针对的场景都是说可能你的消费端出了问题不消费了或者消费的极其极其慢另外还有可能你的消息队列集群的磁盘都快写满了都没人消费这个时候怎么办或者是整个这就积压了几个小时你这个时候怎么办或者是你积压的时间太长了导致比如设置了消息过期时间后就没了怎么办所以这种问题线上常见的一般不出一出就是大问题一般常见于举个例子消费端每次消费之后要写结果挂了消费端挂掉了导致消费速度极其慢分析话术这个是我们真实遇到过的一个场景确实是线上故障了这个时候要不然就是修复的问题让他恢复消费速度然后傻傻的等待几个小时消费完毕可行但是不建议在面试的时候说一个消费者一秒是条一秒个消费者是条一分钟是万条多万条所以如果你积压了几百万到上千万的数据即使消费者恢复了也需要大概小时的时间才能恢复过来一般这个时候只能操作临时紧急扩容了具体操作步骤和思路如下先修复的问题确保其恢复消费速度然后将现有都停掉新建一个是原来的倍临时建立好原先倍或者倍的数量然后写一个临时的分发数据的程序这个程序部署上去消费积压的数据消费之后不做耗时的处理直接均匀轮询写入临时建立好的倍数量的接着临时征用倍的机器来部署每一批消费一个临时的数据这种做法相当于是临时将资源和资源扩大倍以正常的倍速度来消费数据等快速消费完积压数据之后得恢复原先部署架构重新用原先的机器来消费消息分析话术是可以设置过期时间的就是如果消息在中积压超过一定的时间就会被给清理掉这个数据就没了那这就是第二个坑了这就不是说数据会大量积压在里而是大量的数据会直接搞丢这个情况下就不是说要增加消费积压的消息因为实际上没啥积压而是丢了大量的消息我们可以采取一个方案就是批量重导这个我们之前线上也有类似的场景干过就是大量积压的时候我们当时就直接丢弃数据了然后等过了高峰期以后比如大家一起喝咖啡熬夜到晚上点以后用户都睡觉了这个时候我们就开始写程序将丢失的那批数据写个临时程序一点一点的查出来然后重新灌入里面去把白天丢的数据给他补回来也只能是这样了假设万个订单积压在里面没有处理其中个订单都丢了你只能手动写程序把那个订单给查出来手动发到里去再补一次分析话术如果走的方式是消息积压在里那么如果你很长时间都没处理掉此时导致都快写满了咋办这个还有别的办法吗没有谁让你第一个方案执行的太慢了你临时写程序接入数据来消费消费一个丢弃一个都不要了快速消费掉所有的消息然后走第二个方案到了晚上再补数据吧分布式核心中间件一注册中心如何选型选择注册中心时需要考虑以下几个方面的因素高可用性注册中心是服务治理的核心组件因此高可用性是非常重要的注册中心应该能够容忍单点故障并且能够自动进行故障转移和恢复性能和扩展性注册中心需要能够处理大量的服务实例注册和查询请求并保持较低的延迟此外注册中心还应该支持水平扩展以应对日益增长的服务规模数据一致性注册中心应该保证数据的一致性即使在面对网络分区或节点故障的情况下也能保持数据的可靠性和准确性安全性注册中心应该提供合适的安全机制包括身份认证访问控制和数据加密等以保护服务实例的注册信息和通信数据的安全功能和灵活性注册中心应该提供丰富的功能如服务发现负载均衡服务路由健康检查等还应该具备灵活的配置和扩展能力以满足不同的业务需求社区支持和生态系统选择一个有活跃的社区和丰富的生态系统的注册中心可以获得更好的技术支持和资源以及更多的集成和扩展选项常见的注册中心选型包括等每个注册中心都有其特点和优势需要根据具体的业务需求和技术栈来选择适合的注册中心同时也可以考虑多个注册中心组合使用以实现高可用性和灵活性的要求什么是主要用来作什么是一个开源的分布式服务注册和配置中心它提供了服务注册发现配置和管理的能力可以帮助开发者构建和管理微服务架构主要功能包括服务注册与发现充当了服务注册中心的角色服务提供者通过向注册自己的服务使得服务消费者能够方便地发现和调用服务动态配置管理提供了统一的配置管理功能可以集中管理应用程序的配置信息它支持动态刷新配置可以在运行时动态修改应用程序的配置而无需重启应用服务路由与负载均衡可以根据服务的健康状况和负载情况动态地进行服务路由和负载均衡以提供更好的服务质量和可用性服务共享与版本管理支持多租户的服务共享不同的租户可以共享同一个服务同时还提供了版本管理功能可以管理不同版本的服务服务监控与治理提供了服务的健康检查和监控功能可以实时监控服务的状态和性能指标此外还提供了服务熔断限流等治理能力以提高系统的稳定性和可靠性总之是一个功能强大的分布式服务注册和配置中心它可以帮助开发者简化微服务架构的开发和管理工作提高系统的弹性和可伸缩性是的还是的是一个可用性和分区容忍性的系统在分布式系统中定理指出一个系统无法同时满足一致性可用性和分区容忍性这三个特性选择了模型即在面对网络分区时为了保证系统的可用性和分区容忍性它牺牲了一致性这意味着在网络分区的情况下可能会出现数据的不一致性但它能够保证服务的可用性和高效性对于服务注册发现配置管理等功能提供了强大的可用性和灵活性使得开发者能够便捷地构建和管理分布式系统然而在某些特定情况下如果一致性是系统中最重要的特性那么可能需要考虑选择其他模型的系统如何实现的配置变化客户端可以感知到通过以下机制实现配置变化客户端可以感知到长轮询客户端可以向发送一个长轮询请求如果配置发生变化会立即返回配置变化的通知给客户端客户端在收到通知后可以及时更新本地配置客户端缓存客户端会在本地缓存配置信息定期从服务器拉取最新的配置当服务器上的配置发生变化时客户端会通过定时任务或者其他方式从服务器获取最新的配置事件通知机制会将配置变更事件发布给订阅了该配置的客户端客户端可以订阅特定的配置当该配置发生变化时会发送事件通知给客户端客户端收到通知后可以进行相应的处理通过以上机制实现了配置变化的实时感知客户端可以根据自身的需求选择适合的方式来获取配置变化的通知并进行相应的处理这样当配置发生变化时客户端可以及时更新配置实现配置的动态管理能同时实现和的原理是什么能够同时实现可用性和分区容忍性和一致性和分区容忍性的原理是通过引入不同的组件和机制来实现的在中服务注册和发现模块采用了模型通过将服务实例的注册信息存储在多个节点上实现了服务的高可用性和分区容忍性当某个节点发生故障或网络分区时其他节点仍然可以提供服务注册和发现的功能而配置管理模块则采用了模型通过使用协议来实现一致性当客户端更新配置时会将配置写入多个节点的日志中经过多数节点的确认后才会认为配置写入成功这保证了配置的一致性在配置变更时通过协议的复制机制确保配置变更在集群中的所有节点上同步保证了配置的一致性和可靠性通过这种方式在不同的模块中根据需求选择了合适的一致性和可用性模型从而同时实现了和的特性这使得能够满足分布式系统在服务注册发现和配置管理等方面的需求提供高可用性弹性和可靠性的服务服务发现的原理服务发现调用方在第一去发起远程调用的时候会把远程的服务以及该服务的实例都缓存到本地中当后面在去发起远程调用的时候就会优先查询本地如果本地有那么直接根据本地的数据去发起远程调用如若没有才像远程发送一个请求获取到远程数据在同步到缓存有了本地缓存机制就可以保证我未来发起远程调用的时候更快但是会带来数据一致性问题如何解决本地缓存和远程数据一致性问题被动定时拉取每隔钟会发起一个查询远程最新数据来同步本地这样做虽然能够解决最终这两份数据是一致的但是在这一次定时任务和下一次定时任务开始之间远程注册表发生了变化那么就获取不到远程最新而对于定时任务发请求去要远程数据这个环节走的是协议而用了协议之后就可以保证数据包不丢失但是协议会有三次握手和四次挥手因此从效率来说会慢一些初始化执行这个定时任务如果在某一次找远程要的时候没有出现异常那么这个任务每隔会继续执行但是如果在找远程要数据的时候出现了异常那么这个时间就会从开始最多到钟结束主动推送更新一旦远程注册表发生了改变那么服务端会主动发送一个事件并且使用的是协议来发送的接着我客户端只要订阅了这个的端口那么就会让客户端主动去找远程获取最新的注册表协议快因为没有三次握手和四种挥手的过程但是可能会丢失数据包最终来解决服务发现数据不一致问题是通过协议的定时任务发请求和协议的主动发送事件请求来解决一致性的注册中心原理注册中心架构剖析流程图具体细节请结合课上分析二的调用原理首先如果你对某个接口定义了注解就会针对这个接口创建一个动态代理的动态代理会根据你在接口上的等注解来动态构造出你要请求的服务的地址最后针对这个地址发起请求解析响应注册中心原理的底层调用源码大致流程判断当前代理的方式是不是如果是直接结束因为本地服务有这些方法压根不需要从远程来要核心代理逻辑从一个派发器中获取解析当前方法的处理器派发器的结构是一个来获取解析这个方法的处理器默认从这个中找到的方法处理器是同步方法处理器构建一个作用是为了发请求的是时候用这个模版造一个请求细节根据老的请求模版构建一个新的请求模版接着会将老的请求模版中的一些参数放到新的请求模版中但是请求头中参数如果没有在中去指定的话那么这个老模版中就没有头而新模板中也就没有请求头数据因此后面在用这个新模版创建请求的时候该请求就没有请求头数据所以在远程调用时出现了请求头丢失问题支持可以独立对自己的业务远程接口去指定一些连接超时时间和读取的超时时间得到一个重试器如果在发送远程调用的时候出现异常那么在底层会用捕捉到然后进行重试但是对于重试自己也有规则如果一旦在重试期间出现了异常直接将异常抛出结束这一次远程调用如果在重试期间没有出现异常但是通过最大次数次调用如果到了最大次数那么仍然是会抛出异常结束这一次远程调用执行并解码执行指的是要去给远程发请求解码远程给我的数据都是字节流我要将自字节流转成我业务能用的对象反序列化发送请求根据服务名从找到该服务下的所有客户端然后负载均衡的掉用某一个并且在第一次找该客户端的时候会将第一次找到的这个客户端放到缓存中去下一次再来发起远程调用的时候直接从缓存中获取该客户端对响应的数据进行反序列化远程调用的本质建立连接给远程发送请求远程处理数据远程响应数据将数据进行渲染为什么要使用使用有以下几个主要原因强大的全文搜索功能是一个基于的分布式搜索引擎具有强大的全文搜索和检索功能它支持复杂的查询语法和多种搜索方式能够高效地处理大量的文本数据这使得它非常适合用于构建搜索引擎日志分析内容推荐等应用分布式和高可用性是一个分布式系统它能够将数据分布在多个节点上进行存储和计算这使得它具有高可用性和横向扩展能力能够处理大规模数据和高并发访问它还支持故障转移和自动数据恢复即使某个节点发生故障系统仍然可以继续运行实时数据分析和聚合提供了强大的聚合功能能够对大规模数据进行实时的数据分析和统计它支持各种聚合操作如求和平均值最大最小值分组计数等能够快速生成各种报表和可视化图表帮助用户更好地理解和利用数据构建实时应用具有低延迟的写入和查询能力能够快速响应实时数据的变化这使得它非常适合用于构建实时监控实时推荐实时搜索等实时应用场景生态系统和易用性拥有丰富的生态系统包括用于数据可视化用于日志收集和处理用于数据采集等它还提供了和丰富的客户端库使得开发和集成变得非常简单和灵活综上所述因其强大的全文搜索能力分布式和高可用性特性实时数据分析能力以及丰富的生态系统而成为一种流行的选择适用于各种大规模数据处理和实时应用场景为什么快之所以快速主要有以下几个原因倒排索引使用倒排索引来加速搜索过程倒排索引是一种将词条与其出现位置的映射关系存储在索引中的数据构通过倒排索引可以快速定位包含特定词条的文档从而加搜索效率分布式架构是一个分布式系统它可以将数据分布在多个节点上进行存储和计算这使得它具有横向扩展能力能够处理大规模数据和高并发访问通过将数据分片和分布式查询可以并行处理搜索请求从而提高搜索效率倒排索引的内存缓存使用内存缓存来提高搜索性能它会将热门的词条和搜索结果存储在内存中以便快速响应查询请求通过利用内存缓存可以避免频繁的磁盘访问而加速搜索速度集群化部署和负载均衡支持集群化部署可以将索引和查询请求分布在多个节点上它还提供了负载均衡机制能够均衡地将请求分发给不同的节点从而提高整体的处理能力和响应速度后台实时刷新机制采用了近实时的刷新机制当数据写入到时它会先写入内存缓冲区然后异步地刷新到磁盘这样可以避免频繁地磁盘写入同时保证数据的可靠性和一致性综上所述通过倒排索引分布式架构内存缓存负载均衡和实时刷新机制等技术手段实现了高效的搜索和查询功能从而使其具备快速响应和处理大规模数据的能力倒排索引是什么倒排索引是一种将词条与其出现位置的映射关系存储在索引中的数据结构它是一种反转倒排了文档词条关系的索引方式通常一个正向索引是通过文档来查找对应的词条而倒排索引则是通过词条来查找对应的文档在倒排索引中每个词条都会关联一个或多个文档对于每个词条倒排索引会记录下它在哪些文档中出现过以及出现的位置这样当需要搜索某个词条时可以快速地找到包含该词条的文档倒排索引通常由两个主要部分组成词典和倒排列表词典以词条为键记录了每个词条对应的倒排列表的位置而倒排列表则包含了所有包含该词条的文档以及出现位置的信息倒排索引的结构使得搜索引擎能够快速定位包含特定词条的文档从而加快搜索的速度它是搜索引擎中常用的索引结构被广泛应用于全文搜索文本分析和信息检索等领域如何保证和数据库的数据一致性为了保证和数据库的数据一致性可以采取以下几种方式实时同步在数据更新到数据库之后立即将相应的数据同步到中可以通过在应用程序的业务逻辑中同时更新数据库和来实现实时同步这样可以保证数据库和中的数据始终保持一致延迟同步在数据更新到数据库之后通过定时任务或消息队列等机制定期批量将更新的数据同步到中这种方式可以降低对数据库写入操作的性能影响并在一定程度上保证数据的同步性双写模式在数据更新时同时向数据库和进行写入操作这种方式可以确保数据同时写入到两个存储系统从而保证数据的一致性但是需要注意双写模式可能增加系统的复杂度和写入延迟使用数据库的日志或触发器数据库的日志或触发器可以捕获数据的变更操作然后通过监听这些变更操作将数据同步到中这种方式可以避免对应用程序进行大量修改但需要考虑数据库和之间的网络延迟和数据同步的顺序无论采取哪种方式都需要确保数据库和的数据操作是原子的可靠的并且在故障恢复时能够保持数据的一致性此外还可以通过监控和日志记录来及时发现和解决数据同步的问题确保数据的一致性和可靠性微服务分布式分布式和微服务的区别是什么分布式系统和微服务是两个相关但不同的概念它们都涉及到软件架构中的组织和设计原则以下是它们的区别定义和范围分布式系统分布式系统是由多台计算机或服务器协同工作通过网络通信来完成共同的任务这些计算机可以分布在不同的地理位置但它们通过网络连接进行协作微服务微服务是一种软件架构风格将一个大型应用程序拆分成一组小型独立的服务每个微服务都专注于执行一个特定的业务功能可以独立开发部署和扩展关注点分布式系统关注于如何将不同的计算机或服务器连接起来以实现高性能高可用性和负载均衡等目标微服务关注于如何将大型应用程序拆分成更小更可管理的部分并通过松耦合的方式来实现更灵活的开发部署和维护通信方式分布式系统分布式系统中的组件之间需要进行网络通信常见的通信方式包括远程过程调用消息队列等微服务微服务之间通常使用等协议进行通信可以通过或其他通信方式来实现数据一致性分布式系统在分布式系统中确保数据一致性是一个挑战需要考虑分布式事务数据复制等问题微服务每个微服务可以拥有自己的数据存储因此可以根据需求选择适当的数据库类型并更容易管理数据一致性部署和扩展分布式系统需要关注整体系统的部署和扩展可能需要考虑多台服务器的管理和配置微服务每个微服务都可以独立部署和扩展使得开发团队更容易管理和调整特定功能总的来说分布式系统是一种基础架构模式而微服务是一种架构风格微服务通常可以在分布式系统中实现但并不是所有分布式系统都采用微服务架构微服务架构的主要目标是使开发部署和维护更加灵活适用于复杂的应用场景什么是微服务架构优势特点微服务架构是一种软件架构风格将一个大型的应用程序拆分成多个小型自治的服务单元每个服务单元都专注于执行特定的业务功能每个微服务可以独立开发部署扩展和维护通过轻量级通信机制协同工作微服务架构的优势和特点包括模块化与自治性微服务架构通过拆分应用为多个服务单元使得开发团队可以更加专注于各自的业务领域每个微服务都是独立的有自己的代码数据库等可以在不影响其他服务的情况下进行修改和更新灵活性与快速交付微服务的自治性使得团队可以独立地开发测试部署和发布服务这种独立性加速了开发周期使团队能够更快地交付新功能和更新可扩展性微服务架构允许单独扩展每个服务根据需求动态分配资源这使得系统更具弹性能够应对高负载和流量峰值技术多样性不同的微服务可以使用不同的技术栈因为它们之间通过通信这允许团队选择最适合其任务的技术而不受整个应用的技术限制容错性与隔离性由于微服务是自治的一个服务的故障不会影响整个系统故障在较小的范围内隔离从而提高了整体系统的容错性持续集成与持续交付微服务架构有助于实现持续集成和持续交付因为每个服务可以独立地构建测试和发布这有助于减少部署的风险并快速响应用户需求灵活的团队组织微服务架构鼓励小团队负责特定的微服务使得团队更加灵活能够快速做出决策和调整然而微服务架构也带来了一些挑战如分布式系统的复杂性服务间通信的管理数据一致性等问题对于不同的应用场景需仔细权衡微服务的优势与挑战以确定是否采用这种架构负载均衡算法类型轮询法将请求按顺序轮流地分配到后端服务器上它均衡地对待后端的每一台服务器而不关心服务器实际的连接数和当前的系统负载随机法通过系统的随机算法根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问由概率统计理论可以得知随着客户端调用服务端的次数增多其实际效果越来越接近于平均分配调用量到后端的每一台服务器也就是轮询的结果源地址哈希法源地址哈希的思想是根据获取客户端的地址通过哈希函数计算得到的一个数值用该数值对服务器列表的大小进行取模运算得到的结果便是客服端要访问服务器的序号采用源地址哈希法进行负载均衡同一地址的客户端当后端服务器列表不变时它每次都会映射到同一台后端服务器进行访问加权轮询法不同的后端服务器可能机器的配置和当前系统的负载并不相同因此它们的抗压能力也不相同给配置高负载低的机器配置更高的权重让其处理更多的请而配置低负载高的机器给其分配较低的权重降低其系统负载加权轮询能很好地处理这一问题并将请求顺序且按照权重分配到后端加权随机法与加权轮询法一样加权随机法也根据后端机器的配置系统的负载分配不同的权重不同的是它是按照权重随机请求后端服务器而非顺序最小连接数法最小连接数算法比较灵活和智能由于后端服务器的配置不尽相同对于请求的处理有快有慢它是根据后端服务器当前的连接情况动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求尽可能地提高后端服务的利用效率将负责合理地分流到每一台服务器类型方式实现负载均衡硬件负载均衡和软件负载均衡其中的区别七层负载均衡支持协议同时也支持层负载均衡支持七层规则的性能也很不错默认使用的负载均衡软件就是运行在内核态性能是软件负载均衡中最高的严格来说工作在三层所以更通用一些适用各种应用服务分布式架构下共享有什么方案采用无状态服务抛弃使用中间件存储比如等把放到中存储虽然架构上变得复杂并且需要多访问一次但是这种方案带来的好处也是很大的存入要考虑跨域问题且有安全风险集群同步使用绑定策略使用或其他复杂均衡软硬件中的绑定策略同一个只能在指定的同一个机器访问但是这样做失去了负载均衡的意义当挂掉一台服务器的时候会影响一批用户的使用风险很大实现了共享好处可以水平扩展增加服务器服务器重启不丢失不过也要注意数据在中的刷新失效机制不仅可以跨服务器共享甚至可以跨平台例如网页端和端理论理论一致性即更新操作成功并返回客户端后所有节点在同一时间的数据完全一致对于客户端来说一致性指的是并发访问时更新过的数据如何获取的问题从服务端来看则是更新后如何复制分布到整个系统以保证数据最终一致可用性即服务一直可用而且是正常响应时间系统能够很好的为用户服务不出现用户操作失败或者访问超时等用户体验不好的情况分区容错性即分布式系统在遇到某节点或网络分区故障的时候仍然能够对外提供满足一致性和可用性的服务分区容错性要求能够使应用虽然是一个分布式系统而看上去却好像是在一个可以运转正常的整体比如现在的分布式系统中有某一个或者几个机器宕掉了其他剩下的机器还能够正常运转满足系统需求对于用户而言并没有什么体验上的影响和分区容错是必须保证的当发生网络分区的时候如果要继续服务那么强一致性和可用性只能选是基本可用软状态和最终一致性理论是对中一致性和可用性权衡的结果其来源于对大规模互联网系统分布式实践的总结是基于定理逐步演化而来的理论的核心思想是即使无法做到强一致性但每个应用都可以根据自身业务特点采用适当的方式来使系统达到最终一致性基本可用响应时间上的损失正常情况下处理用户请求需要返回结果但是由于系统出现故障处理用户请求的时间变为系统功能上的损失正常情况下用户可以使用系统的全部功能但是由于系统访问量突然剧增系统的部分非核心功能无法使用软状态数据同步允许一定的延迟最终一致性系统中所有的数据副本在经过一段时间的同步后最终能够达到一个一致的状态不要求实时分布式生成方案当前日期和时间时间戳时钟序列计数器全局唯一的机器识别号如果有网卡从网卡地址获得没有网卡以其他方式获得优点代码简单性能好本地生成没有网络消耗保证唯一相对而言重复概率极低可以忽略缺点每次生成的都是无序的而且不是全数字且无法保证趋势递增生成的是字符串字符串存储性能差查询效率慢写的时候由于不能产生顺序的操作在进行操作可能会导致频繁的页分裂这种操作在记录占用空间比较大的情况下性能下降比较大还会增加读取磁盘次数长度过长不适用于存储耗费数据库性能无一定业务含义可读性差数据库自增序列单机模式优点实现简单依靠数据库即可成本小数字化单调自增满足数据库存储和查询性能具有一定的业务可读性结合业务缺点强依赖存在单点问题如果数据库宕机则业务不可用生成性能有限单点数据库压力大无法扛高并发场景信息安全问题比如暴露订单量查询改一下查到别人的订单分布式下生成的会重复数据库高可用多主模式做负载基于序列的起始值和步长设置不同的初始值相同的步长步长大于等于节点数优点解决了生成的单点问题同时平衡了负载解决了分布式环境下重复问题缺点系统扩容困难系统定义好步长之后增加机器之后调整步长困难主从同步的时候电商下单支付数据因为数据同步延迟导致查不到这个数据加不是最好的解决方式数据要求比较严谨的话查主库基于等中间件生成雪花算法生成一个的整性数字第一位符号位固定为位时间戳位位序列号位数可以有不同实现优点每个毫秒值包含的值很多不够可以变动位数来增加性能佳依赖的实现时间戳值在高位中间是固定的机器码自增的序列在低位整个是趋势递增的能够根据业务场景数据库节点布置灵活挑战位划分灵活度高缺点强依赖于机器时钟如果时钟回拨会导致重复的生成所以一般基于此的算法发现时钟回拨都会抛异常处理阻止生成这可能导致服务不可用分布式锁的解决方案需要这个锁独立于每一个服务之外而不是在服务里面数据库利用主键冲突控制一次只有一个线程能获取锁非阻塞不可重入单点失效时间分布式锁通过临时节点解决了死锁的问题一旦客户端获取到锁之后突然挂掉连接断开那么这个临时节点就会自动删除掉其他客户端自动获取锁临时顺序节点解决惊群效应分布式锁单线程处理网络请求不需要考虑并发安全性所有服务节点设置相同的返回为则锁获取失败问题早期版本没有超时参数需要单独设置存在死锁问题中途宕机后期版本提供加锁与设置时间原子操作但是存在任务超时锁自动释放导致并发问题加锁与释放锁不是同一线程问题删除锁判断线程唯一标志再删除可重入性及锁续期没有实现通过解决类似的实现看门狗监听机制意思的机制都只操作单节点即使通过保证高可用如果这个节点由于某些原因发生了主从切换那么就会出现锁丢失的情况同步设置可能数据丢失从多个节点申请锁当一半以上节点获取成功锁才算获取成功有相应的实现实现一个分布式锁需要考虑哪些问题实现一个分布式锁时需要考虑以下几个问题锁的唯一性在分布式环境下需要确保同一把锁在不同的节点之间是唯一的可以使用全局唯一标识符例如基于或的分布式锁来确保锁的唯一性死锁和活锁分布式环境下的死锁和活锁是需要避免的问题死锁是指多个节点互相等待对方释放锁的情况而活锁是指多个节点不断争夺锁资源但没有一个节点能够成功获取锁为了避免死锁和活锁可以使用超时机制重试机制随机等待时间等策略来解决锁的可重入性分布式锁是否支持可重入是需要考虑的问题可重入意味着同一个线程可以多次获取同一把锁而不会发生死锁在实现分布式锁时需要考虑是否支持可重入并在实现时进行相应的处理锁的粒度锁的粒度是指锁的范围即锁定的是整个系统模块方法还是更细粒度的资源在分布式环境下锁的粒度需要根据实际需求进行选择避免锁的范围大或过小锁的性能和可靠性分布式锁的性能和可靠性是需要考虑的问题锁的获取和释放需要保证高效且可靠同时要考虑网络延迟节点故障等因素对锁性能和可靠性的影响锁的容错和容量在分布式环境下需要考虑节点故障和网络分区等异常情况对锁的影响可以使用多个节点进行容错和冗余以确保锁的可用性和容量综上所述实现一个分布式锁需要考虑锁的唯一性死锁和活锁锁的可重入性锁的粒度锁的性能和可靠性以及锁的容错和容量等问题根据具体需求选择适合的分布式锁方案并在实现时合理处理这些问题什么是分布式事务分布式事务是指在分布式系统中涉及多个独立的数据库或服务的事务操作它需要确保这些操作要么全部成功执行要么全部回滚以保持数据的一致性和可靠性分布式事务的目标是在不同的系统之间维护数据的一致性即使在出现故障或部分操作失败的情况下也能够保持数据的正确性在传统的单一数据库事务中事务是由数据库管理系统负责管理和保障的但在分布式环境下涉及到多个独立的数据库或服务各自拥有独立的事务管理机制因此需要特殊的方法来确保分布式事务的一致性分布式事务面临的挑战和问题包括原子性分布式事务需要确保涉及的所有操作要么都成功执行要么都回滚不能出现部分操作成功而部分操作失败的情况一致性分布式事务需要保证各个参与方的数据保持一致性即在事务开始和结束时系统的数据状态应该满足特定的约束隔离性分布式事务的操作应该与其他事务隔离避免不同事务之间的干扰和冲突持久性分布式事务需要确保在事务提交后其结果被可靠地持久化以防止数据丢失为了实现分布式事务有一些常见的方法和技术包括两阶段提交三阶段提交补偿事务等这些方法在不同的场景下有不同的适用性和权衡开发人员需要根据系统的需求和复杂性选择适合的方法来处理分布式事务同时分布式事务的实现也需要考虑到性能可靠性和复杂性等方面的因素分布式事务解决方案规范分布式事务规范定义了分布式事务模型四个角色事务管理器协调者资源管理器参与者应用程序通信资源管理器全局事务一个横跨多个数据库的事务要么全部提交要么全部回滚事务时对规范的实现对应的单库事务两阶段协议第一阶段每个参与者执行本地事务但不提交进入状态并通知协调者已经准备就绪第二阶段当协调者确认每个参与者都后通知参与者进行操作如果有参与者则发送命令各参与者做回滚问题单点故障一旦事务管理器出现故障整个系统不可用参与者都会阻塞住数据不一致在阶段二如果事务管理器只发送了部分消息此时网络发生异常那么只有部分参与者接收到消息也就是说只有部分参与者提交了事务使得系统数据不一致响应时间较长参与者和协调者资源都被锁住提交或者回滚之后才能释放不确定性当协事务管理器发送之后并且此时只有一个参与者收到了那么当该参与者与事务管理器同时宕机之后重新选举的事务管理器无法确定该条消息是否提交成功三阶段协议主要是针对两阶段的优化解决了单点故障的问题但是性能问题和不一致问题仍然没有根本解决引入了超时机制解决参与者阻塞的问题超时后本地提交只有协调者有超时机制第一阶段阶段协调者询问事务参与者是否有能力完成此次事务如果都返回则进入第二阶段有一个返回或等待响应超时则中断事务并向所有参与者发送请求第二阶段阶段此时协调者会向所有的参与者发送请求参与者收到后开始执行事务操作参与者执行完事务操作后此时属于未提交事务的状态就会向协调者反馈表示我已经准备好提交了并等待协调者的下一步指令第三阶段阶段在阶段二中如果所有的参与者节点都返回了那么协调者就会从预提交状态转变为提交状态然后向所有的参与者节点发送请求参与者节点在收到提交请求后就会各自执行事务提交操作并向协调者节点反馈消息协调者收到所有参与者的消息后完成事务相反如果有一个参与者节点未完成的反馈或者反馈超时那么协调者都会向所有的参与者节点发送请求从而中断事务补偿事务针对每个操作都要注册一个与其对应的确认和补偿撤销操作操作做业务检查及资源预留做业务确认操作实现一个与相反的操作既回滚操作首先发起所有的分支事务的操作任何一个分支事务的操作执行失败将会发起所有分支事务的操作若操作全部成功将会发起所有分支事务的操作其中操作若执行失败会进行重试模型对业务的侵入性较强改造的难度较大每个操作都需要有三个接口实现和接口还必须实现幂等性消息队列的事务消息发送消息到消息中间件发送成功后执行本地事务如果事务执行成功则消息中间件将消息下发至消费端前消息不会被消费如果事务执行失败则回滚消息中间件将这条消息删除消费端接收到消息进行消费如果消费失败则不断重试需要注意的是每种分布式事务处理方法都有其适用的场景和权衡选择适当的方法取决于系统的要求复杂性和可用技术栈什么是和有什么区别和都是用于处理分布式事务的协议但它们在处理方式和适用场景上存在一些区别是一种分布式事务处理方法它将事务拆分为三个阶段尝试确认和取消每个阶段都有相应的操作在尝试阶段参与者尝试执行事务操作检查是否满足执行条件如果所有参与者的尝试都成功进入确认阶段参与者确认执行事务如果任何一个参与者的尝试失败或确认阶段失败将进入取消阶段执行事务的补偿操作来恢复系统到一致状态注重于事务的补偿机制以确保数据的一致性是另一种分布式事务处理协议它在全局协调器和多个参与者之间进行通信它有两个阶段准备和提交在准备阶段全局协调器将询问所有参与者是否可以执行事务参与者会回复可以或不可以如果所有参与者都回复可以则进入提交阶段在此阶段全局协调器通知所有参与者提交事务如果任何一个参与者回复不可以全局协调器会通知所有参与者中止事务依赖于中心化的协调器其缺点包括单点故障和阻塞的可能性区别处理方式采用尝试确认取消的模式强调补偿机制而采用两阶段提交的方式依赖全局协调器来决定提交或中止事务灵活性相对更加灵活因为它允许开发人员在尝试和确认阶段之间插入补偿逻辑较为严格需要参与者在准备阶段做出确定性的回应复杂性和性能通常比更适用于高并发环境因为它的操作相对较轻而的中心化协调可能导致性能瓶颈可用性通常在局部事务级别上具有更好的可用性因为每个参与者可以独立决定是否尝试事务在选择还是时需要根据系统的需求复杂性和可靠性等因素进行权衡什么是柔性事务柔性事务是一种用于分布式系统中的事务处理模式旨在处理跨多个参与者的分布式事务在分布式环境中事务涉及到多个资源或服务需要保证数据的一致性和可靠性柔性事务是为了在分布式系统中实现事务处理的灵活性和可扩展性而设计的柔性事务模式通常允许开发人员在事务的各个阶段插入逻辑以便在出现错误或异常情况时进行处理这种模式的核心思想是将事务处理拆分为三个阶段尝试确认和取消尝试在这个阶段事务的参与者尝试执行操作并在操作完成之前不对外部资源产生影响这是一个预提交的阶段用于检查所有资源是否可用并为后续的确认阶段做准备确认如果所有参与者的尝试阶段都成功那么系统会进入确认阶段在这个阶段参与者提交事务并将操作的结果应用到资源中如果在这个阶段发生了错误可以触发补偿逻辑回滚之前的操作以确保数据的一致性取消如果在确认阶段发生错误系统会进入取消阶段在这个阶段参与者会执行回滚操作将之前尝试阶段所做的更改撤销以保持数据的一致性柔性事务相对于传统的两阶段提交来说具有更高的灵活性和可用性它允许在不同的阶段插入补偿逻辑以应对各种异常情况同时减少了全局协调器的依赖从而降低了性能瓶颈的风险这使得柔性事务在高并发和复杂的分布式系统中更具优势如何基于本地消息表实现分布式事务当基于本地消息表实现分布式事务时通常会采用一种称为基于消息的最终一致性或最终一致性补偿模式这个模式可以帮助在分布式环境中处理事务性操作同时保持数据的一致性以下是基于本地消息表实现分布式事务的一般步骤操作记录与消息发送当一个分布式事务发起时主节点或服务将事务操作记录到本地数据库并将一个消息发送到消息队列中这个消息包含了执行的操作事务标识以及其他必要的信息消息传递与处理其他参与者节点在收到消息后根据消息中的操作类型执行相应的本地操作这些本地操作可能会修改各个节点的数据状态但在这个阶段不会立即确认事务的完成确认阶段在所有参与者节点执行完本地操作后各节点会将一个确认消息发送回主节点主节点根据收到的确认消息来判断是否可以提交事务如果有任何错误发生主节点可以触发补偿逻辑补偿阶段如果在确认阶段发生错误主节点可以通过发送补偿消息来触发参与者节点执行相反的操作以撤销之前的更改从而保持数据的一致性这就是所谓的最终一致性补偿完成或取消一旦确认阶段中的所有参与者节点都成功确认事务被视为成功完成如果在确认阶段有任何错误主节点会触发取消操作参与者节点会执行补偿操作将数据状态还原到事务开始前的状态基于本地消息表的分布式事务实现主要依赖于消息队列的可靠性和分布式事务的补偿能力这种模式可以提高分布式系统的可用性和容错性但同时也需要在应用程序中实现正确的补偿逻辑来处理可能的异常情况什么是他有哪几种模式是由阿里巴巴开源的一款分布式事务解决方案旨在解决分布式系统中的数据一致性问题提供了一套事务管理的解决方案支持对分布式事务进行管理和协调有以下三种常见的模式模式模式是最常用的模式它基于数据库的本地事务实现分布式事务的一致性在模式下通过拦截数据访问层的操作并将这些操作封装在一个全局事务中通过将事务信息存储在全局事务上下文中并协调各个分支事务的提交或回滚来实现式事务的一致性模式模式是一种补偿型的分布式事务模式在模式下通过定义三个阶段的操作阶段尝试执行业务操作阶段确认执行操作阶段撤销执行操作通过补偿机制来保证分布式事务的一致性即使在异常情况下也能够进行回滚或补偿模式模式是一种长事务的分布式事务模式通过将业务操作分解为一系列的子事务来实现每个子事务都有自己的回滚操作从而实现了分布式事务的逐步提交和回滚模式通过异步消息和补偿机制来实现事务的提交和回滚这三种模式在不同的场景下可以根据实际需求进行选择和组合使用以满足分布式系统的事务管理需求如何实现接口的幂等性机制服务端提供了发送的接口我们在分析业务的时候哪些业务是存在幂等问题的就必须在执行业务前先去获取服务器会把保存到中然后调用业务接口请求时把携带过去一般放在请求头部服务器判断是否存在中存在表示第一次请求然后删除继续执行业务如果判断不存在中就表示是重复操作直接返回重复标记给这样就保证了业务代码不被重复执行危险性先删除还是后删除先删除可能导致业务确实没有执行重试还带上之前由于防重设计导致请求还是不能执行后删除可能导致业务处理成功但是服务闪断出现超时没有删除别人继续重试导致业务被执行两边我们最好设计为先删除如果业务调用失败就重新获取再次请求获取比较和删除必须是原子性如果这两个操作不是原子可能导致高并发下都到同样的数据判断都成功继续业务并发执行可以在使用脚本完成这个操作各种锁机制数据库悲观锁数据库乐观锁这种方法适合在更新的场景中根据版本也就是在操作库存前先获取当前商品的版本号然后操作的时候带上此号我们梳理下我们第一次操作库存时得到为调用库存服务变成了但返回给订单服务出现了问题订单服务又一次发起调用库存服务当订单服务传如的还是再执行上面的语句时就不会执行因为已经变为了条件就不成立这样就保证了不管调用几次只会真正的处理一次业务层分布式锁如果多个机器可能在同一时间同时处理相同的数据比如多台机器定时任务都拿到了相同数据处理我们就可以加分布式锁锁定此数据处理完成后释放锁获取到锁的必须先判断这个数据是否被处理过各种唯一约束数据库唯一约束插入数据应该按照唯一索引进行插入比如订单号相同的订单就不可能有两条记录插入我们在数据库层面防止重复这个机制是利用了数据库的主键唯一约束的特性解决了在场景时幂等问题但主键的要求不是自增的主键这样就需要业务生成全局唯一的主键如果是分库分表场景下路由规则要保证相同请求下落地在同一个数据库和同一表中要不然数据库主键约束就不起效果了因为是不同的数据库和表主键不相关防重很多数据需要处理只能被处理一次比如我们可以计算数据的将其放入的每次处理数据先看这个是否已经存在存在就不处理表防重使用订单号做为去重表的唯一索引把唯一索引插入去重表再进行业务操作且他们在同一个事务中这个保证了重复请求时因为去重表有唯一约束导致请求失败避免了幂等问题这里要注意的是去重表和业务表应该在同一库中这样就保证了在同一个事务即使业务操作失败了也会把去重表的数据回滚这个很好的保证了数据一致性微服务架构的服务治理有哪些实现方案微服务架构的服务治理有以下几种实现方案服务注册与发现使用服务注册表来管理所有微服务的信息包括服务名称地址版本等服务提供者将自己的信息注册到注册表中服务消费者通过注册表来发现可用的服务常见的服务注册与发现工具有和等负载均衡通过在服务提供者与服务消费者之间引入负载均衡器将请求平均分配到多个服务实例上以提高系统的可伸缩性和可用性常见的负载均衡器有和等健康检查与容错机制通过定期的健康检查来监测服务的可用性和状态并根据检查结果进行容错处理比如自动剔除不可用的服务实例常见的健康检查工具有的的和等熔断器与降级在高并发或异常情况下通过熔断器来控制请求的流量避免服务的雪崩效应同时可以通过降级策略在服务不可用时返回默认值或者静态数据保证系统的可用性常见的熔断器和降级工具有的和等配置中心将微服务的配置集中管理实现配置的动态更新和版本控制通过配置中心可以动态修改微服务的配置而无需重启服务常见的配置中心有和等网关通过引入网关来对外暴露微服务的统一接口实现请求的路由转发和过滤等功能网关可以对请求进行鉴权和限流提供统一的访问控制和监控常见的网关有的和等以上是常见的微服务架构的服务治理实现方案可以根据实际需求选择适合的方案进行使用线程并发什么是并发答是指在一定时间内交替执行多任务的任务操作时有多个线程运行时间分为几个时间段然后将时间段分配给每个线程执行当线程代码在一段时间内运行时其他线程处于悬挂状并发和并行有什么区别答并发和并行是一个很容易混淆的概念并发是指多个任务的交替而平行是指真正意义上的同时进行事实上如果系统中只有一个在实际系统环境中不能并行使用多线程则只能通过切换时间片来交替执行任务真正的平行只能出现在拥有多个的系统中并发同时许多任务正在执行中单位时间内不一定同时执行并行在单位时间内同时执行多项任务为什么要使用并发答并发编程在一定程度上离不开多核的发展随着单核的研发无法遵循摩尔定律摩尔定律是基于硬件开发的观测定律也是基于摩尔定律的反摩尔定律不过反摩尔定律是软件领域的定律有兴趣的可以自己理解为了进一步提高计算速度硬件工程师不再追求单独的计算单元而是将多个计算单元集成在一起即形成多核短短十几年等家用可以达到个甚至个核心短短十几年等家用可以达到个甚至个核心专业服务器通常可以达到几个独立的每个甚至有个以上的核心因此摩尔定律它似乎继续体验的核心扩展在多核的背景下并发编程的趋势应运而生通过并发编程可以充分发挥多核的计算能力提高其性能并发编程有哪些缺点答上下文切换频繁时间片是分配给每个线程的时间因为时间很短所以不断切换线程让我们觉得多个线程是同时执行的时间片通常是几十毫秒每次切换时都需要保存当前状态以恢复以前的状态这种切换行为非常失去性能过于频繁的切换不能充分发挥多线程编程的优势无锁并发编程可用于通常减少上下文切换算法使用最少的线程和使用协程线程的安全问题多线程编程中最难把握的是临界区域的线程安全如果你不注意就会有死锁一旦产生死锁系统功能将不可用上下文切换是什么答多线程编程中一般线程的数量大于核心数而一个为了有效地执行这些线程核心只能在任何时候使用一个线程策略是将时间片分配到每个线程并旋转当一个线程的时间片用完时它将重新处于就绪状态供其他线程使用这个过程属于上下文切换上下文切换通常是计算密集型的换句话说它需要相当可观的处理器时间在每秒几十次或数百次的切换中每次切换都需要纳秒量级时间因此上下文切换意味着系统消耗了大量事实上时间可能是操作系统中时间消耗最大的操作与其他操作系统相比包括其他类别系统有很多优点其中之一就是上下文切换和模式切换的时间消耗很少使用多线程可能会带来什么问题答并发编程的目的是提高程序执行效率和程序运行速度但并发编程并不总是提高程序运行速度并发编程可能会遇到内存泄漏上下文切换死锁硬件和软件资源闲置等诸多问题简要总结线程与进程的关系答一个进程中可以有多个线程多个线程共享进程的堆叠和方法区之后的元空间资源但每个线程都有自己的程序计数器虚拟机栈和本地方法栈综上所述线程是过程划分为较小的操作单元线程和进程最大的区别在于每个进程基本上都是独立的而每个线程都不一定因为同一进程中的线程很可能相互影响线程执行成本小但不利于资源管理和保护进程恰恰相反的区别锁池所有需要竞争同步锁的线程都会放在锁池当中比如当前对象的锁已经被其中一个线程得到则其他线程需要在这个锁池进行等待当前面的线程释放同步锁后锁池中的线程去竞争同步锁当某个线程得到后会进入就绪队列进行等待资源分配等待池当我们调用方法后线程会放到等待池当中等待池的线程是不会去竞争同步锁只有调用了或后等待池的线程才会开始去竞争锁是随机从等待池选出一个线程放到锁池而是将等待池的所有线程放到锁池当中是类的静态本地方法则是类的本地方法方法不会释放但是会释放而且会加入到等待队列中方法不依赖于同步器但是需要依赖关键字不需要被唤醒休眠之后推出阻塞但是需要不指定时间需要被别人中断一般用于当前线程休眠或者轮循暂停操作则多用于多线程之间的通信会让出执行时间且强制上下文切换而则不一定后可能还是有机会重新竞争到锁继续执行的执行后线程直接进入就绪状态马上释放了的执行权但是依然保留了的执行资格所以有可能下次进行线程调度还会让这个线程获取到执行权继续执行执行后线程进入阻塞状态例如在线程中调用线程的那线程会进入到阻塞队列直到线程结束或中断线程这行代码必须要等全部执行完毕才会执行谈谈对线程安全的理解不是线程安全应该是内存安全堆是共享内存可以被所有线程访问当多个线程访问一个对象时如果不用进行额外的同步控制或其他的协调操作调用这个对象的行为都可以获得正确的结果我们就说这个对象是线程安全的堆是进程和线程共有的空间分全局堆和局部堆全局堆就是所有没有分配的空间局部堆就是用户分配的空间堆在操作系统对进程初始化的时候分配运行过程中也可以向系统要额外的堆但是用完了要还给操作系统要不然就是内存泄漏在中堆是虚拟机所管理的内存中最大的一块是所有线程共享的一块内存区域在虚拟机启动时创建堆所存在的内存区域的唯一目的就是存放对象实例几乎所有的对象实例以及数组都在这里分配内存栈是每个线程独有的保存其运行状态和局部自动变量的栈在线程开始的时候初始化每个线程的栈互相独立因此栈是线程安全的操作系统在切换线程的时候会自动切换栈栈空间不需要在高级语言里面显式的分配和释放目前主流操作系统都是多任务的即多个进程同时运行为了保证安全每个进程只能访问分配给自己的内存空间而不能访问别的进程的这是由操作系统保障的在每个进程的内存空间中都会有一块特殊的公共区域通常称为堆内存进程内的所有线程都可以访问到该区域这就是造成问题的潜在原因和的区别和的实质是继承关系没有可比性无论使用还是都会然后执行方法用法上如果有复杂的线程操作需求那就选择继承如果只是简单的执行一个任务那就实现会卖出多一倍的票正常卖出原因是创建了两个实例自然会卖出两倍属于用法错误谈谈对守护线程的理解守护线程为所有非守护线程提供服务的线程任何一个守护线程都是整个中所有非守护线程的保姆守护线程类似于整个进程的一个默默无闻的小喽喽它的生死无关重要它却依赖整个进程而运行哪天其他线程结束了没有要执行的了程序就结束了理都没理守护线程就把它中断了注意由于守护线程的终止是自身无法控制的因此千万不要把等重要操作逻辑分配给它因为它不靠谱守护线程的作用是什么举例垃圾回收线程就是一个经典的守护线程当我们的程序中不再有任何运行的程序就不会再产生垃圾垃圾回收器也就无事可做所以当垃圾回收线程是上仅剩的线程时垃圾回收线程会自动离开它始终在低级别的状态中运行用于实时监控和管理系统中的可回收资源应用场景来为其它线程提供服务支持的情况或者在任何情况下程序结束时这个线程必须正常且立刻关闭就可以作为守护线程来使用反之如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话那么这个线程就不能是守护线程而是用户线程通常都是些关键的事务比方说数据库录入或者更新这些操作都是不能中断的必须在之前设置否则会跑出一个异常你不能把正在运行的常规线程设置为守护线程在线程中产生的新线程也是的守护线程不能用于去访问固有资源比如读写操作或者计算逻辑因为它会在任何时候甚至在一个操作的中间发生中断自带的多线程框架比如会将守护线程转换为用户线程所以如果要使用后台线程就不能用的线程池的原理和使用场景每一个对象均含有一个类型的成员变量它存储本线程中所有对象及其对应的值由一个个对象构成继承自一个由对象和构成由此可见的是对象并且是一个弱引用当没指向的强引用后该就会被垃圾收集器回收当执行方法时首先会获取当前线程对象然后获取当前线程的对象再以当前对象为将值存储进对象中方法执行过程类似首先会获取当前线程对象然后获取当前线程的对象再以当前对象为获取对应的由于每一条线程均含有各自私有的容器这些容器相互独立互不影响因此不会存在线程安全性问题从而也无需使用同步机制来保证多条线程访问容器的互斥性使用场景在进行对象跨层传递的时候使用可以避免多次传递打破层次间的约束框架进行事务操作用于存储线程事务信息框架数据库连接会话管理框架的处理器请求管理框架在事务开始时会给当前线程绑定一个在整个事务过程都是使用该线程绑定的来执行数据库操作实现了事务的隔离性框架里面就是用的来实现这种隔离例子聪明出于勤奋天才在于积累聪明出于勤奋天才在于积累线程线程内存泄露原因如何避免内存泄露为程序在申请内存后无法释放已申请的内存空间一次内存泄露危害可以忽略但内存泄露堆积后果很严重无论多少内存迟早会被占光不再会被使用的对象或者变量占用的内存不能被回收就是内存泄露强引用使用最普遍的引用一个对象具有强引用不会被垃圾回收器回收当内存空间不足虚拟机宁愿抛出错误使程序异常终止也不回收这种对象如果想取消强引用和某个对象之间的关联可以显式地将引用赋值为这样可以使在合适的时间就会回收该对象弱引用进行垃圾回收时无论内存是否充足都会回收被弱引用关联的对象在中用类来表示可以在缓存中使用弱引用的实现原理每一个维护一个为使用弱引用的实例为线程变量的副本使用的弱引用作为如果一个不存在外部强引用时势必会被回收这样就会导致中为而还存在着强引用只有线程退出以后的强引用链条才会断掉但如果当前线程再迟迟不结束的话这些为的的就会一直存在一条强引用链红色链条使用强引用当的为强引用回收时因为还持有的强引用如果没有手动删除不会被回收使用弱引用当的为弱引用回收时由于持有的弱引用即使没有手动删除也会被回收当为时调用完方法之后在调用方法的时候会清除值因此内存泄漏的根源是由于的生命周期跟一样长如果没有手动删除对应的就会导致内存泄漏而不是因为弱引用正确的使用姿势每次使用完都调用它的方法清除数据并发的三大特征原子性原子性是指在一个操作中不可以在中途暂停然后再调度即不被中断操作要不全部执行完成要不都不执行就好比转账从账户向账户转元那么必然包括个操作从账户减去元往账户加上元个操作必须全部完成将从主存读到工作内存中的副本中的运算将结果写入工作内存将工作内存的值刷回主存什么时候刷入由操作系统决定不确定的那程序中原子性指的是最小的操作单元比如自增操作它本身其实并不是原子性操作分了步的包括读取变量的原始值进行加操作写入工作内存所以在多线程中有可能一个线程还没自增完可能才执行到第二部另一个线程就已经读取了值导致结果错误那如果我们能保证自增操作是一个原子性的操作那么就能保证其他线程读取到的一定是自增后的数据关键字可见性当多个线程访问同一个变量时一个线程修改了这个变量的值其他线程能够立即看得到修改的值若两个线程在不同的那么线程改变了的值还没刷新到主存线程又使用了那么这个值肯定还是之前的线程对变量的修改线程没看到这就是可见性问题线程线程如果线程改变了的值线程一定会停止吗不一定当线程更改了变量的值之后但是还没来得及写入主存当中线程转去做其他事情了那么线程由于不知道线程对变量的更改因此还会一直循环下去关键字有序性虚拟机在进行代码编译时对于那些改变顺序之后不会对最终结果造成影响的代码虚拟机不一定会按照我们写的代码的顺序来执行有可能将他们重排序实际上对于有些代码进行重排序之后虽然对变量的值没有造成影响但有可能会出现线程安全问题方法里的和做了重排序线程先对赋值为随后执行到线程直接计算出结果再到线程这时候才赋值为很明显迟了一步关键字本身就包含了禁止指令重排序的语义而关键字是由一个变量在同一时刻只允许一条线程对其进行操作这条规则明确的关键字同时满足以上三种特性但是关键字不满足原子性在某些情况下的同步机制的性能确实要优于锁使用关键字或包里面的锁因为的总开销要比锁低我们判断使用还是加锁的唯一依据就是的语义能否满足使用的场景原子性内存模型内存模型简称是一种抽象的概念并不真实存在它描述的是一组规则或规范通过这组规范定义了程序中各个变量包括实例字段静态字段的访问方式运行程序的实体是线程而每个线程创建时都会为其创建一个工作内存有些地方称为栈空间用于存储线程私有的数据而内存模型中规定所有变量都存储在主内存主内存是共享内存区域所有线程都可以访问但线程对变量的操作读取赋值等必须在工作内存中进行首先要将变量从主内存拷贝的自己的工作内存中然后对变量进行操作操作完成后再将变量写回主内存不能直接操作主内存中的变量工作内存中存储着主内存中的变量副本拷贝前面说过工作内存是每个线程的私有数据区域因此不同的线程间无法访问对方的工作内存线程间的通信传值必须通过主内存来完成规定了内存主要划分为主内存和工作内存两种主内存主要存储的是实例对象所有线程创建的实例对象都存放在主内存中当然也包括了共享的类信息常量静态变量由于是共享数据区域多条线程对同一个变量进行访问可能会发生线程安全问题共享变量如果一个变量被多个线程使用那么这个变量会在每个线程的工作内存中保有一个副本这种变量就是共享变量工作内存主要存储当前方法的所有本地变量信息工作内存中存储着主内存中的变量副本拷贝每个线程只能访问自己的工作内存即线程中的本地变量对其它线程是不可见的就算是两个线程执行的是同一段代码它们也会各自在自己的工作内存中创建属于当前线程的本地变量当然也包括了字节码行号指示器相关方法的信息注意由于工作内存是每个线程的私有数据线程间无法相互访问工作内存因此存储在工作内存的数据不存在线程安全问题模型入下图基于规范注意不同于内存区域模型与内存区域的划分是不同的概念层次更恰当说描述的是一组规则通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式是围绕原子性有序性可见性展开与内存区域唯一相似点都存在共享数据区域和私有数据区域在中主内存属于共享数据区域从某个程度上讲应该包括了堆和方法区而工作内存数据线程私有数据区域从某个程度上讲则应该包括程序计数器虚拟机栈以及本地方法栈对共享内存的操作做出了如下两条规定线程对共享内存的所有操作都必须在自己的工作内存中进行不能直接从主内存中写不同线程无法直接访问其他线程工作内存中的变量因此共享变量的值传递需要通过主内存完成存在的必要性由于运行程序的实体是线程而每个线程创建时都会为其创建一个工作内存有些地方称为栈空间用于存储线程私有的数据线程与主内存中的变量操作必须通过工作内存间接完成主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间然后对变量进行操作操作完成后再将变量写回主内存那么如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题假设主内存中存在一个共享变量初始值为现在有和两条线程分别对该变量进行操作线程各自的工作内存中存在共享变量副本假设现在线程想要修改的值为而线程却想要读取的值那么线程读取到的值是线程更新后的值还是更新前的值呢答案是不确定即线程有可能读取到线程更新前的值也有可能读取到线程更新后的值这是因为工作内存是每个线程私有的数据区域而线程操作变量时即将拷贝到自己的工作内存中首先是将变量从主内存拷贝到线程的工作内存中然后对变量进行操作操作完成后再将变量写回主内存而对于线程的也是类似的这样就有可能造成主内存与工作内存间数据存在一致性问题假如线程修改完后正在将数据写回主内存而线程此时正在读取主内存这样线程读取到的值就是但如果线程已将写回主内存后线程才开始读取的话那么此时线程读取到的就是谈谈关键字的理解验证可见性我是子线程工作内存的值子线程结束让线程完全启动我是主线程工作内存的值验证有序性第次打印不具备原子性为什么用线程池解释下线程池参数降低资源消耗提高线程利用率降低创建和销毁线程的消耗提高响应速度任务来了直接有线程可用可执行而不是先创建线程再执行提高线程的可管理性线程是稀缺资源使用线程池可以统一分配调优监控线程池参数代表核心线程数也就是正常情况下创建工作的线程数这些线程创建后并不会消除而是一种常驻线程代表的是最大线程数它与核心线程数相对应表示最大允许被创建的线程数比如当前任务较多将核心线程数都用完了还无法满足需求时此时就会创建新的线程但是线程池内线程总数不会超过最大线程数表示超出核心线程数之外的线程的空闲存活时间也就是核心线程不会消除但是超出核心线程数的部分线程如果空闲一定的时间则会被消除我们可以通过来设置空闲时间用来存放待执行的任务假设我们现在核心线程都已被使用还有任务进来则全部放入队列直到整个队列被放满但任务还再持续进入则会开始创建新的线程实际上是一个线程工厂用来生产线程执行任务我们可以选择使用默认的创建工厂产生的线程都在同一个组内拥有相同的优先级且都不是守护线程当然我们也可以选择自定义线程工厂一般我们会根据业务来制定不同的线程工厂任务拒绝策略有两种情况第一种是当我们调用等方法关闭线程池后这时候即使线程池内部还有没执行完的任务正在执行但是由于线程池已经关闭我们再继续想线程池提交任务就会遭到拒绝另一种情况就是当达到最大线程数线程池已经没有能力继续处理新提交的任务时这是也就拒绝线程池的工作原理在创建了线程池后线程池中的线程数为零当调用方法添加一个请求任务时线程池会做出如下判断如果正在运行的线程数量小于那么马上创建线程运行这个任务如果正在运行的线程数量大于或等于那么将这个任务放入队列如果这个时候队列满了且正在运行的线程数量还小于那么还是要创建非核心线程立刻运行这个任务如果队列满了且正在运行的线程数量大于或等于那么线程池会启动默认的拒绝策略来执行当一个线程完成任务时它会从队列中取下一个任务来执行当一个线程无事可做超过一定的时间时线程会判断如果当前运行的线程数大于那么这个线程就被停掉所以线程池的所有任务完成后它最终会收缩到的大小注意提交一个时不管当前线程池中的线程是否空闲只要数量小于核心线程数就会创建新线程注意相当于是非公平的比如队列满了之后提交的可能会比正在排队的先执行线程池的五种状态是如何流转的线程池有五种状态会接收新任务并且会处理队列中的任务不会接收新任务并且会处理队列中的任务不会接收新任务并且不会处理队列中的任务并且会中断在处理的任务所有任务都终止了线程池中也没有线程了这样线程池的状态就会转为一旦达到此状态就会调用线程池的执行完之后就会转变为这五种状态并不能任意转换只会有以下几种转换情况手动调用触发或者线程池对象时会调用从而调用调用触发如果先调紧着调就会发生队列为空并且线程池中没有线程时自动转换线程池中没有线程时自动转换队列中可能还有任务执行完后就会自动转换线程池为什么一定得是阻塞队列线程池中的线程在运行过程中执行完创建线程时绑定的第一个任务后就会不断的从队列中获取任务并执行那么如果队列中没有任务了线程为了不自然消亡就会阻塞在获取队列任务时等着队列中有任务过来就会拿到任务从而去执行任务通过这种方法能最终确保线程池中能保留指定个数的核心线程数关键代码某个线程在从队列获取任务时会判断是否使用超时阻塞获取我们可以认为非核心线程会核心线程会非核心线程超过时间还没获取到任务后面就会自然消亡了线程发生异常会被移出线程池吗答案是会的那有没有可能核心线程数在执行任务时都出错了导致所有核心线程都被移出了线程池在源码中当执行任务时出现异常时最终会执行执行完这个方法后当前线程也就自然消亡了但是方法中会额外再新增一个线程这样就能维持住固定的核心线程数线程池的核心线程数最大线程数该如何设置我们都知道线程池中有两个非常重要的参数核心线程数表示线程池中的常驻线程的个数最大线程数表示线程池中能开辟的最大线程个数那这两个参数该如何设置呢我们对线程池负责执行的任务分为三种情况密集型任务比如找出中的素数密集型任务比如文件网络混合型任务密集型任务的特点时线程在执行任务时会一直利用所以对于这种情况就尽可能避免发生线程上下文切换比如现在我的电脑只有一个如果有两个线程在同时执行找素数的任务那么这个就需要额外的进行线程上下文切换从而达到线程并发的效果此时执行这两个任务的总时间为任务执行时间线程上下文切换的时间而如果只有一个线程这个线程来执行两个任务那么时间为任务执行时间所以对于密集型任务线程数最好就等于核心数可以通过以下拿到你电脑的核心数只不过为了应对线程执行过程发生异常导致线程阻塞的请求我们可以额外在多设置一个线程这样当某个线程暂时不需要时可以有替补线程来继续利用所以对于密集型任务我们可以设置线程数为核心数我们在来看型任务线程在执行型任务时可能大部分时间都阻塞在上假如现在有个如果我们只设置了个线程来执行型任务那么很有可能这个线程都阻塞在了上这样这个就都没活干了所以对于型任务我们通常会设置线程数为核心数不过就算是设置为了核心数也不一定是最佳的比如有个线程数为那么也有可能这个线程同时阻塞在了上所以可以再增加线程从而去压榨的利用率通常如果型任务执行的时间越长那么同时阻塞在上的线程就可能越多我们就可以设置更多的线程但是线程肯定不是越多越好我们可以通过以下这个公式来进行计算线程数核心数线程等待时间线程运行总时间线程等待时间指的就是线程没有使用的时间比如阻塞在了线程运行总时间指的是线程执行完某个任务的总时间我们可以利用抽样来估计这两个时间图中表示在刚刚这次抽样过程中总共的执行时间为利用了的时间为所以没有利用的时间为所以我们可以计算出线程等待时间线程运行总时间所以线程数所以根据公式算出来的线程为个线程左右按上述公式如果我们执行的任务密集型任务那么线程等待时间线程运行总时间所以线程数核心数线程等待时间线程运行总时间核心数核心数以上只是理论实际工作中情况会更复杂比如一个应用中可能有多个线程池除开线程池中的线程可能还有很多其他线程或者除开这个应用还是一些其他应用也在运行所以实际工作中如果要确定线程数最好是压测这个接口会执行我现在利用来压这是在默认最大个线程的请求下的压测结果当我们把线程数调整为发现执行效率提高了一倍假如再增加线程数到提升就不那么高了总结我们再工作中对于密集型任务核心数这样既能充分利用也不至于有太多的上下文切换成本型任务建议压测或者先用公式计算出一个理论值理论值通常都比较小对于核心业务访问频率高可以把核心线程数设置为我们压测出来的结果最大线程数可以等于核心线程数或者大一点点比如我们压测时可能会发现个线程最佳但是个线程时也还行此时就可以为最大线程数对于非核心业务访问频率不高核心线程数可以比较小避免操作系统去维护不必要的线程最大线程数可以设置为我们计算或压测出来的结果是如何自定义线程池的中用的线程池为注意类名和下的一样但是包名不一样会创建这个线程注意传入的队列为它的入队逻辑为特殊在入队时如果线程池的线程个数等于最大线程池数入队入队时如果线程池有闲置线程任务依旧入队入队时如果线程池的线程个数小于最大线程池数会返回表示入队失败则去创建线程这样就控制了的这个线程池在提交任务时不会先判断线程个数是否小于核心线程数而是提前创建个核心线程如果等于最大线程数会入队但是线程个数小于最大线程数会入队失败从而会去创建线程所以随着任务的提交会优先创建线程直到线程个数等于最大线程数才会入队当然其中有一个比较细的逻辑是在提交任务时如果正在处理的任务数小于线程池中的线程个数那么也会直接入队而不会去创建线程也就是上面源码中的作用变量和变量有什么区别答首先变量看起来像变量但功能不同变量可以保证先行关系即后续读操作前会发生写操作但它不能保证原子性例如如果用修改变量那么操作不是原子性的类提供的方法可以使该操作具有原子性如方法可以增加原子性并添加当前值其他数据类型和引用变量也可以进行类似的操作缓存是的还是的是一个支持多种数据结构的内存数据库它可以根据配置和使用方式在和之间做出选择具体来说可以在不同的场景下提供不同的一致性级别在默认情况下追求最高的性能和可用性更倾向于模型即可用性优先它使用主从复制和哨兵机制来实现高可用性但在出现网络分区或节点故障时可能会导致数据的不一致性但是也提供了一些支持一致性的特性例如和通过使用这些特性可以在需要更高一致性的场景下选择模型即一致性优先在中数据被分片存储在不同的节点上并使用协议来保持数据的一致性则提供了监控和自动故障转移的功能以保证高可用性和数据的一致性因此根据具体的配置和使用方式可以在和之间进行选择介绍一下的集群方案主从模式哨兵模式哨兵是集群中非常重要的一个组件主要有以下功能集群监控负责监控和进程是否正常工作消息通知如果某个实例有故障那么哨兵负责发送消息作为报警通知给管理员故障转移如果挂掉了会自动转移到上配置中心如果故障转移发生了通知客户端新的地址哨兵用于实现集群的高可用本身也是分布式的作为一个哨兵集群去运行互相协同工作故障转移时判断一个是否宕机了需要大部分的哨兵都同意才行涉及到了分布式选举即使部分哨兵节点挂掉了哨兵集群还是能正常工作的哨兵通常需要个实例来保证自己的健壮性哨兵主从的部署架构是不保证数据零丢失的只能保证集群的高可用性对于哨兵主从这种复杂的部署架构尽量在测试环境和生产环境都进行充足的测试和演练模式是一种服务端技术版本开始正式提供采用槽的概念一共分成个槽将请求发送到任意节点接收到请求的节点会将查询请求发送到正确的节点上执行方案说明通过哈希的方式将数据分片每个节点均分存储一定哈希槽哈希值区间的数据默认分配了个槽位每份数据分片会存储在多个互为主从的多节点上数据写入先写主节点再同步到从节点支持配置为阻塞同步同一分片多个节点间的数据不保持强一致性读取数据时当客户端操作的没有分配在该节点上时会返回转向指令指向正确的节点扩容时需要需要把旧节点的数据迁移一部分到新节点在架构下每个要放开两个端口号比如一个是另外一个就是加的端口号比如端口号是用来进行节点间通信的也就是的通信用来进行故障检测配置更新故障转移授权用了另外一种二进制的协议协议用于节点间进行高效的数据交换占用更少的网络带宽和处理时间优点无中心架构支持动态扩容对业务透明具备的监控和自动故障转移能力客户端不需要连接集群所有节点连接集群中任何一个可用节点即可高性能客户端直连服务免去了代理的损耗缺点运维也很复杂数据迁移需要人工干预只能使用号数据库不支持批量操作管道操作分布式逻辑和存储模块耦合等是出来之前业界普遍使用的多实例集群方法其主要思想是采用哈希算法将数据的进行散列通过函数特定的会映射到特定的节点上客户端驱动支持功能即以及结合缓存池的优点优势在于非常简单服务端的实例彼此独立相互无关联每个实例像单服务器一样运行非常容易线性扩展系统的灵活性很强缺点由于处理放到客户端规模进一步扩大时给运维带来挑战客户端不支持动态增删节点服务端实例群拓扑结构有变化时每个客户端都需要更新调整连接不能共享当应用规模增大时资源浪费制约优化什么是的数据分片的数据分片是一种数据分布在多个节点上的技术用于实现水平扩展和负载均衡在中数据分片是通过哈希槽来实现的具体而言数据分片的过程如下哈希槽的定义将整个数据空间划分为固定数量的哈希槽通常是个每个哈希槽都有一个唯一的标识符从到数据的映射当客户端发送一个命令请求时通过对的哈希值进行计算将键值对映射到一个特定的哈希槽中这样每个键值对就被分配到了一个特定的哈希槽中哈希槽的分配将所有的哈希槽均匀地分配给各个节点每个节点负责存储一部分哈希槽对应的数据这样数据就被分片存储在了多个节点上数据的查找当客户端需要访问某个键值对时它首先计算键的哈希值然后根据哈希值找到对应的哈希槽客户端根据哈希槽的信息找到负责该哈希槽的节点并将请求发送给该节点数据的迁移当需要添加或删除节点时会进行数据的迁移以保持各个节点负载均衡数据迁移的过程中哈希槽会从一个节点移动到另一个节点保证数据的分片均匀和一致通过数据分片可以在多个节点上并行处理请求提高了系统的吞吐量和容量同时数据分片还实现了负载均衡和故障隔离当某个节点故障时其他节点仍然可以继续提供服务总的来说的数据分片通过哈希槽的方式将数据分布在多个节点上实现了水平扩展负载均衡和故障隔离为什么这么快之所以被认为是快速的主要有以下几个原因内存存储将数据存储在内存中而不是磁盘上相比于磁盘访问内存访问速度更快可以实现很低的延迟和高吞吐量单线程模型采单线程模型避免了多线程间的竞争和上下文切换的开销线程模型简化了并发控制减少了锁的使用提高了处理请求的效率高效的数据结构提供了多种高效的数据结构如字符串哈希表跳跃表集合和有序集合等这些数据结构在内部实现上都经过了优化能够快速地进行插入删除查找和遍历操作异步操作支持异步操作可以在后台执行一些耗时的操作如持久化复制和集群的同步等这样可以减少客户端的等待时间提高系统的响应速度高效的网络通信核心自定义的协议进行网络通信协议本身简单而高效的网络通信采用非阻塞多路复用机制和事件驱动的方式可以处理大量的并发连接提高了系统的并发性能优化的算法和数据结构在内部实现中使用了许多优化的算法和数据结构例如使用跳跃表来实现有序集合使用压缩列表来存储小规模的列表和哈希表等这些优化可以减少内存占用和提高数据操作的效率总的来说之所以快速是因为它使用内存存储采用单线程模型提供高效的数据结构支持异步操作优化网络通信和使用优化的算法和数据结构等这些特性使得能够在处理大量请求时保持低延迟和高吞吐量的事务机制是怎样的事务开始命令的执行标识着一个事务的开始命令会将客户端状态的属性中打开标识来完成的命令入队当一个客户端切换到事务状态之后服务器会根据这个客户端发送来的命令来执行不同的操作如果客户端发送的命令为中的一个立即执行这个命令否则将命令放入一个事务队列里面然后向客户端返回回复如果客户端发送的命令为四个命令的其中一个那么服务器立即执行这个命令如果客户端发送的是四个命令以外的其他命令那么服务器并不立即执行这个命令首先检查此命令的格式是否正确如果不正确服务器会在客户端状态的属性关闭标识并且返回错误信息给客户端如果正确将这个命令放入一个事务队列里面然后向客户端返回回复事务执行客户端发送命令服务器执行命令逻辑如果客户端状态的属性不包含标识或者包含或者标识那么就直接取消事务的执行否则客户端处于事务状态有标识服务器会遍历客户端的事务队列然后执行事务队列中的所有命令最后将返回结果全部返回给客户端不支持事务回滚机制但是它会检查每一个事务中的命令是否错误事务不支持检查那些程序员自己逻辑错误例如对类型的数据库键执行对类型的操作命令是一个乐观锁可以为事务提供行为可以监控一个或多个键一旦其中有一个键被修改或删除之后的事务就不会执行监控一直持续到命令命令用于开启一个事务它总是返回执行之后客户端可以继续向服务器发送任意多条命令这些命令不会立即被执行而是被放到一个队列中当命令被调用时所有队列中的命令才会被执行执行所有事务块内的命令返回事务块内所有命令的返回值按命令执行的先后顺序排列当操作被打断时返回空值通过调用客户端可以清空事务队列并放弃执行事务并且客户端会从事务状态中退出命令可以取消对所有的监控的持久化机制是怎样的提供了两种方式的持久化机制分别是快照和日志在指定的时间间隔内将内存中的数据集快照写入磁盘实际操作过程是一个子进程先将数据集写入临时文件写入成功后再替换之前的文件用二进制压缩存储优点整个数据库将只包含一个文件方便持久化容灾性好方便备份性能最大化子进程来完成写操作让主进程继续处理命令所以是最大化使用单独子进程来进行持久化主进程不会进行任何操作保证了的高性能相对于数据集大时比的启动效率更高缺点数据安全性低是间隔一段时间进行持久化如果持久化之间发生故障会发生数据丢失所以这种方式更适合数据要求不严谨的时候由于是通过子进程来协助完成数据持久化工作的因此如果当数据集较大时可能会导致整个服务器停止服务几百毫秒甚至是秒钟以日志的形式记录服务器所处理的每一个写删除操作查询操作不会记录以文本的方式记录可以打开文件看到详细的操作记录优点数据安全中提供了中同步策略即每秒同步每修改同步和不同步事实上每秒同步也是异步完成的其效率也是非常高的所差的是一旦系统出现宕机现象那么这一秒钟之内修改的数据将会丢失而每修改同步我们可以将其视为同步持久化即每次发生的数据变化都会被立即记录到磁盘中通过模式写文件即使中途服务器宕机也不会破坏已经存在的内容可以通过工具解决数据一致性问题机制的模式定期对文件进行重写以达到压缩的目的缺点文件比文件大且恢复速度慢数据集大的时候比启动效率低运行效率没有高和对比文件比更新频率高优先使用还原数据比更安全也更大性能比如果两个都配了优先加载比较默认选择数据格式格式所有写命令压缩的二进制文件数据的安全性三种写回策略决定分钟级别数据的丢失文件大小大小恢复速度慢快重写机制重写阻塞主线的性能三种写回策略决定分钟级别的快照数据恢复的选择的过期策略是怎么样的是数据库我们可以设置中缓存的的过期时间的过期策略就是指当中缓存的过期了如何处理惰性过期只有当访问一个时才会判断该是否已过期过期则清除该策略可以最大化地节省资源却对内存非常不友好极端情况可能出现大量的过期没有再次被访问从而不会被清除占用大量内存定期过期每隔一定的时间会扫描一定数量的数据库的字典中一定数量的并清除其中已过期的该策略是一个折中方案通过调整定时扫描的时间间隔和每次扫描的限定耗时可以在不同情况下使得和内存资源达到最优的平衡效果字典会保存所有设置了过期时间的的过期时间数据其中是指向键空间中的某个键的指针是该键的毫秒精度的时间戳表示的过期时间键空间是指该集群中保存的所有键中同时使用了惰性过期和定期过期两种过期策略的内存淘汰策略是怎么样的之前一共实现了种内存淘汰策略在之后又增加了种策略我们可以按照是否会进行数据淘汰把它们分成两类不进行数据淘汰的策略只有这一种会进行淘汰的种其他策略会进行淘汰的种策略再进一步根据淘汰候选数据集的范围把它们分成两类在设置了过期时间的数据中进行淘汰包括后新增四种在所有数据范围内进行淘汰包括后新增三种具体解释下各个策略默认情况下在使用的内存空间超过值时并不会淘汰数据也就是设定的策略对应到缓存也就是指一旦缓存被写满了再有写请求来时不再提供服务而是直接返回错误用作缓存时实际的数据集通常都是大于缓存容量的总会有新的数据要写入缓存这个策略本身不淘汰数据也就不会腾出新的缓存空间我们不把它用在缓存中接着和这四种淘汰策略它们筛选的候选数据范围被限制在已经设置了过期时间的键值对上也正因为此即使缓存没有写满这些数据如果过期了也会被删除比如我们使用命令对一批键值对设置了过期时间后无论是这些键值对的过期时间是快到了还是的内存使用量达到了阈值都会进一步按照这四种策略的具体筛选规则进行淘汰在筛选时会针对设置了过期时间的键值对根据过期时间的先后进行删除越早过期的越先被删除就像它的名称一样在设置了过期时间的键值对中进行随机删除会使用算法筛选设置了过期时间的键值对会使用算法选择设置了过期时间的键值对相对于这四种策略淘汰的是设置了过期时间的数据这三种淘汰策略的备选淘汰数据范围就扩大到了所有键值对无论这些键值对是否设置了过期时间它们筛选数据进行淘汰的规则是策略从所有键值对中随机选择并删除数据策略使用算法在所有数据中进行筛选策略使用算法在所有数据中进行筛选这也就是说如果一个键值对被删除策略选中了即使它的过期时间还没到也需要被删除当然如果它的过期时间到了但未被策略选中同样也会被删除的算法算法的全称是从名字上就可以看出这是按照最近最少使用的原则来筛选数据最不常用的数据会被筛选出来而最近频繁使用的数据会留在缓存中那具体是怎么筛选的呢会把所有的数据组织成一个链表链表的头和尾分别表示端和端分别代表最近最常使用的数据和最近最不常用的数据我们现在有数据如果数据和被先后访问它们都会从现有的链表位置移到端而链表中在它们之前的数据则相应地往后移一位因为算法选择删除数据时都是从端开始所以把刚刚被访问的数据移到端就可以让它们尽可能地留在缓存中如果有一个新数据要被写入缓存但此时已经没有缓存空间了也就是链表没有空余位置了那么算法做两件事数据是刚被访问的所以它会被放到端算法把端的数据从缓存中删除相应的链表中就没有数据的记录了其实算法背后的想法非常朴素它认为刚刚被访问的数据肯定还会被再次访问所以就把它放在端长久不访问的数据肯定就不会再被访问了所以就让它逐渐后移到端在缓存满时就优先删除它不过算法在实际实现时需要用链表管理所有的缓存数据这会带来额外的空间开销而且当有数据被访问时需要在链表上把该数据移动到端如果有大量数据被访问就会带来很多链表移动操作会很耗时进而会降低缓存性能所以在中算法被做了简化以减轻数据淘汰对缓存性能的影响默认会记录每个数据的最近一次访问的时间戳由键值对数据结构中的字段记录然后在决定淘汰的数据时第一次会随机选出个数据把它们作为一个候选集合接下来会比较这个数据的字段把字段值最小的数据从缓存中淘汰出去当需要再次淘汰数据时需要挑选数据进入第一次淘汰时创建的候选集合这儿的挑选标准是能进入候选集合的数据的字段值必须小于候选集合中最小的值当有新数据进入候选数据集后如果候选数据集中的数据个数达到了就把候选数据集中字段值最小的数据淘汰出去这样一来缓存不用为所有的数据维护一个大链表也不用在每次数据访问时都移动链表项提升了缓存的性能的淘汰策略的选择建议优先使用策略这样可以充分利用这一经典缓存算法的优势把最近最常访问的数据留在缓存中提升应用的访问性能如果你的业务数据中有明显的冷热数据区分我建议你使用策略如果业务应用中的数据访问频率相差不大没有明显的冷热数据区分建议使用策略随机选择淘汰的数据就行如果你的业务中有置顶的需求比如置顶新闻置顶视频那么可以使用策略同时不给这些置顶数据设置过期时间这样一来这些需要置顶的数据一直不会被删除什么是热问题如何解决热问题热问题是指在中某个或某些特定的键被频繁访问导致对这些键的操作成为系统的性能瓶颈热问题可能会导致负载过高响应时间延长甚至造成系统崩溃为了解决热问题可以采取以下一些策略增加缓存容量扩大内存容量可以提高缓存命中率减少对热的访问次数从而缓解热问题可以考虑升级服务器或增加集群节点来增加内存容量分片将热均匀地分散到多个实例中每个实例处理一部分热的请求这样可以降低单个实例的负载压力提系统整体的吞吐量缓存预热在系统启动或流量低峰期提前加载热的数据到缓存中使得这些热的数据在实际访问时已经存在于缓存中减少对后端存储的访问数据分片对于热所对的数据量较大的情况可以考虑将数据进行分片存储将不同片段的数据存放在不同的键上从而减轻单个键的访问压力缓存降级对于某些热可以考虑将其缓存时间设置较短或者不缓存直接访问后端存储这样可以避免热对缓存系统的过度压力同时确保其他非热正常缓存使用集群通过搭建集群将热分散到多个节点上实现负载均衡和高可用性提高系统的整体性能和稳定性综合考虑具体业务场景和系统需求可以采取不同的策略或组合使用来解决热问题什么是大问题如何解决大问题是指在数据库中存储了过大的数据结构如大型列表哈希集合等导致内存占用过高影响性能的情况这可能会导致以下问题内存占用过高大占用了大量的内存空间导致其他数据无法被缓存从而影响的性能和响应速度数据加载时间延长由于大的加载和传输需要较长时间会导致读取和写入操作的延迟持久化问题在进行数据持久化如快照日志时大会增加持久化的时间和磁盘空间占用解决大问题的方法包括数据分片将大数据拆分成多个小数据分别存储在不同的中例如将一个大型哈希表分成多个小型哈希表使用分布式存储将大数据存储在分布式数据库中如或其他分布式存储系统合理选择数据结构根据实际需求选择合适的数据结构避免在单个中存储过大的数据数据压缩对于可以压缩的数据使用提供的数据压缩功能减小存储占用使用大分析工具提供了一些工具可以用于识别和处理大问题例如内存分析工具和命令定期清理周期性地检查数据库发现并处理大例如将大转移至其他存储系统合理设置过期时间对于不再需要的数据设置适当的过期时间让可以自动淘汰这些数据综合使用这些方法可以有效地解决大问题提高的性能和稳定性什么是缓存击穿缓存穿透缓存雪崩击穿缓存穿透和缓存雪崩都是与缓存相关的常见问题现象缓存击穿是指缓存中没有但数据库中有的数据一般是缓存时间到期这时由于并发用户特别多同时读缓存没读到数据又同时去数据库去取数据引起数据库压力瞬间增大造成过大压力解决方案设置热点数据永远不过期加互斥锁缓存穿透是指缓存和数据库中都没有的数据导致所有的请求都落到数据库上造成数据库短时间内承受大量请求而崩掉解决方案固定值攻击缓存一个空对象或者任意一个数据比如缓存随机值攻击接口层增加校验如用户鉴权校验做基础校验的直接拦截全量缓存将数据库的数据全部缓存到缓存将数据库全部数据的要具有唯一性全部缓存到布隆过滤器在项目一启动的时将数据库中所有的数据全部缓存到布隆过滤器本地或者分布式版本都可以根据服务的实例数决定中布隆过滤器一个足够大的一个一定不存在的数据会被这个拦截掉从而避免了对底层存储系统的查询压力自带的缓存雪崩是指缓存同一时间大面积的失效所以后面的请求都会落到数据库上造成数据库短时间内承受大量请求而崩掉解决方案缓存数据的过期时间设置随机防止同一时间大量数据过期现象发生给每一个缓存数据增加相应的缓存标记记录缓存是否失效如果缓存标记失效则更新数据缓存搭建高可用集群架构比如哨兵模式业务服务层面使用降级熔断限流手段注意这是三套具体的解决方案落地什么情况下会出现数据库和缓存不一致的问题数据库和缓存不一致的问题可能会出现在以下几种情况下写操作未更新缓存当应用程序对数据库进行写操作时如果没有及时更新相关的缓存数据就会导致数据库和缓存的数据不一致这通常发生在缓存和数据库的更新操作没有保持同步的情况下缓存过期和数据库更新当缓存中的数据过期时如果此时有大量的并发请求查询该数据而后端数据库正在进行更新操作就有可能导致缓存中的旧数据被读取与数据库中的新数据不一致多级缓存不一致在多级缓存架构中不同层级的缓存可能会出现数据不一致的情况例如一级缓存本地缓存和二级缓存分布式缓存之间的数据同步问题如果没有及时更新或失效旧的缓存数据就会导致数据库和缓存数据的不一致数据库异常和缓存更新失败当数据库发生异常或写操作失败时如果缓存更新操作也失败了就会导致数据库和缓存的数据不一致例如数据库写操作成功了但是缓存更新失败导致缓存中的数据是旧的或不一致的最终一句话不管哪种方式在高并发读读读写情况下都可能导致数据库数据和缓存数据不一致问题如何解决和数据库的一致性问题解决方案一双写模式在写数据库的同时去将数据写入在无并发的情况下重试即可在并发的情况下可能会数据不一致慢的线程旧数据居然把新数据覆盖这是暂时性的脏数据问题但是在数据稳定缓存过期以后又能得到最新的正确数据双写模式下的数据实时更新当更新数据库的时候同步更新缓存并且加锁优点数据一致性强缺点有耦合性并且写和读的操作成为了串行牺牲了高并发读数据的能力适用环境适用于数据一致性要求高的场景比如银行业务证券交易业务双写模式下的数据准实时更新当更新数据库的同时异步去更新缓存比如更新数据库后把一条消息发送到中去优点修改数据库数据的业务和修改缓存的数据业务完成了解耦缺点有较短的延迟并且可能无法保证最终一致性需要补偿机制保证消息百分百投递适用环境对数据实时性要求不严格的场景比如对一些商品热度值的统计解决方案二失效模式先删缓存在写数据库或者在写数据库的同时去删除缓存在并发的情况下也可能出现不一致会有两种情况情况一先删除缓存再更新数据库若异常情况删除缓存成功了更新数据库失败了无并发的情况下重试修改数据库操作即可解决保证最终的一致性有并发的情况下给缓存数据设置过期时间但是在缓存数据失效的这一段时间内缓存数据仍然和数据库数据是不一致的因此还可以在写完数据库之后主动在来删除缓存双删思想主动删除缓存缓存的被动失效情况二先更新数据库值再删除缓存值若异常情况更新数据库成功了删除缓存失败了无并发的情况下重试修删除缓存操作即可解决保证最终的一致性有并发读的情况下可以不用管因为等待缓存删除完成下一次在来读的时候发现缓存缺失就会将数据最新的数据读到并同步到缓存中在等待删除缓存期间也会有一段时间不一致有并发读写的情况下仍然会出现缓存数据和数据库数据不一致问题因此还需要通过缓存数据的失效机制主动删缓存的机制来保证缓存数据和数据库数据的一致性在删除缓存和缓存数据失效期间仍然会出现不一致解决方案三缓存失效机制基于缓存本身的失效机制具体实现方式为设置缓存失效时间如果有缓存就从缓存中取数据如果没缓存就从数据库中取数据并且重新设置缓存优点实现方式简单与业务完美解耦不影响正常业务缺点在缓存失效期间仍然会出现不一致所以有数据一致性有延迟适用环境能接受一定的数据延迟场景比如对商品的热度值统计解决方案四延时双删主要是针对失效模式情况一先删除缓存再更新数据库在线程更新完数据库值以后我们可以让它先一小段时间再进行一次缓存删除操作之所以要加上的这段时间就是为了让线程能够先从数据库读取数据再把缺失的数据写入缓存然后线程再进行删除所以线程的时间就需要大于线程读取数据再写入缓存的时间这个时间怎么确定呢建议你在业务程序运行的时候统计下线程读数据和写缓存的操作时间以此为基础来进行估算情况二先更新数据库值再删除缓存值如果线程删除了数据库中的值但还没来得及删除缓存值线程就开始读取数据了那么此时线程查询缓存时发现缓存命中就会直接从缓存中读取旧值不过在这种情况下如果其他线程并发读缓存的请求不多那么就不会有很多请求读取到旧值而且线程一般也会很快删除缓存值这样一来其他线程再次读取时就会发生缓存缺失进而从数据库中读取最新值所以这种情况对业务的影响较小解决方案五引入中间件类似于的主从数据同步大致的流程如下读热数据基本都在写增删改都是操作更新数据的数据操作来更新到第一次将数据全部写入到中做一个全量备份接这中的作为增量进行实时更新当读取到后分析利用消息对列推送到各个实例中去对进行更新优点类似于的主从模式因为的主从也是通过订阅日志来实现的数据一致性缺点引入中间件代码开发难度较大成本较高如何实现延迟消息本身并不提供延迟消息的特性但可以通过一些技术手段实现延迟消息的功能以下是一种基于的延迟消息实现方法使用有序集合将延迟消息的到期时间作为有序集合的分数消息内容作为有序集合的成员将延迟消息添加到有序集合中将延迟消息按照到期时间添加到有序集合中定时检查有序集合通过定时任务或者后台线程定期检查有序集合中的消息找到到期的消息处理到期的消息当有序集合中的消息到期时将其从有序集合中移除并进行相应的处理可以将消息发送到消息队列或者进行其他业务操作通过以上方法可以实现延迟消息的功能需要注意的是在实现过程中需要考虑以下几点需要保证定时检查的频率以确保消息能够及时被处理可以使用多个有序集合来支持不同延迟时间的消息将消息按照不同的延迟时间分组存储可以使用的发布订阅功能将到期的消息发送到其他服务进行处理需要考虑消息的可靠性如处理失败时的重试机制等需要根据具体的业务需求和系统架构选择合适的延迟消息方案以上方法只是其中一种常见的实现方式之一除了做缓存还能用来干什么除了做缓存还可以用来实现以下几个功能数据存储支持多种数据结构如字符串哈希列表集合有序集合等可以将作为主要的数据存储用于存储和查询数据例如可以将用户会话信息配置信息计数器等数据存储在中消息队列的发布订阅功能可以用作简单的消息队列系统发布者将消息发布到指定的频道订阅者可以监听频道并接收消息这种方式可以用于实现异步任务事件驱动等场景分布式锁利用的原子性操作和过期时间特性可以实现分布式锁通过在中存储一个特定键值对作为锁标识可以实现对共享资源的互斥访问避免并发问题计数器的自增和自减操作可以用于实现计数器功能可以用于统计网站的访问量点赞数量订单数量等场景地理位置应用理位置数据结构可以存储和查询地理位置信息如地理坐标半径查询等可以用于实现附近的人地理位置搜索等功能实时排行榜利用的有序集合数据结构可以实现实时的排行榜功能可以根据特定的规则将成员和分数存储在有序集合中并根据分数进行排名分布式缓存可以作为分布式缓存系统通过集群和主从复制等机制提供高可用性和高性能的缓存服务总之不仅仅是一个缓存系统还可以用于实现多种功能和应用场景包括数据存储消息队列分布式锁计数器地理位置应用实时排行榜等如何用实现分布式锁使用的命令可以实现简单的分布式锁下面是使用实现分布式锁的基本步骤获取当一个进程或线程需要获取锁时使用命令尝试设置一个指定的键作为锁的标识如果返回值为表示成功获取锁如果返回值为表示锁已被其他进程或线程持有获取锁失败释放锁当持有锁的进程或线程需要释放锁时使用命令删除对应的键通过以上步骤可以实现简单的分布式锁需要注意的是分布式锁的实现需要考虑以下几点锁的粒度需要明确锁的范围即确定需要保护的共享资源可以使用不同的锁标识来实现对不同资源的锁定锁的超时为了避免死锁可以为获取到的锁设置一个超时时间避免锁被长时间持有锁的可重入性如果同一个进程或线程多次获取同一个锁需要确保锁的可重入性即能够正常释放锁锁的可靠性需要考虑锁的可靠性如处理锁的异常情况网络分区等锁的误删线程加入的锁可能被线程删除锁的原子性加锁设置过期时间和判断删除锁需要根据具体的业务场景和系统需求综合考虑以上因素来设计和实现分布式锁什么是他解决了什么问题是一个用于解决分布式系统中的锁竞争问题的算法它是由作者提出的一种算法旨在解决的分布式锁在网络分区等异常情况下可能出现的问题在分布式系统中使用的命令来实现锁时可能会遇到网络分区例如主节点与从节点之间的网络断开等故障情况导致锁的可靠性受到影响算法通过引入多个独立的实例使得锁在多个实例上创建增加了锁的可靠性算法的基本思想是使用多个实例理论上最少需要个以上来创建锁在获取锁时需要在多个实例上尝试获取锁并使用大部分实例都获取到锁才算成功这样即使其中一个实例出现故障或网络分区仍然可以保证锁的可用性算法的步骤如下获取当前时间戳及随机字符串在多个实例上依次尝试获取锁使用命令设置锁标识设置过期时间为锁的超时时间一般为较短的时间避免长时间锁定统计成功获取到锁的实例数如果成功获取到锁的实例数大于等于大部分实例数例如大于等于为总实例数则认为获取锁成功如果获取锁失败则需要在已获取锁的实例上释放锁算法并不是用所有场景的通用解决方案仍然存在一些局限性例如对于时钟不同步的实例网络延迟等情况可能会导致锁的可靠性下降因此在使用算法时需要根据具体的业务需求和系统环境进行评估和测试如何用实现分布式锁是一个基的分布式对象和服务的框架它提供了一种简单且可靠的方式来实现分布式锁下面是使用实现分布式锁的基本步骤引入依赖在项目的构建文件中引入的依赖例如的文件中添加以下依赖创建客户端实例化客户端并配置连接信息例如的地址和密码等获取分布式锁通过的方法获取一个分布式锁对象加锁和解锁使用方法加锁并在锁定的代码块执行完毕后使用方法解锁执行需要加锁的代码块通过以上步骤就可以使用实现分布式锁还提供了一些其他的功能如可重入锁公平锁读写锁等可以根据具体的需求选择合适的锁类型此外还支持异步执行和监听锁状态的功能提供了更多灵活和便捷的方法来操作分布式锁需要注意的是在实现分布式锁时仍然需要考虑锁的超时时间可重入性互斥性和可靠性等因素以确保分布式锁的正确和性能优化热门领域概念了解云计算什么是云计算云计算是一种基于互联网的计算模式它通过将计算资源例如服务器存储数据库网络软件等提供给用户使用户能够根据需要获得灵活的可扩展的计算能力而无需购买配置和维护物理硬件设备云计算的主要特点包括按需服务用户可以根据实际需求随时获得所需的计算资源无需事先购买或预留资源共享多个用户可以共享同一组物理资源通过虚拟化技术将资源划分为多个虚拟实例从而提高资源利用率可扩展性用户可以根据业务需求快速扩展或缩减计算资源以适应不断变化的工作负载灵活性用户可以选择不同类型的计算资源和服务根据实际需求进行配置从而满足不同的应用场景付费模式通常采用按使用量付费的方式用户只需支付实际使用的资源量避免了高昂的起始投资和维护成本自动化管理云计算平台通常提供自动化管理功能例如自动扩展备份监控等减少了用户的管理工作量云计算可以分为三种主要模式基础设施即服务平台即服务和软件即服务提供基本的计算存储和网络基础设施用户可以在此基础上构建和管理自己的应用程序和环境在的基础上还提供了开发和部署应用程序所需的平台和工具使开发者能够专注于应用逻辑而无需担心底层基础设施提供完整的应用程序作为服务用户可以直接通过互联网访问和使用无需安装和维护总之云计算通过提供灵活高效经济的计算资源为个人和企业提供了一种更便捷的方式来开发部署和管理应用程序和服务什么是公有云私有云混合云公有云私有云和混合云是云计算中常用的部署模式它们在云资源的管理和访问权限上有所不同公有云公有云是由第三方提供商建立和管理的云基础设施供多个用户共享这些提供商会提供各种计算存储网络和应用服务用户可以根据需要按需购买和使用公有云通常具有高度的可扩展性和灵活性适用于各种规模的企业和个人用户私有云私有云是一种基于云计算概念的部署模式但它是为单个组织或企业独立建立和管理的私有云通常在组织内部的数据中心中部署提供更高的安全性和定制性因为云资源仅供特定组织使用这种模式适用于有特殊安全和合规需求的企业或者需要更多控制权的情况混合云混合云是将公有云和私有云结合起来的部署模式在混合云中组织可以将某些工作负载部署在公有云上同时将敏感数据或合规性要求较高的工作负载部署在私有云中这种模式可以充分利用公有云的弹性和灵活性同时满足特定的安全和隐私需求综上所述公有云私有云和混合云是根据云资源的共享性质和管理控制程度来划分的不同云计算部署模式组织可以根据自身需求选择适合的模式什么是和是云计算中常见的服务模型用于描述不同层次的云服务提供方式基础设施即服务在这种模型下提供的是基础的计算资源如虚拟机存储网络等用户可以在这些基础设施上构建管理和运行自己的应用程序拥有更高的灵活性和控制权但用户需要自己管理操作系统中间件应用等层面的内容平台即服务提供了比更高层次的抽象除了基础设施还提供了开发部署和管理应用程序所需的平台和工具用户可以将注意力集中在应用程序的开发和部署上而不必过多关注底层的基础设施管理通常包括运行时环境开发工具数据库管理等软件即服务在这种模型下提供的是完整的应用程序作为服务用户无需关心底层的基础设施平台只需通过网络浏览器或其他客户端访问应用程序常见的包括电子邮件服务在线办公套件客户关系管理系统等这些服务模型从底层基础设施到应用程序层面提供了不同层次的抽象和服务使用户能够根据需求选择合适的模型来构建部署和使用应用程序什么是无服务器是一种计算模型旨在让开发者能够更专注于编写代码和功能而无需显式管理服务器和基础设施虽然名称中带有无服务器但实际上并不意味着没有服务器存在而是指开发者无需关心服务器的管理细节在传统的应用部署中开发人员需要管理服务器的配置扩展性负载平衡等方面而在模型中这些管理任务由云服务提供商来处理开发者只需上传包含其代码的函数或服务然后在需要时触发这些函数云提供商会根据请求自动分配和释放资源使开发者只需为实际使用的计算资源付费模型的特点包括按需付费开发者只需为实际使用的计算资源付费避免了不必要的资源浪费自动扩展云服务提供商会根据请求的负载自动扩展资源确保应用程序始终具有所需的性能事件驱动架构通常是基于事件驱动的函数会在特定事件发生时被触发执行如请求数据库更改等无状态每个函数执行都是独立的不会保留状态这使得函数更易于扩展和管理常见的服务包括等开发者可以使用这些服务来部署单个函数或更复杂的应用程序逻辑而无需直接管理底层的服务器基础设施场景题场景题理解如果你的业务量突然提升倍你会怎么做面对业务量突然提升倍的情况我会采取以下一些措施来应对性能优化首先我会仔细分析系统瓶颈寻找性能瓶颈并进行优化这可能涉及到代码优化数据库查询优化缓存的使用等确保系统能够高效地处理更多的请求扩容如果性能优化无法满足需求我会考虑增加系统的计算资源比如扩展服务器集群使用负载均衡器来分担流量这可以提高系统的容量和并发处理能力缓存策略我会审查系统中的缓存策略确保数据可以合理地被缓存从而减轻数据库的压力使用适当的缓存方案可以提高响应速度异步处理对于一些可以延迟处理的任务我会考虑将其改为异步处理这可以减少实时请求的压力提高系统的稳定性限流和排队为了防止系统过载我会引入限流机制控制每秒处理的请求数量对于超出处理能力的请求可以引入排队机制以避免系统崩溃数据库优化数据库通常是系统的瓶颈之一我会考虑数据库分库分表索引优化等措施以提高数据库的承载能力和查询效率监控和警报增加监控和警报系统实时监测系统的性能指标如内存网络等一旦达到预定阈值系统可以自动触发警报让维护团队可以及时采取措施紧急计划虽然我们希望一切都能顺利处理但是突发情况仍然可能发生我会制定紧急计划包括回滚方案灾难恢复策略等以应对意外情况总之面对业务量大幅提升的情况综合考虑系统的性能资源架构等各个方面采取一系列综合措施以确保系统能够稳定高效地应对挑战让你设计一个订单号生成服务该怎么做设计一个订单号生成服务需要考虑多个方面包括唯一性可扩展性性能和易用性以下是一个基本的设计方案唯一性保证订单号必须保证唯一性可以通过以下几种方式来实现自增序列使用数据库自增序列来生成订单号每次插入一条订单记录时自增序列会自动递增生成唯一的订单号通用唯一标识符使用作为订单号几乎可以保证全局唯一性但是相对较长可能影响存储和索引效率分布式生成如果系统需要处理大量订单可以考虑分布式生成订单号以避免单点性能瓶颈一种方法是引入分布式生成器如算法保证在多个节点上生成唯一的编码信息在订单号中可以包含一些有意义的信息比如订单类型时间戳等以便快速识别订单属性缓存机制为了提高性能可以引入缓存机制将最近生成的订单号缓存起来避免频繁地访问数据库或分布式生成器生成算法设计一个高效的生成算法以避免长时间的等待或计算开销算法应该在保证唯一性的前提下尽量减小订单号的长度高可用性考虑实现多个订单号生成服务的实例以提供高可用性可以使用负载均衡来分配请求同时保证各实例之间的订单号唯一性错误处理考虑异常情况如数据库连接断开或分布式生成器不可用设计适当的错误处理机制确保系统的稳定性订单号格式定义订单号的格式使其易于阅读和管理可以使用前缀日期随机数等方式日志记录记录每个生成的订单号包括生成时间相关信息等以便后续追踪和排查问题最终的设计取决于具体业务需求和技术栈在设计过程中需要综合考虑系统的性能可靠性和易用性确保订单号生成服务能够满足预期需求订单到期关闭如何实现订单到期关闭是许多业务系统中常见的功能之一通常涉及到以下步骤和考虑订单到期时间设定首先你需要在订单的数据模型中添加一个到期时间字段这个字段可以是订单创建时间加上一个固定的时限或者根据业务需求进行动态设置定期检查设计一个定期的任务或者后台服务以便在每个订单的到期时间到来时进行检查这可以使用定时任务消息队列等机制来实现关闭过期订单当检查到订单的到期时间已经过了当前时间系统应该将这些订单标记为已过期或者关闭状态具体的操作可能包括更改订单状态发送通知给相关人员或者执行其他业务逻辑通知用户对于用户及时地通知订单的过期状态是很重要的你可以通过电子邮件短信推送通知等方式通知用户让他们知道订单已经关闭或者过期清理和归档过期订单可能占用数据库空间或者内存资源根据实际需求你可以考虑定期清理或者归档这些已关闭或者过期的订单以释放资源日志和监控在订单到期关闭的过程中记录相关的日志信息以便后续排查问题同时建立监控机制及时发现和处理因订单到期引起的异常情况恢复和处理有时候订单过期后用户可能会要求恢复订单或者进行一些特殊处理你需要设计相应的流程和界面来支持这些需求以便管理员或客户支持人员可以进行干预测试和优化在实际运行中不断测试和优化订单到期关闭的流程这可以帮助你发现潜在的问题并进行改进确保系统在各种情况下都能正确地处理订单的到期关闭综上所述订单到期关闭涉及到多个环节需要在系统设计中充分考虑这些步骤并根据业务需求和技术架构进行适当的实现如何设计一个购物车功能设计购物车功能涉及到使用户能够方便地添加管理和结算所选商品以及提供良好的用户体验以下是一个基本的购物车功能设计概述添加商品在商品页面上为每个商品提供一个添加到购物车按钮当用户点击该按钮时将选定的商品添加到购物车购物车图标和总览在页面的适当位置显示一个购物车图标以及显示当前购物车中的商品数量和总金额的总览区域这样用户可以随时查看购物车的状态购物车页面提供一个单独的购物车页面用户可以通过点击购物车图标或导航链接访问在购物车页面上列出已添加的商品数量单价和小计还可以提供移除商品更改数量以及清空购物车的选项商品数量和编辑在购物车中为每个商品提供一个数量字段允许用户手动输入或使用增减按钮调整数量还可以提供一个编辑选项以便用户查看和修改商品的属性如颜色尺寸等小计和总计对于每个商品显示小计金额数量单价在购物车底部显示所有商品的总金额以及可能的运费和税费等附加费用计算出订单的总金额结算流程提供一个去结算或结算按钮引导用户进入结算流程在结算页面用户可以选择收货地址支付方式等并进行最终确认登录和账户关联如果你的网站或应用需要用户登录可以将购物车与用户账户关联使用户可以在不同设备间同步购物车内容保存购物车状态在用户离开网站或关闭浏览器后保留购物车中的商品使用户下次访问时可以继续购物库存管理在用户添加商品到购物车时需要实时检查库存以避免售罄情况如果商品在用户结算前被其他用户购买应及时更新购物车信息提供推荐在购物车页面或结算页面可以显示相关的商品推荐鼓励用户继续浏览和购买其他商品移动端适配确保购物车功能在移动设备上的用户体验良好可以考虑采用折叠式购物车侧边栏等方式安全和隐私确保用户的购物车信息安全并遵循相关的隐私政策和法规最终的设计应该根据你的业务需求用户画像和技术架构进行调整和定制购物车功能不仅是一个交易过程还能影响用户对你产品的整体印象所以提供一个流畅直观且安全的购物车体验至关重要每天次登录请求机器如何做调优对于每天万次的登录请求针对核的机器进行调优可以有以下一些建议内存分配确保为分配足够的内存但不要超过机器可用内存的合理范围可以使用启动参数和来设置初始堆内存和最大堆内存例如垃圾回收策略选择合适的垃圾回收策略以平衡吞吐量和延迟对于高吞吐量的场景可以考虑使用垃圾回收器启用可以通过参数并发线程数调整并发线程数以充分利用多核对于核的机器可以考虑设置参数内存回收周期根据应用的特点和负载调整垃圾回收的时间间隔可以使用参数和来控制新生代的内存分配百分比堆区域划分垃圾回收器允许将堆内存划分为多个区域可以通过参数来调整每个区域的大小以优化垃圾回收的效率元空间设置对于大量的类加载和反射操作需要适当调整元空间的大小可以使用参数和日志和监控开启的日志和监控可以帮助你实时了解的运行状态和性能指标以便及时调整参数可以使用参数来输出垃圾回收日志硬件资源利用考虑将登录请求分散到多个实例上以充分利用硬件资源降低单个实例的负载以上建议仅供参考实际的调优策略需要根据你的应用特点负载情况和机器配置进行调整建议在调优过程中逐步引入变更并使用监控工具来评估性能的变化不用分布式锁如何防止用户重复点击不使用分布式锁时你仍然可以采取其他方法来防止用户重复点击以下是一些可能的替代方案前端防御在前端实现一些防御措施例如在用户点击后禁用相应的按钮或链接直到后台处理完成这可以通过来实现虽然前端控制不是绝对可靠的方法用户可能通过浏览器开发工具绕过但可以防止大部分普通用户的重复点击请求队列在后端服务中实现一个请求队列当用户发起请求时将请求放入队列中进行处理并且确保同一个用户的相同请求在队列中只有一个这可以通过用户标识如用户来实现在请求处理完成之前拒绝队列中同一用户的相同请求记录请求时间对于每个用户记录其最近一次请求的时间戳当用户发起请求时先检查距离上一次请求的时间间隔是否足够如果不够则拒绝处理这可以防止用户在短时间内连续点击限制请求频率设置一个全局的请求频率限制确保同一个用户在一段时间内只能发起有限次数的请求这可以通过限制地址用户标识等来实现使用数据库锁尽管不如分布式锁高效但你可以在数据库中使用行级锁或者悲观锁来防止并发修改从而防止用户重复点击需要注意的是这些方法并不能完全消除用户重复点击的可能性因为客户端和网络环境复杂多变总会存在一些特殊情况综合使用多种方法可以提高防御效果最终的选择应该基于你的应用需求可用技术以及风险承受能力来确定让你设计一个秒杀系统你会考虑哪些问题当设计一个秒杀系统时需要考虑以下一些关键问题高并发处理秒杀活动通常会引起巨大的并发请求系统需要能够处理大量用户同时发起的请求确保系统稳定运行不会因为负载过重而崩溃数据一致性在秒杀过程中多个用户可能会竞争有限的资源如商品库存需要确保并发操作不会导致数据不一致或超卖现象库存管理如何高效地管理商品库存避免超卖和卖完的情况同时能够迅速更新库存状态是一个关键问题限流和防刷需要采取措施限制用户频繁的请求以防止恶意刷单和重复点击队列和异步处理使用队列技术可以将请求缓冲起来然后异步处理以减轻数据库和服务器压力提高系统性能缓存策略合理使用缓存可以减轻数据库压力提高数据访问速度但需要注意缓存的更新策略以确保数据的实时性和准确性分布式架构考虑采用分布式架构将不同功能模块分散在不同的服务器上以提高系统的扩展性和可用性安全性和防护防止恶意攻击注入等安全问题保障用户数据安全和系统稳定用户体验设计友好的用户界面和流程确保用户能够顺利参与秒杀活动同时避免因为系统问题造成用户体验不佳监控和调优设置合适的监控系统实时监测系统运行状态性能指标和异常情况及时进行调优和处理故障容灾和备份考虑系统的容灾和备份方案确保系统在故障时能够快速恢复并保障数据不会丢失业务流程设计定义清晰的秒杀流程包括商品展示下单支付发货等环节确保整个流程顺畅运行这些只是设计秒杀系统时需要考虑的一些关键问题具体方案需要根据业务需求和技术栈来定制如果让你实现消息队列会考虑哪些问题如果要设计和实现一个消息队列需要考虑以下问题消息传递方式确定消息是通过什么方式进行传递常见的方式包括点对点传递和发布订阅模式消息持久化考虑消息是否需要被持久化以防止消息在系统故障时丢失可以选择将消息存储在数据库文件系统或者其他持久化存储中消息顺序性某些场景下消息的顺序性非常重要设计时需要确保相同的消息顺序被保留并且不同消息之间的顺序不会混淆消息传递的可靠性系统应该能够保证消息的可靠传递即使在网络不稳定或者其他异常情况下也能够确保消息的送达消息重试机制考虑在消息处理失败时的重试机制以确保消息最终被成功处理避免因为一次失败就丢失了重要信息消息格式与序列化确定消息的格式以及如何进行序列化和反序列化以便消息能够在不同组件之间进行传递和解析消息过滤与路由考虑如何根据消息的内容对消息进行过滤和路由确保消息被正确地发送到目标处理程序性能和吞吐量根据预期的负载和性能需求选择合适的消息队列实现并进行性能测试和优化扩展性系统应该能够方便地进行横向扩展以适应日益增长的消息量监控和管理设计合适的监控系统实时监测消息队列的状态和性能指标同时提供管理工具来管理消息的发送消费和处理安全性考虑消息队列的安全性防止未经授权的访问和消息篡改集成和支持考虑消息队列与其他系统的集成提供适当的和文档以便开发人员能够方便地使用消息队列这些是设计和实现消息队列时需要考虑的一些关键问题具体方案会根据实际需求和技术选择进行定制库存扣减如何避免超卖和少卖针对库存扣减避免超卖和少卖的问题你可以结合消息队列的设计和实现来解决以下是一个基本的思路库存管理系统首先你需要一个库存管理系统来跟踪每个商品的库存数量这个系统应该能够及时更新库存数量记录每次的库存变动消息队列应用对于库存扣减操作你可以将其转化为消息队列的任务每次有订单需要扣减库存时将一个消息发送到消息队列消费者服务在消息队列中你可以有一个或多个消费者服务负责实际的库存扣减操作这样做的好处是你可以控制同时进行库存扣减的并发量从而避免超卖和少卖的问题事务处理在库存扣减操作中确保消息队列中的每个消息都被消费者服务原子性地处理这可以使用消息队列的事务特性或者结合数据库事务来实现如果扣减库存和订单的状态更新在不同系统中进行确保这两个操作要么同时成功要么同时失败以保持数据的一致性库存预检查在处理消息之前消费者服务可以进行库存预检查检查库存是否足够以执行扣减操作如果库存不足可以将消息退回到队列或者将其标记为失败库存补偿机制如果发生了少卖的情况你可以设计一个库存补偿机制例如定期检查库存和实际销售情况如果有差异则自动增加库存以补偿监控和报警针对库存扣减过程设计监控系统来实时监测消息队列状态和性能同时监控库存的变化设置报警机制如果出现异常情况比如消息积压库存异常等及时通知相关人员进行处理安全性和集成确保消息队列的安全性只允许授权的操作访问消息队列同时提供集成接口和文档让开发人员能够方便地使用消息队列进行库存扣减总之通过合理的消息队列设计事务处理预检查和监控机制你可以有效地避免库存的超卖和少卖问题保证系统的稳定和一致性具体的实现会根据你所选择的消息队列系统和技术栈有所不同如何用实现朋友圈点赞功能当使用来实现朋友圈点赞功能时可以按照以下步骤进行设计和实现存储点赞关系使用的数据结构例如来存储点赞关系对于每篇朋友圈动态可以使用一个来存储点赞的用户每个用户只能在中出现一次确保每个用户只能点赞一次点赞计数可以使用的来存储点赞计数信息每篇朋友圈动态都对应一个其中成员是用户分数是点赞的时间戳这样可以实现点赞时间的排序并且可以通过的长度来获取点赞的总数取消点赞如果用户取消点赞只需从点赞关系的中移除相应的用户同时从中删除对应的成员查看点赞状态通过判断用户是否在点赞关系的中可以确定用户是否已经点赞获取点赞列表如果需要展示最近点赞的用户列表可以通过获取中的成员用户和分数时间戳然后根据时间戳排序得到最近点赞的用户列表以下是一个简化的示例代码点赞将用户及当前时间戳加入有序集合取消点赞将用户从有序集合中移除查看点赞列表请注意这只是一个基本的示例实际应用中可能需要考虑更多的异常情况和优化同时为了保证数据的一致性和安全性可能需要进一步的设计和措施的实现排行榜实现分数相同按照时间顺序排序怎么做要在的有序集合中实现分数相同情况下按时间顺序排序可以借助一些技巧和额外的字段来实现以下是一种可能的实现方法假设你要存储帖子的排行榜分数表示点赞数时间戳表示点赞时间添加帖子点赞时使用命令将帖子的作为成员点赞时间戳作为分数添加到中当多个用户点赞同一帖子时由于分数是点赞时间戳相同分数的成员会按照字典序排序查询排行榜时使用命令按分数时间戳倒序获取排行榜列表这将返回按时间倒序的点赞列表如果多个用户的点赞时间戳相同它们会按照插入顺序排列符合你的要求需要注意的是由于的是基于分数排序的所以我们将时间戳作为分数存储这样就能够实现相同分数情况下的时间顺序排序在实际应用中你可能还需要考虑数据清理数据同步等问题以确保系统的稳定性和一致性如何实现查找附近的人功能实现查找附近的人功能通常涉及到地理位置数据和距离计算在这里我将为你提供一个基本的思路和步骤使用的地理位置数据结构来实现这个功能在中地理位置数据可以使用有序集合的功能来存储和查询每个成员都有一个经度和纬度的坐标可以通过这些坐标来计算距离并进行查询以下是一个基本的实现步骤存储用户地理位置信息对于每个用户使用命令将其地理位置信息存储在一个有序集合中键可以是类似于的标识查询附近的人使用命令来查询附近的人你可以指定一个中心点的坐标比如当前用户的位置然后指定一个距离范围命令会返回在这个范围内的用户列表这将返回一组用户及其与中心点的距离筛选结果你可以根据需要对查询结果进行进一步的筛选和处理比如根据距离排序限制结果数量等请注意这只是一个简单的实现示例实际情况可能会更加复杂在实际应用中你还需要考虑数据的更新清理错误处理以及性能优化等问题另外随着技术的不断发展可能会有其他更高级的方法和工具来实现类似的功能例如使用地理信息数据库或专门的地理位置服务消息队列使用拉模式好还是推模式好为什么消息队列可以采用拉模式或推模式来处理消息传递选择哪种模式取决于你的应用场景和需求拉模式在拉模式中消费者主动从消息队列中拉取消息消费者决定何时获取消息以及获取多少消息这种模式的优势在于消费者可以控制消息的处理速率以适应自己的处理能力拉模式适用于以下情况消费者处理能力不稳定如果消费者的处理速度波动较大拉模式可以避免消息积压问题消费者需要灵活控制如果消费者希望在特定时间获取消息或者根据自身逻辑选择性地获取特定消息拉模式更适合推模式在推模式中消息队列将消息主动推送给消费者消费者只需提供一个回调函数或处理方法消息队列会在有消息到达时调用该回调函数推模式的优势在于即时性适用于以下情况低延迟要求如果你需要实现低延迟的消息传递推模式可以更快地将消息发送给消费者实时通知如果你需要及时通知消费者进行某些操作推模式可以满足这种即时性的需求选择拉模式还是推模式取决于你的应用需求和场景拉模式适用于需要灵活控制消息获取的场景消费者处理能力波动较大的情况对消息处理的顺序有严格要求推模式适用于需要低延迟和实时性的场景需要及时通知和即时反馈的情况消费者处理能力稳定不容易被消息积压需要注意的是有些消息队列系统甚至允许在同一个应用中同时使用拉模式和推模式以满足不同消息处理需求在实际应用中根据业务需求来选择适合的模式是非常重要的如果让你实现一个会考虑用哪些技术解决哪些问题要实现类似于这样的分布式服务框架需要考虑多个方面的技术和问题以下是一些可能的考虑和解决方案服务注册与发现使用类似或等分布式系统作为服务注册中心用于服务提供者注册自己的服务并供消费者发现可用的服务远程通信协议选择合适的远程通信协议如协议可以使用基于的协议如或者等序列化与反序列化选用高效的序列化方式如或者以减少网络传输时的数据体积负载均衡实现负载均衡策略确保服务消费者能够均匀地调用不同的服务提供者可考虑使用轮询随机权重等策略容错与熔断实现容错机制处理服务提供者不可用或者网络故障等情况可以引入熔断器如以避免级联故障并发与线程池考虑到服务提供者可能会被大量请求同时调用需要使用线程池等技术来管理并发请求避免资源耗尽超时与重试实现超时机制避免长时间等待同时可以引入重试机制确保在某些网络瞬时问题导致的失败情况下能够进行自动重试跨语言支持如果需要支持不同编程语言间的服务调用可以使用通用的接口定义语言来定义接口再根据不同语言生成对应的客户端和服务端代码监控与治理引入监控和管理工具如等用于实时监控服务的调用情况性能指标等并能进行故障排查和性能优化安全与认证考虑数据传输的安全性可以使用加密通信另外还可以引入认证和授权机制确保只有合法的服务消费者能够调用服务分布式事务如果需要支持分布式事务可以考虑使用分布式事务管理器如或等机制扩展性构建可扩展的架构允许根据业务需求动态添加新的服务提供者同时保持系统的稳定性最终的选择会依赖于具体的业务需求技术栈以及团队的经验和技术偏好以上列举的技术和问题只是其中的一部分实际实现时还需要根据具体情况进行详细的设计和调优单分区单消费者实例如何提高吞吐量针对单分区单消费者实例如何提高吞吐量的问题以下是一些可能的优化策略增加分区数的吞吐量与分区数相关增加分区数可以充分利用多个消费者并行处理消息但需要注意分区数的调整可能需要对生产者和消费者的代码进行适当的修改调整消费者数尽可能多地创建消费者实例每个实例处理一个分区这样可以最大化地利用和网络资源提高并行处理能力调整消费者的并行处理能力在消费者代码中确保消息的处理逻辑能够高效运行可以考虑使用多线程或异步处理以提高并行处理的能力提高消费者端的配置调整消费者的配置参数例如等以优化拉取消息的性能使用批量处理将多条消息批量处理而不是逐条处理可以减少网络开销和处理开销从而提高吞吐量调整服务器端的配置调整服务器端的配置参数例如等以适应高吞吐量的需求考虑使用压缩如果网络带宽有限可以考虑在生产者端启用消息压缩以减少传输的数据量使用更快的硬件和网络升级硬件和网络设备以提供更大的计算和通信能力监测性能和瓶颈使用监控工具监测集群消费者和生产者的性能指标找出可能的瓶颈并针对性地进行优化版本更新确保使用了较新的版本因为每个版本都可能对性能进行了改进和优化需要注意的是上述优化策略的效果取决于具体的使用情境和环境因此建议在应用这些策略之前先进行充分的测试和评估以确保其对吞吐量的提升效果符合预期同时持续的性能监测和调优也是保持高吞吐量的关键一个订单在超时关闭但在也支付成功了怎么办在这种情况下处理订单超时和支付成功的冲突可能需要以下步骤确认订单状态首先需要确保订单状态的准确性检查订单数据库或系统确认订单在是否确实被标记为超时关闭同时也确认支付是否在之前成功完成审查日志查看相关系统的日志记录尤其是订单处理和支付流程的日志这可以帮助你了解事件发生的确切时间以及可能的问题恢复订单状态如果支付在之前成功完成并且订单被错误地标记为超时关闭你可能需要通过后台操作或管理员权限来恢复订单状态将订单状态重新设置为已支付或待处理以便继续订单的后续流程通知用户如果出现了这种情况及时通知相关用户向用户解释发生的问题向其确认订单的实际状态并道歉为带来的不便系统改进这种问题可能暴露出订单处理系统或支付系统的一些潜在问题你需要分析为什么会出现这种错误以避免类似问题再次发生可能需要对系统流程数据库事务处理和事件触发机制进行审查和改进测试与验证在进行任何更改之前务必进行全面的测试模拟类似的情况确保订单状态和支付能够正确处理以避免再次出现类似的问题总之处理订单超时和支付成功冲突需要综合考虑数据的准确性用户体验和系统流程及时纠正错误通知用户并采取措施防止未来类似问题的发生是关键步骤一个支付单多个渠道同时支付成功了怎么办如果出现一个支付单被多个渠道同时支付成功的情况需要采取以下步骤来解决这个问题确认支付状态首先确保支付状态的准确性检查系统记录确认是否真的存在多个渠道同时支付成功的情况或者是系统记录出现了错误数据处理如果确认多个渠道确实同时支付成功需要对支付数据进行处理通常情况下系统会自动处理相同订单的多次支付将多余的支付金额退还给用户确保这个过程是自动化的以减少用户的不便用户通知如果需要进行退款或其他处理务必及时通知用户解释情况并说明后续的操作步骤例如退款的时间和方式系统改进类似于上面提到的订单超时问题这种情况可能也暴露出支付系统的潜在问题分析为什么会出现这种冲突检查支付系统的流程和事件处理机制确保类似问题不会再次发生测试与验证在进行任何系统改进之前进行全面的测试和验证模拟多个渠道同时支付的情况确保系统能够正确处理并防止类似问题的再次发生监测与预防建立监测机制定期检查支付系统的表现以及是否出现类似的问题预防措施可能包括对并发支付的处理机制进行优化确保数据的一致性和准确性总之解决一个支付单多渠道同时支付成功的问题需要综合考虑数据处理用户通知系统改进以及未来预防措施确保用户的权益不受损害同时优化系统以避免类似问题的再次发生如何解决消息重复消费重复下单等问题要解决消息重复消费重复下单等问题通常可以采取以下一些方法消息去重在消息队列中你可以实现消息的唯一标识当消费者从队列中获取消息时首先检查该消息的唯一标识是否已经被处理过如果已经处理过就可以跳过该消息避免重复消费幂等性设计在系统中引入幂等性概念即使同一个操作被多次执行结果也保持一致对于下单操作可以设计成幂等操作确保多次重复请求只会产生一次订单可以通过为每个订单生成一个唯一的订单号使用订单号来识别订单的唯一性事务控制在涉及到多个操作的情况下使用事务来确保操作的原子性例如在创建订单的同时扣减库存可以将这两个操作放在同一个事务中如果其中一个操作失败整个事务会回滚保证数据的一致性幂等性校验在处理请求之前可以先查询系统的状态判断该请求是否已经被处理过如果已经处理过可以直接返回之前的结果避免重复操作定时任务清理可以设置定时任务来清理过期的数据如未支付的订单或已经处理过的消息这样可以确保系统中不会长期存在无效数据消息确认机制在消息队列中可以使用消息确认机制来确保消息被成功消费只有在消费者确认后消息才会被标记为已消费避免消息在处理失败时被重复消费日志记录与审计记录每个操作的日志并建立审计机制这样可以追踪操作的历史及时发现异常情况并进行处理综合使用上述方法可以有效地解决消息重复消费重复下单等问题保证系统的稳定性和数据的一致性你是如何进行调优的进行调优时通常可以采取以下步骤来优化查询性能和提高数据库操作效率分析查询执行计划使用数据库管理工具或命令获取查询的执行计划执行计划将显示查询的执行路径包括表的连接方式索引的使用情况等通过分析执行计划可以确定查询中存在的性能瓶颈索引优化确保表中的字段上存在适当的索引以加快数据检索速度然而不宜过度索引因为索引也会增加数据写入的开销使用复合索引来覆盖多个查询条件避免使用过多的单列索引合理编写语句编写高效的查询语句是调优的关键避免使用而是只选择需要的列合理使用操作避免多余的连接使用子查询时确保子查询返回的数据量有限缓存数据对于频繁查询的数据可以使用缓存技术如将结果缓存起来减少对数据库的频繁访问分区表和分表如果数据表过大可以考虑使用分区表或分表的方式将数据分散存储提高查询效率定期维护和统计定期进行数据库的维护工作如重新生成索引更新统计信息等以保持数据库的优化状态避免全表扫描尽量避免全表扫描操作可以通过适当的索引条件过滤等方式来减少数据量提高查询速度优化数据库参数配置根据数据库类型调整数据库的参数配置如缓冲池大小连接数等以适应实际业务负载使用合适的存储引擎根据具体的应用需求选择合适的数据库存储引擎如等使用慢查询分析工具数据库管理工具提供了慢查询分析功能可以帮助你识别哪些查询语句执行较慢从而有针对性地进行优化综合考虑上述方法根据具体的业务需求和数据库特点可以进行有效的调优提升数据库性能和查询效率不使用和如何设计一个线程安全的单例不使用和来设计一个线程安全的单例可以考虑使用一些其他方式例如基于静态内部类的单例模式或者使用双重检查锁定等技术来实现以下是两种常见的线程安全单例实现方法静态内部类单例模式这种方法利用了类加载的特性保证了只有在第一次使用单例的时候才会加载内部类从而实现懒加载同时又保证线程安全私有构造方法是项乐观锁技术当多个线程尝试使用同时更新同一个变量时只有其中一个线程能更新变量的值而其它线程都失败失败的线程并不会被挂起而是被告知这次竞争中失败并可以再次尝试实现单例的方式如下用的好处在于不需要使用传统的锁机制来保证线程安全是一种基于忙等待的算法依赖底层硬件的实现相对于锁它没有线程切换和阻塞的额外消耗可以支持较大的并行度的一个重要缺点在于如果忙等待一直执行不成功一直在死循环中会对造成较大的执行开销另外如果个线程同时执行到的时候会有大量对象创建很可能导致内存溢出索引失效的问题是如何排查的有那些种情况索引失效是数据库性能调优中常见的问题之一通常会导致查询变慢甚至超时排查索引失效问题需要仔细分析查询语句表结构索引设计以及数据库统计信息等因素以下是一些可能导致索引失效的情况以及排查方法查询条件与索引不匹配如果查询条件中使用的列与索引的列不匹配数据库可能无法使用索引来加速查询检查查询条件是否涵盖了索引的前缀或者是否需要重新设计索引以更好地匹配查询索引选择性低索引的选择性是指索引中不同值的数量与总行数的比率如果索引选择性很低意味着索引中的值重复较多数据库可能会选择全表扫描而不是使用索引可以通过查看统计信息比如索引的基数值的数量来评估索引的选择性数据分布不均匀如果索引列的数据分布不均匀一些值的数量过多而另一些值很少那么在查询时可能会导致部分索引失效考虑重新设计索引或者优化查询条件以解决这个问题数据类型不匹配查询条件中使用的数据类型与索引列的数据类型不匹配时索引可能无法被使用确保查询条件的数据类型与索引列的数据类型相同隐式类型转换如果在查询条件中进行了隐式类型转换可能会导致索引失效数据库无法在索引上执行隐式类型转换因此尽量避免在查询条件中进行类型转换条件当查询条件中使用了多个条件时如果这些条件涉及不同的列可能会导致索引失效尽量将条件转换为使用或其他方式以避免索引失效函数操作在查询条件中使用函数操作比如对索引列进行函数操作可能会导致索引失效数据库无法使用索引来加速函数操作因此尽量避免在索引列上进行函数操作统计信息过期数据库使用统计信息来选择查询计划如果统计信息过期或者不准确可能会导致数据库做出错误的优化决策定期更新统计信息以确保数据库选择正确的查询计划排查索引失效问题时可以通过数据库的执行计划索引状态统计信息以及查询语句的优化来识别问题所在并采取相应的措施进行优化亿个号限制内存如何去重对于在限制为内存的情况下对亿个号进行去重可以考虑使用外部排序的方法来处理外部排序是一种适用于数据量大于内存可容纳的情况的排序方法它将数据分成小块每次处理一块数据最终将这些有序的小块合并成一个有序的完整数据集下面是一个基本的思路你可以根据实际情况进行调整分割数据块将亿个号按照一定的规则划分成多个小块每个小块的大小要适合你的内存限制比如可以选择将每个小块限制在左右对每个小块进行内部排序将每个小块加载到内存中使用一种高效的排序算法比如快速排序归并排序等对每个小块进行排序逐一合并小块在内存中维护一个小块合并的队列每次从每个小块中取出一个最小的号将其写入输出文件并从对应的小块中取出下一个号填充进队列重复这个步骤直到所有小块都被处理完毕重复合并过程如果输出文件仍然过大可以将输出文件继续分割成更小的块然后进行多次合并直到得到一个完整的有序数据集需要注意的是外部排序过程需要额外的磁盘空间来存储临时数据块和合并结果同时选择合适的小块大小和合并策略也会影响整体性能在实际操作中你可能需要使用一些编程语言或工具来实现外部排序比如使用的库来维护小块合并的队列以及逐步处理数据块由于数据量庞大整个过程可能会比较耗时所以耐心和合理的资源规划都是必要的另外如果你的情况允许也可以考虑使用分布式计算框架将数据分布到多台机器上进行处理以加快去重的速度说一说多级缓存是如何应用的多级缓存是计算机体系结构中常用的一种优化技术旨在加速数据访问并提高系统性能它利用不同容量和速度的存储设备来缓存数据以降低访问主存储器的频率从而减少访问延迟多级缓存通常分为三级分别是和缓存它们按照从最近到最远的访问距离进行层次划分以下是多级缓存的应用方式缓存位于内部速度最快但容量最小通常用于存储当前正在执行的指令和相关数据由于其位置接近核心可以迅速提供数据适用于对访问延迟敏感的任务缓存位于核心外部容量较大速度较快它承担了缓存无法容纳的数据并提供更大的缓存空间缓存可以通过一些高效的算法来预测数据的使用模式从而更好地满足的数据需求缓存位于芯片上但多个核心共享容量更大速度相对较慢缓存通常用于存储多个核心之间共享的数据以及更大规模的工作负载它有助于降低多核处理器之间的数据传输延迟多级缓存的应用方式包括以下几个方面缓存命中和缓存失效当需要访问数据时会首先在最小的缓存中查找如果找到则为缓存命中否则会在更大的或缓存中查找如果所有缓存层都没有找到需要的数据就会发生缓存失效需要从主存储器中加载数据缓存替换算法当缓存空间不足时会采用一些算法来决定替换哪些数据常见的替换算法包括最近最少使用最不常用等以及一些变种数据预取缓存控制器可能会根据访问模式预测未来可能需要的数据并提前将其加载到缓存中以提高命中率总之多级缓存通过提供不同层次的缓存存储有效地提高了计算机系统的数据访问速度和整体性能在设计中需要权衡容量速度和成本等因素以达到最佳的性能提升效果从树的角度分析为什么单表万要考虑分表从树的角度分析为什么单表万要考虑分表涉及数据库性能和查询效率的考虑树是一种常用于数据库索引的数据结构用于加速数据的插入更新和查询操作当单表数据量逐渐增大可能会出现以下几个问题从而考虑分表查询性能下降随着数据量的增加树的高度可能会增加导致查询操作的时间复杂度增加较深的树意味着需要更多的磁盘操作从而影响查询的效率索引维护成本增加当数据量大时树的维护成本也会增加插入更新和删除操作可能需要频繁地调整树结构这可能导致性能下降内存压力增大单表数据量增加会增加树节点的数量从而需要更多的内存来存储索引如果内存无法容纳足够多的索引节点就可能导致频繁的磁盘访问进而影响查询性能数据备份和恢复困难单表数据量庞大时数据备份和恢复变得更加复杂和耗时分表可以使数据管理和维护变得更加灵活有助于更好地进行备份和恢复操作因此当单表数据量达到万这个数量级时可能需要考虑分表来缓解上述问题通过将数据拆分为多个表每个表的数据量减少树的高度降低查询性能和索引维护成本可以得到改善同时分表还有助于更好地利用内存简化数据管理和提高数据备份恢复的效率然而分表也需要综合考虑业务需求查询模式等因素避免出现过度分表导致的查询性能下降或连接操作复杂的问题为什么不用跳表为什么不用树和都是流行的数据库或数据存储引擎它们在设计和实现上有各自的考虑和特点这也影响了它们在数据结构选择方面的决策不使用跳表的原因是数据库的默认存储引擎它采用了树作为主要的索引数据结构树在数据库领域广泛应用因为它对范围查询排序等操作有着良好的支持适合于数据库的多样化查询需求相比之下跳表在某些方面可能表现出色但在数据库场景下它的性能和特点可能不如树跳表适用于有序数据的搜索它可以在某些情况下实现快速查找但相对于树跳表的实现和维护可能更为复杂而且跳表对于范围查询的性能可能不如树此外树在磁盘存储和内存管理方面也有优势这在数据库中尤为重要不使用树的原因是一个内存存储数据库它主要用于缓存和快速数据存取在这样的场景下树不一定是最优选择树的设计和优势更多地与磁盘存储相关而的数据通常完全存储在内存中磁盘访问并不是主要瓶颈使用了一种称为跳跃表的数据结构来实现有序集合跳跃表在内存中的实现相对简单适用于的高速内存存储和快速读写操作它在某些情况下可以提供良好的性能尤其是在不需要像树那样复杂的平衡和维护操作时总之和在选择数据结构上考虑了各自的使用场景性能需求以及存储特点虽然跳表在某些情况下可能表现得很好但在数据库和内存存储引擎的背景下树和跳跃表分别被选择以满足不同的性能和设计要求线上接口如果响应很慢如何去排查定位问题呢线上接口响应缓慢可能涉及多个因素需要逐步排查和定位问题以下是一些可能的步骤和方法监控和日志分析检查系统监控指标例如使用率内存占用网络流量等以确定是否存在资源瓶颈分析应用程序日志和性能监控数据查找是否有异常或错误信息以及哪些操作或查询导致响应变慢数据库查询性能如果接口涉及数据库查询检查数据库性能使用数据库性能分析工具如查询计划来评估查询的性能查看是否存在慢查询确保数据库索引的正确性和有效性代码审查仔细审查接口的代码检查是否有低效或冗余的操作特别关注循环递归不必要的操作等确保代码中没有阻塞死锁或竞争条件网络延迟检查网络延迟特别是在分布式系统中使用网络分析工具查看是否存在网络瓶颈或连接问题缓存使用如果应用程序使用缓存如确保缓存的正确使用检查缓存是否过期是否频繁失效以及缓存命中率等第三方服务如果接口依赖于其他第三方服务检查这些服务是否正常运行可能的问题包括第三方服务响应变慢不稳定或不可用性能测试进行性能测试模拟高负载情况观察接口在负载下的表现这可以帮助确定是否存在扩展性问题代码优化和重构基于分析结果进行代码优化或重构可能需要改进算法减少数据库查询次数使用缓存等手段来提高性能横向扩展如果系统瓶颈主要来自资源限制考虑横向扩展增加服务器数量以分担负载监控和警报设置实时监控和警报机制以便在出现性能问题时能够及时采取行动总之排查和解决线上接口响应缓慢的问题需要综合考虑多个因素并逐步进行分析和改进及时的监控和持续的性能优化是保障系统稳定和高效运行的关键怎么做数据对账当需要进行数据对账时通常涉及比较两个或多个数据源之间的差异以确保数据的一致性和准确性以下是一般的数据对账步骤确定对账目标确定要对账的数据源和目标例如两个不同系统之间的数据两个时间点的数据等数据提取从每个数据源中提取需要对账的数据这可能涉及数据库查询调用文件导出等数据转换将提取的数据转换成统一的格式以便于后续比较确保数据字段名数据类型等匹配数据比较对转换后的数据进行比较比较的方法可以包括逐行比对使用哈希函数生成数据指纹后进行比对等差异分析如果数据源之间存在差异进行详细的差异分析确定哪些数据不一致并找出造成差异的原因差异解决根据差异分析结果采取适当的措施来解决数据差异可能需要更新数据纠正错误等记录和报告记录对账过程的结果包括哪些数据一致哪些数据不一致以及差异的原因和解决方案这可以作为后续审计和改进的依据自动化对账可选对于频繁进行的对账任务可以考虑建立自动化对账流程这可以减少人工错误和时间成本定期重复对账数据对账不是一次性任务应该定期重复执行以确保数据一致性的持续性值得注意的是数据对账可能会因应用场景和数据的不同而有所不同上述步骤提供了一个通用的框架可以根据实际情况进行调整和扩展此外对于大规模数据可能需要考虑性能和效率问题选择合适的工具和算法来进行对账操作千万级大表如何做数据清理清理千万级大表的数据可以采取以下几种方法分区表如果你的表支持分区可以根据时间范围将数据分散到不同的分区中这样当需要清理数据时只需删除相应的分区即可而不需要扫描整个表这种方法可以提高清理数据的效率分批删除将要删除的数据分成多个较小的批次进行删除而不是一次性删除整个表的数据可以使用和子句来限制每个批次的删除数量并使用循环或脚本来逐批删除数据这样可以减少对数据库的负载避免一次性删除大量数据时的性能问题使用索引确保表中的字段上有适当的索引索引可以加快删除操作的速度特别是在大表中根据删除条件创建适当的索引这样数据库可以更快地定位到要删除的数据优化删除语句使用语句删除数据时可以优化语句的性能避免在删除操作中使用不必要的子查询或复杂的条件这可能会导致查询执行时间过长确保删除语句的条件能够充分利用索引以提高删除操作的效率数据归档如果你需要保留历史数据但不经常查询可以考虑将旧数据归档到其他表或存储介质中例如归档表归档文件或其他数据库这样可以减小主表的大小提高查询性能定期维护定期进行数据库维护操作例如优化表结构重建索引收集统计信息等这些操作可以提高数据库的性能并减少数据清理的需要在进行数据清理操作之前请务必备份数据库以防止意外数据丢失此外根据你的具体情况可能需要结合其他方法或工具来进行数据清理例如使用分布式数据库数据分片或数据迁移等最好在测试环境中进行测试和验证以确保清理操作的安全性和效果为什么用树用树和使用不同的树结构树和树作为其索引数据结构这是基于它们的设计目标和特点而做出的选择树树是一种多路搜索树用于在数据库中实现索引它的主要特点是每个节点可以有多个子节点适用于磁盘存储的数据库系统树的特点包括平衡性树保持了树的平衡性使得在查找操作时最坏情况下的搜索时间仍然是这对于磁盘存储系统来说非常重要因为它减少了磁盘次数提高了查询效率节点包含键值和数据树的每个节点既包含键值也包含数据这意味着在叶子节点上即可找到实际的数据记录而不需要再次跳转到另一个位置使用树作为索引数据结构因为它被设计为一种灵活的文档数据库支持丰富的数据模型树适用于在磁盘上存储大量数据适合这种需要处理大量文档的情况然而在某些情况下可能也使用树的变体比如以提高查询性能树树是树的变体在树的基础上进行了一些优化它的主要特点是内部节点不存储数据而只存储键值实际的数据都存储在叶子节点上树的特点包括更适合范围查询由于树的数据都存储在叶子节点上并且叶子节点之间使用指针连接因此范围查询更高效这对于数据库系统非常重要因为范围查询是数据库常见的查询类型之一适合磁盘存储树的叶子节点形成了一个有序链表便于顺序访问这对于磁盘存储来说非常高效因为可以减少磁盘的随机操作使用树作为其索引数据结构这是因为通常处理关系型数据树适合在关系型数据库中进行范围查询和有序遍历此外树的结构使得它更适合支持聚簇索引将数据和索引存储在一起这在关系型数据库中非常常见综上所述选择树作为索引结构以适应其关系型数据模型和范围查询的需求而则选择树以适应其面向文档的数据模型虽然两者的索引结构不同但都旨在提供高效的数据访问和查询性能高并发的积分系统在数据库增加积分怎么实现在高并发的积分系统中实现数据库增加积分的方式可以采用以下几种方法乐观锁使用乐观锁机制可以在不加锁的情况下实现并发操作在数据库表中添加一个版本号或时间戳字段每次更新积分时检查版本号如果版本号匹配则更新积分并增加版本号如果版本号不匹配则表示其他并发操作已修改数据需要进行冲突处理悲观锁使用悲观锁可以在操作期间锁定数据防止其他并发操作对数据进行修改在更新积分之前对相关的数据行或表进行加锁确保只有一个线程可以修改数据但悲观锁可能会导致性能下降因为其他线程需要等待锁的释放分布式锁使用分布式锁可以实现多个应用程序实例之间的协调确保只有一个实例可以执行增加积分的操作可以使用基于数据库的分布式锁如在中使用行级锁或表级锁或者使用分布式锁服务如的分布式锁队列将增加积分的请求放入队列中由单个线程或多个工作线程按顺序处理请求这样可以避免并发冲突并提供顺序处理的能力常见的队列系统包括等事务在数据库操作中使用事务可以确保操作的原子性和一致性将增加积分的操作放在一个事务中当多个并发操作同时进行时数据库会自动处理并发冲突保证数据的正确性无论采用哪种方法都需要根据具体的业务需求和系统架构来选择合适的方案同时还需要考虑数据库的性能和扩展性以及并发操作可能带来的性能瓶颈和资源竞争在设计和实现时可以结合使用以上的方法以满足高并发积分系统的需求热点数据更新会带来哪些问题当中的热点数据频繁更新时可能会导致以下问题锁竞争多个并发事务同时更新同一行或同一组数据时会引发锁竞争如果没有合适的锁策略和并发控制机制可能会导致事务等待和阻塞降低系统的并发性能死锁如果多个事务之间存在循环依赖的更新操作并且没有正确处理锁的顺序可能会导致死锁的发生死锁会导致事务无法继续执行需要通过超时或者手动干预来解决数据不一致当热点数据频繁更新时如果没有正确的事务隔离级别和并发控制策略可能会导致数据不一致的问题例如读取到未提交的数据或者读取到部分更新的数据性能瓶颈频繁的热点数据更新可能会导致数据库性能瓶颈特别是在高并发的情况下数据库需要处理大量的更新操作可能会增加和磁盘的负载导致响应时间延长和吞吐量下降数据库压力热点数据更新可能会导致数据库的存储空间增加和磁盘的负载增加如果没有及时的数据库优化和调整可能会导致数据库性能下降和存储资源的消耗为了解决这些问题可以采取以下措施优化查询和更新语句通过合理的索引设计查询优化和更新批量处理等方式减少对热点数据的频繁更新操作降低锁竞争和数据库负载选择合适的事务隔离级别根据业务需求和数据一致性要求选择合适的事务隔离级别避免读取到脏数据或不可重复读的问题使用合理的并发控制策略通过锁机制乐观锁或悲观锁等方式控制并发事务对热点数据的访问和更新避免锁竞争和死锁的发生数据库优化和扩展通过合理的数据库配置硬件升级分库分表读写分离等方式提升数据库的性能和扩展性以应对高并发的热点数据更新综上所述热点数据的频繁更新可能会带来锁竞争死锁数据不一致性能瓶颈和数据库压力等问题通过合理的数据库设计并发控制和优化策略可以有效地解决这些问题并提升系统的性能和可靠性和外部机构交互如何防止被外部服务不可用而拖垮与外部机构交互时为了防止外部服务不可用导致自身服务受到影响可以采取以下一些策略超时设置和重试机制在与外部服务进行交互时设置合适的超时时间如果在预定时间内未收到响应可以触发重试机制多次尝试与外部服务建立连接但是要注意避免无限制的重试以免对自身系统造成过多负担限流和熔断使用限流和熔断机制来控制与外部服务的交互频率当外部服务不可用或响应时间过长时可以暂时停止或降低对该服务的请求防止过多的请求集中到不可用的服务上从而拖垮自身服务服务降级在外部服务不可用的情况下可以采取服务降级策略提供一个备用的功能或响应确保自身系统的基本功能仍然可用例如展示缓存数据提供默认值等异步处理将与外部服务的交互设计为异步操作不会直接阻塞主要流程将请求放入消息队列或异步任务中从而减少直接依赖外部服务的耦合多地域部署如果外部服务支持多地域部署可以选择将自身服务部署在多个地理位置以减少单一地区外部服务不可用对整体系统的影响监控和报警实施有效的监控和报警系统及时检测外部服务的可用性和性能一旦发现问题可以迅速采取措施如切换到备用服务通知相关人员等合理的容错策略在代码中实施合理的容错策略例如处理异常情况优雅降级和自动恢复机制确保系统在外部服务不稳定时也能正常运行预案和应急准备制定与外部服务不可用时的应急预案明确责任人员和处理流程以便在发生问题时能够迅速应对合作伙伴选择在选择外部服务供应商时要考虑其稳定性和可靠性选择有良好服务记录和强大基础设施的供应商减少不可用风险总之通过合理的设计和应对策略可以最大程度地降低外部服务不可用对自身服务造成的影响保障系统的稳定性和可用性里有数据中只存的数据如何保证中的数据都是热点数据要确保中存储的数据都是热点数据可以考虑以下策略缓存策略选择选择合适的缓存策略如最近最少使用最不经常使用或基于时间过期等这些策略可以根据数据的访问频率和使用情况来淘汰冷数据确保中存储的数据都是热点数据数据预热在系统启动或负载低峰期可以通过预热的方式将热点数据加载到中预热可以通过批量读取数据库中的热点数据并将其存储到中以提前缓存热点数据减少后续访问时的延迟数据更新时同步更新当中的数据发生更新时及时将更新的数据同步到中可以通过在应用程序中实现数据更新的逻辑保持和中数据的一致性这样可以确保中存储的数据是最新的热点数据定期更新数据定期更新中的数据将最新的热点数据加载到中可以通过定时任务或者触发器来实现定期更新以保证中的数据与中的热点数据保持同步监控和自动清理监控中的数据访问情况和存储空间占用情况根据实际情况自动清理不再是热点数据的缓存以释放存储空间并保持中存储的数据都是热点数据合理设置过期时间对于不再频繁访问的数据可以设置较短的过期时间以便在一段时间内没有被访问时自动从中淘汰这样可以确保中存储的数据都是当前较为活跃的热点数据通过以上策略可以有效地保证中存储的数据都是热点数据提高数据访问的性能和响应速度但需要根据具体业务场景和数据访问模式来选择和调整策略以达到最佳效果项目上线问题排查工作经验飙高问题排查过程当遇到实时飙高的问题时可以按照以下步骤进行排查确认问题现象首先需要明确实时飙高的具体表现和受影响的方面例如是使用率飙高还是网络延迟增加是某个特定服务的响应时间增长还是整个系统的吞吐量下降等监测系统指标使用系统监控工具或性能分析工具来收集系统的关键指标这些指标包括使用率内存使用率网络吞吐量磁盘等通过监测这些指标可以了解系统在实时飙高期间的状态查看日志和错误信息检查系统日志和错误日志寻找与实时飙高相关的任何错误或异常信息这些信息可能会提供有关问题原因的线索例如异常堆栈跟踪错误消息等分析负载和请求模式研究实时飙高期间的负载和请求模式检查是否有异常的请求频率或请求量增加是否有突发的负载压力以及是否有特定的请求类型或资源导致了飙高问题检查系统配置和资源限制检查系统的配置和资源限制包括服务器硬件配置操作系统参数应用程序配置等确保系统的配置与实际需求相匹配并且没有过度限制资源的设置排查代码问题检查应用程序的代码寻找可能导致实时飙高的问题这可能包括低效的算法循环中的死循环资源泄漏线程阻塞等使用性能分析工具来确定代码中的瓶颈和性能热点排查第三方服务如果系统依赖于第三方服务检查这些服务是否出现故障或延迟可能需要联系第三方服务提供商来了解是否存在与实时飙高相关的问题进行压力测试和负载测试使用压力测试工具模拟实际负载并观察系统在高负载情况下的表现这有助于确定系统的性能极限和可能的瓶颈逐步回退变更如果实时飙高问题与最近的系统变更相关可以逐步回退这些变更以确定是否有特定的变更引起了飙高问题寻求专家帮助如果以上步骤无法解决问题可以寻求专家的帮助例如系统管理员开发人员或性能工程师他们可能有更深入的知识和经验来解决实时飙高问题通过以上排查步骤可以逐步缩小问题范围找到实时飙高问题的根本原因并采取相应的措施来解决问题飙高问题排查过程排查飙高问题的过程可以分为以下步骤确认问题首先要明确飙高的问题是否真实存在可以通过监控工具系统日志等途径来验证使用率是否异常升高确定影响范围确定是整个系统的使用率升高还是特定进程应用程序导致的这可以通过查看系统级别的监控数据和进程级别的监控数据来判断分析进程和应用程序如果是特定进程或应用程序导致的飙高就需要分析这些进程应用程序的行为可以使用工具如等来查看进程的使用率内存占用线程数等信息查看系统资源使用情况检查内存磁盘网络等资源的使用情况因为资源竞争也可能导致飙高特别注意内存的使用情况过多的交换可能会导致使用率升高检查日志查看系统日志应用程序日志以及可能的错误日志以便找到任何异常或错误信息有时候某些异常事件可能导致使用率升高性能分析工具使用性能分析工具如等来跟踪进程的系统调用函数调用和事件以帮助确定是哪些操作导致了飙高检查代码如果问题与特定应用程序相关可能需要检查应用程序的代码查找可能的瓶颈或死循环代码中可能存在的资源竞争不合理的循环等问题都可能导致使用率升高硬件问题排除考虑硬件故障可能导致的问题如散热不足硬件损坏等这些问题也可能导致飙高升级和优化如果确定问题是由于某个应用程序或组件的性能问题导致的可以尝试升级软件版本应用性能优化技巧或者调整配置参数来缓解问题监控和预防一旦问题解决建议设置持续的监控来跟踪系统和应用程序的性能以便及时发现并预防类似问题的再次发生在排查飙高问题时关键是收集足够的信息从多个角度进行分析以便确定问题的根本原因根据不同的情况可能需要结合多种方法和工具来解决问题数据库连接池满排查过程数据库连接池满的报警报错信息如下应用报警应用数据库连接池满陆续出现等数据库异常报警当数据库连接池满时可以按照以下步骤进行排查确认连接池满的迹象监控数据库连接池的指标例如连接数活动连接数空闲连接数等如果这些指标达到连接池的最大限制说明连接池已满查看数据库连接池配置检查连接池的配置参数包括最大连接数最小空闲连接数连接超时时间等确保这些参数的设置合理并且能够满足系统的需求分析连接池使用情况查看连接池的使用情况包括连接的获取和释放过程记录下频繁获取连接的代码路径和时间点以及连接释放是否及时这有助于找出连接泄露或者连接使用不当的问题检查数据库连接资源检查数据库服务器的连接资源情况查看数据库服务器的最大连接数设置以及当前连接数是否接近最大限制如果数据库服务器也存在连接数限制可以考虑增加最大连接数的配置检查数据库性能检查数据库服务器的性能指标例如使用率内存使用率磁盘等如果数据库服务器的性能达到瓶颈可能导致连接池满优化数据库性能可以缓解连接池满的问题检查数据库操作检查应用程序中的数据库操作包括查询语句事务处理等优化数据库操作可以减少连接的占用时间从而减少连接池的压力检查应用程序并发访问检查应用程序的并发访问情况特别是在高峰时段如果并发访问量过大可能会导致连接池满可以考虑增加连接池的大小或者优化应用程序的并发处理能力查看日志和异常信息检查应用程序的日志和异常信息查找是否有连接池相关的错误或异常这些信息可以帮助定位连接池满的原因性能分析工具使用性能分析工具来跟踪应用程序的数据库连接使用情况例如连接的创建销毁使用时间等这有助于找出连接使用不当或者泄露的问题优化和调整根据排查结果进行相应的优化和调整可以调整连接池的配置参数增加连接池的大小优化数据库操作或者增加数据库服务器的性能通过以上步骤的排查可以找出数据库连接池满的原因并采取相应的措施来解决问题重要的是收集足够的信息从多个角度进行分析以便确定问题的根本原因数据库被打满排查过程开发经常收到数据库的报警提示我们的数据库的有异常飙高的情况通过命令发现经常把打满了排查数据库被打满的问题通常需要一系列步骤来定位和解决下面是一般的排查过程确认使用率高首先确保数据库服务器的使用率确实是高的可以使用操作系统提供的工具如等或数据库性能监控工具来验证检查数据库负载查看数据库的当前负载情况包括并发连接数查询数量事务处理数等这可以帮助确认是否存在异常的数据库活动分析长时间运行的查询使用数据库性能分析工具如语句查询计划查看是否有复杂低效率的查询在运行优化这些查询可以减轻负担检查索引使用情况确保数据库表使用了适当的索引没有或者不正确使用索引可能导致查询变得非常耗时进而导致使用率上升检查锁等待情况死锁或者大量的锁等待会导致被打满确保应用程序和数据库使用了合适的锁策略避免锁争用检查硬件资源确保数据库服务器的硬件资源足够包括核数内存磁盘等不足的硬件资源可能导致过载检查并发连接数大量并发连接可能导致过载评估并优化应用程序连接池的设置确保不会有过多的闲置连接监控长时间运行的进程使用操作系统的工具来监控是否有长时间运行的进程占用了过多的资源这可能是恶意进程或者其他异常情况审查系统日志检查数据库服务器的系统日志查找异常错误消息这有助于找到可能的问题根源考虑数据库优化如果排查过程中发现一些持续存在的性能问题考虑数据库的整体优化包括配置优化硬件升级数据库版本升级等性能测试在排查过程结束后可以进行性能测试验证优化措施是否有效是否解决了被打满的问题总之排查数据库被打满的过程需要综合考虑多个因素从数据库层面应用程序层面和硬件层面分析最终找到根本原因并采取相应措施来解决问题问题排查过程问题是指系统内存不足无法满足进程的内存需求导致进程被操作系统终止的情况下面是一般的问题排查过程确认错误首先确认系统中是否发生了错误可以查看系统日志如或者使用命令来检查系统日志中是否有相关的错误信息检查内存使用情况使用系统监控工具如或者命令如来检查系统的内存使用情况确认系统内存是否已经耗尽检查进程内存使用确定哪个进程使用了大量的内存可以使用命令按内存使用排序或者使用命令查看进程的内存占用情况检查内存泄漏如果发现某个进程占用了大量内存但是没有明显的原因可能存在内存泄漏的情况可以使用内存分析工具如来检测和定位内存泄漏问题检查进程资源限制确认进程的资源限制是否合理包括内存限制和文件描述符限制如果限制过低可能导致进程无法获取足够的内存资源检查系统交换空间确认系统是否启用了交换空间以及交换空间的大小如果交换空间过小或者未启用当内存不足时系统无法将部分内存数据交换到磁盘从而导致错误检查程序日志检查程序的日志文件查找是否有与内存使用相关的错误或异常信息这有助于定位程序中可能导致的问题优化程序内存使用根据具体情况优化程序的内存使用方式可以考虑使用内存池减少内存分配次数释放不再使用的内存等方法来降低内存占用调整系统配置根据具体情况可能需要调整系统的内核参数或者其他配置以提高系统的内存管理和利用效率增加硬件资源如果经过优化和调整后仍然无法解决问题可能需要考虑增加系统的硬件资源如增加内存容量或者升级到更高性能的服务器总之问题的排查过程需要综合考虑多个因素包括内存使用情况进程资源限制系统配置等通过定位问题原因并采取相应措施来解决问题频繁问题排查频繁的问题通常是由于应用程序中的内存管理问题导致的下面是一般的排查过程确认频率首先确认确实发生频繁可以通过查看应用程序的日志或者性能监控工具来确定的发生频率和持续时间检查堆内存设置确认应用程序的堆内存设置是否合理堆内存过小可能导致频繁的垃圾回收而堆内存过大可能导致时间过长可以通过调整和参数来适当调整堆内存大小分析日志详细分析日志查看发生的原因日志中会提供关于垃圾回收的详细信息包括每个阶段的时间堆内存使用情况对象分配速率等通过分析日志可以确定的具体原因检查内存泄漏频繁的可能是由于内存泄漏导致的使用内存分析工具如来检测和定位内存泄漏问题分析内存快照可以查看对象的引用链找出造成内存泄漏的代码或对象检查对象生命周期确认应用程序中的对象生命周期是否合理如果有大量长时间存活的对象可能会导致频繁的可以考虑优化对象的创建和销毁方式减少对象的生命周期优化垃圾回收器参数根据具体情况可以调整垃圾回收器的参数来优化性能不同的垃圾回收器有不同的参数可供调整如新生代和老年代的比例垃圾回收算法等减少对象分配频繁的可能是由于过多的对象分配导致的可以通过重用对象使用对象池减少临时对象的创建等方式来降低对象分配的频率检查外部资源释放确保应用程序正确释放外部资源如数据库连接文件句柄等未正确释放外部资源可能导致内存泄漏和频繁的增加堆内存或调整策略如果经过优化后仍然无法解决频繁的问题可以考虑增加堆内存大小或者尝试其他的策略如性能测试和监控在排查过程结束后进行性能测试和监控验证优化措施是否有效是否解决了频繁的问题总之频繁的问题排查需要综合考虑堆内存设置日志分析内存泄漏对象生命周期等因素并采取相应的优化措施来减少的频率和持续时间统计方法耗时的原理是什么是一款用于应用程序的诊断工具可以实时地查看和修改应用程序的运行状态其中一个功能就是统计方法的耗时这个功能主要是通过对字节码的修改来实现的具体原理如下字节码修改使用字节码增强技术通过在类加载时修改字节码在方法的入口和出口处插入计时代码这使得能够在不修改源代码的情况下动态地统计方法的执行时间方法耗时统计当目标方法被调用时在方法入口处记录当前时间戳然后在方法退出时记录另一个时间戳通过这两个时间戳的差值就可以计算出方法的执行时间从而实现方法耗时的统计展示和分析收集到方法耗时的数据后会将这些数据进行汇总并展示给用户用户可以通过提供的命令或者控制台来查看方法的平均执行时间最大执行时间执行次数等信息从而快速定位潜在的性能瓶颈需要注意的是由于是通过字节码增强实现方法耗时的统计所以在某些情况下可能会对应用程序的性能产生一定的影响特别是当需要对大量方法进行耗时统计时因此在生产环境中应该谨慎使用的耗时统计功能避免过度的方法耗时统计对应用程序性能造成不必要的影响另外还提供了其他强大的功能如实时查看方法参数修改方法返回值等可以帮助开发人员更方便地诊断和调试应用程序慢问题排查慢问题是指在数据库中执行的语句花费了过长的时间来完成下面是一般的慢问题排查过程确认慢首先确认哪些语句被认为是慢可以通过数据库的性能监控工具或日志来获取执行时间较长的语句分析执行计划对于慢分析其执行计划是非常重要的执行计划描述了数据库是如何执行语句的包括使用的索引表的访问方式等通过执行计划可以确定是否存在索引缺失全表扫描等性能问题检查索引使用确认慢是否使用了适当的索引可以通过执行计划或数据库的索引统计信息来判断是否存在索引缺失索引选择不当等问题根据需要可以创建修改或删除索引来优化查询性能优化语句对于慢可以考虑对语句进行优化可以通过重写语句使用更合适的查询方式如子查询等避免使用不必要的函数或操作符等来提高查询性能检查表结构和数据量确认表的结构是否合理并检查表中的数据量是否过大如果表结构不合理或数据量过大可能会导致查询性能下降可以考虑调整表结构拆分大表分区等方式来优化查询性能数据库优化除了语句本身还可以考虑对数据库进行优化例如调整数据库的缓冲区大小增加内存优化数据库参数配置等以提升数据库的整体性能使用数据库工具使用数据库性能监控工具或查询分析工具可以更直观地分析慢问题这些工具可以提供更详细的性能指标执行计划索引建议等信息帮助更准确地定位和解决慢问题性能测试和监控在优化慢后进行性能测试和监控验证优化措施是否有效是否解决了慢问题总之慢问题排查需要综合考虑语句本身索引使用表结构数据库配置等多个因素并采取相应的优化措施来提高查询性能同时定期监控数据库的性能及时发现和解决慢问题以保证应用程序的正常运行和良好的性能飙高问题排查过程有一个项目平常都没事的运行的都比较好但每次在发布过程中刚刚重启好机器经常会有利用率和飙高的现象导致我们项目的变高反馈有大量超时当服务器的负载飙高表示服务器正在承受超过其处理能力的负载导致性能下降或服务不可用以下是一般的飙高问题排查过程确认负载情况使用系统监控工具如等或性能监控平台确认服务器的负载情况负载通常由三个数字表示分别是分钟分钟和分钟的平均负载如果这些数字超过服务器的处理能力说明负载过高检查系统资源使用检查服务器的内存磁盘和网络等资源的使用情况使用工具如等来查看各个资源的使用情况确定是否有资源瓶颈导致负载飙高查找高负载进程使用系统监控工具或命令如等查找占用系统资源较多的进程关注使用率高的进程以及可能导致高磁盘或网络流量的进程分析高负载进程对于占用系统资源较多的进程进一步分析其原因可以查看进程的日志配置文件线程信息等以确定是否存在异常情况死循环资源竞争等问题优化高负载进程根据分析结果对高负载进程进行优化可能的优化措施包括改进代码逻辑减少资源占用增加缓存调整线程池大小等扩展资源如果负载过高是由于资源不足导致的可以考虑扩展服务器资源例如增加核心扩大内存容量使用更快的磁盘等监控和自动化部署监控系统实时监测服务器的负载情况及时发现和解决负载飙高问题可以设置警报机制当负载超过一定阈值时及时通知运维人员性能测试和调优在优化措施实施后进行性能测试和监控验证是否解决了负载飙高问题并持续监控服务器的性能及时调整和优化需要注意的是负载飙高可能由多种原因引起可能是由于应用程序的问题也可能是由于系统配置不当或硬件故障等因此在排查过程中需要综合考虑多个因素并采取相应的措施来解决负载飙高问题人事面试情商一请介绍一下你自己回答提示这是面试官会问的问题一般人回答这个问题过于平常只说姓名年龄爱好所学专业等如果你用一分钟来重复你的简历那么你的印象加分没有了不妨坦诚自信地展现自我重点突出与应聘职位相吻合的优势你的相关能力和素质是企业最感兴趣的信息因为在许多情况下在听取你的介绍时面试官也会抓住他感兴趣的点深入询问所以在进行表述时要力求以真实为基础顾及表达的逻辑性和条理性避免冗长而没有重点的叙述一定要在最短的时间内激发起面试官对你的好感回答范例我叫今年岁年毕业于大学有年的开发工作经验我对技术有深厚的兴趣专业知识面宽责任心强思路清晰沟通力能好精通技术体系熟悉平常有时间看看博客并且自己也喜欢在上写技术类的文章与博友一起讨论谢谢如果跟人事自我介绍您好我叫如果学校和专业好的话可以提一下一般的话就算了我之前在公司做过两年开发工程师在这两年当中大概接触过什么样类型的项目比如商城金融等今天看了咱们公司招聘的岗位需求跟我之前的工作内容挺相符的而且咱们公司的业务也是我喜欢的类型所以我今天过来面试希望可以加入到咱们公司当中来如果是跟技术自我介绍您好我叫如果学校和专业好的话可以提一下一般的话就算了我之前在公司做过两年开发工程师在这两年当中大概接触过什么样类型的项目比如商城金融等在做这些项目的当中常用的一些技术点包括技术另外除了常用的技术还会一些其他的专业技能今天看了咱们公司招聘的岗位需求跟我之前的工作内容挺相符的所以我今天过来咱们公司面试希望可以加入到咱们这个大家庭当中来二为什么来深圳找工作面试官对异地求职者都会问的问题主要考察你是否稳定个人经验能力之外排在第一位的就是稳定性如果不够稳定那么其余都是空谈回答范例我来自湖南湖南是一个农业大省行业还不是很发达我是学计算机专业的也很喜欢这个行业深圳在国内行业发展是最快的所以我想来这里谋求发展学习更多的新技术能够带来自我的提升注意不要说以前公司有多么不好也不要说哪个哥们混的很不错羡慕才来深圳因为企业招人想要的都是能够长期工作的人可能哪个哥们哪天在别的地方又混的更好了你是不是还要跳槽所以只要说来学习更多新技术和管理经验就够了三你为什么离开原来的公司回答提示最重要的是应聘者要使找招聘单位相信应聘者在过往的单位的离职原因在此家招聘单位里不存在避免把离职原因说得太详细太具体不能掺杂主观的负面感受如太辛苦人际关系复杂管理太混乱公司不重视人才公司排斥我们某某的员工等但也不能躲闪回避如想换换环境个人原因等不能涉及自己负面的人格特征如不诚实懒惰缺乏责任感不随和等尽量使解释的理由为应聘者个人形象添彩回答范例如我离职是因为这家公司倒闭我在公司工作了三年多有较深的感情从去年始由于市场形势突变公司的局面急转直下到眼下这一步我觉得很遗憾但还要面对显示重新寻找能发挥我能力的舞台同一个面试问题并非只有一个答案而同一个答案并不是在任何面试场合都有效关键在应聘者掌握了规律后对面试的具体情况进行把握有意识地揣摩面试官提出问题的心理背景然后投其所好分析除非是薪资太低或者是最初的工作否则不要用薪资作为理由求发展也被考官听得太多离职理由要根据每个人的真实离职理由来设计但是在回答时一定要表现得真诚离职原因没有定式要根据自己的情况以及应聘公司的情况灵活的去说大概方向就是合同到期距离技术发展公司经营不好其他四你最大的缺点是什么被面试官问的概率很大也是的杀手锏和狠招这个问题最难回答通常面试官不希望听到求职直接回答的缺点是什么如果求职者说自己小心眼脾气大工作效率低企业肯定不会录用你不要自作聪明地回答我最大的缺点就是过于追求完美有的人以为这样回答会显得自己比较出色但事实上他已经岌岌可危了面试官喜欢求职者从自己的优点说起中间加一些小缺点最后再把问题转到优点上突出优点的部分面试官喜欢聪明的求职者回答范例这个问题好难回答啊我想想亲和力表现也缓解了自己的紧张情绪我的缺点是比较执着比如在技术方面比较爱钻研有的时候会为一个技术问题加班到深夜还有就是工作比较按部就班总是按照项目经管的要求完成任务另外的缺点是总在息的工作范围内有创新意识并没有扩展给其他同事这些问题我想我可以进入公司后以最短的时间来解决我的学习能力很强我相信可以很快融入公司的企业文化进入工作状态我想就这些吧五你未来年的职业规划是怎样的大部分面试官司都会问你是否有职业规划这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考在回答这个问题之前要对自己有个清晰的认识知道自己想往哪个方向发展以及未来有什么计划要给面试官一种积极向上好学上进有追求有规划的感觉面试官喜欢有规划的求职者回答范例我希望从现在开始年之内能够在我目前申请的这个职位上沉淀下来通过不断的努力后最好能有晋升希望年内可以做到架构师算法工程师建模工程师或者做管理同时我也希望自己能够在企业的平台上得到进一步的职业能力提升六你对薪资的要求如果你对薪酬的要求太低那显然贬低自己的能力如果你对薪酬的要求太高那又会显得你分量过重公司受用不起一些雇主通常都事先对求职的职位定下开支预算因而他们第一次提出的价钱往往是他们所能给予的最高价钱他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣回答范例一我对工资没有硬性要求我相信贵公司在处理我的问题上会友善合理我注重的是找对工作机会所以只要条件公平我则不会计较太多如果你必须自己说出具体数目那就不要说一个宽泛的范围不要说之间那样你将只会得到最低限底的数字也就是最好给出一个具体的数字七什么时候能入职大多数企业会关心就职时间最好是回答如果被录用的话到职日可按公司的规定上班如果还未辞去上一个工作但上班时间又太近似乎有些强人所难因为交接至少要一个月的时间应进一步说明原因录取公司应该会通融的八介绍一个你认为最熟悉的项目项目经理这个问题在技术面试时常被问到问这个问题的意图是想考察你的成长路径和编程习惯因为你最熟悉的项目往往是你成长最快的项目那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹所以通过你对熟悉项目的描述有经验的他会很快锁定你技术成长中的缺陷和闪光点从而判断是否能够为我所用你最好拿出一个自己最擅长技术的那个项目进行介绍他听完你的介绍后会接下来进行提问这样他所有问的问题你都成竹在胸了切忌拿自己参与很少的项目来介绍一旦他深入的询问很可能你会答非所问反而造成更严重的影响你大强以和他谈谈在那个项目中获得的经验这样会引起此君的共鸣有可能的话说出一些你自己的小技巧他会很高兴同时这场面试也会很轻松拿到基本没问题了九如果公司录用你你将怎样开展工作很多企业在招聘开发人员时很看重是否能够尽快上手所以回答这个问题时要实打实的回答在回答中最好强调能够尽快投入开发工作中这样领导就放心了会觉得你不是一个只会盲目工作的人而是一个按部就班稳打稳扎的人回答范例我对咱们公司的大体情况只有一个大概了解在这个职位的工作性质仅仅是我自己的一个理解作为这个职位而言我想我首先要对本公司的主营业务要有一个了解了解公司的业务组成部分业务的发展方向我们面向的客户性质等第二我要了解所属部门在公司中的地位以及部门的工作目标从而确定自身的工作努力方向第三了解我参与项目的开发方式架构方式紧密配合领导工作尽快投入具体的开发工作中这就是我开展工作的计划十你还有什么问题问我吗这个问题看上去可有可无其实很关键面试官不喜欢说没有问题的人没有问题就是自寻死路没有问题传达出你对公司缺乏兴趣而只是来寻找一笔薪水其实在面试过程中谦虚礼貌的问面试官怎么称呼该部门工作中的信息如项目情况开发技术再或者说贵公司的晋升机制是什么样的等表现出一种很积极主动的状态是非常讨巧的也可以更多的了解到自己来的工作环境企业很欢迎这样的求职者因为体现出你对学习的热情和对公司的忠诚度以及你的上进心这个要分析面试官的身份如果是普通技术面试官可以问问对方目前项目的规划使用的技术情况还有就是您在这边工作多久了是否能分享一些您在这边的工作体会如果是的话可以问问公司的企业文化工资评定是否跟绩效挂钩公司是否定期组织员工活动团建等等如果是公司或者是的话可以问问团队的组成和公司前景之类的或者告诉面试官关于公司的部分情况通过查看公司网站还有面试基本上了解了比较喜欢咱们公司这个平台和氛围希望有机会能加入一起共事如果您这边觉得我合适的话最快什么时间能给我回复十一社保问题如果上家公司写的是外地公司的话之前是否上过社保深圳这边是查不到的而且都要重新上如果上家写的深圳公司之前确实没有上过的话就说之前公司规模小五险一金一直没有上但是签了自动放弃的协议公司也给一部分补偿金金额大概左右如果之前你在深圳上过一段时间的社保跟现在写的工作经历对不上的话就说之前公司不给上有一段时间自己通过关系找了一家公司挂靠了一段时间面试的时候如果问你之前在深圳是否上过社保只要说是或者否就可以不用主动说太多对方问的话再解释十二上家公司薪资构成及到手多少钱网上找税收计算器把上家薪资输入自动算出扣税多少再加上社保补偿金就是你最后到手的工资不用跟面试官说的特详细只要说个大概就好十三你有没有在工作中遇到过你无论如何都难以解决的问题你的态度如何工作中难免会有些问题难以被彻底的解决在这样的情况下我会思考这样几个问题我是否已经尽了全力是否还有什么方法或什么人能够帮助我解决问题我是否已经全面的思考过问题的方方面面还是钻在死胡同里出不来我是否能在目前情况下改善问题哪怕只是较小程度的改善有时一些小小的改善积累起来可能最终就能够解决问题我认为遇到问题的态度切忌慌乱往往欲速则不达因此要冷静下来思考另外就是切记不停的抱怨不停的抱怨不但会给人留下负面印象甚至因为消极的态度错过了解决问题的最后机会点评该求职者首先表现了他不会轻易放弃解决问题的态度懂得从各个角度去思考问题并且会努力到最后一刻在表述自己遇到问题的态度方面该求职者也表现的非常完美冷静不抱怨并积极处理问题是所有面试官都会欣赏的态度十四压力面试随着企业竞争的激烈员工的压力也越来越大因此企业希望寻找到能够接受挑战承担责任并能够抵抗压力的高素质人才因此压力面试越来越多地应用到面试中面试官会制造一种具有压力的紧张气氛采用的方式包括打击求职者的自信心对求职者的回答表示不满意希望得到更佳的答案并且始终不给于正面的反馈对于求职者的回答步步紧逼不断的追问求职者回答中的任何细节都会被不断的追问细节上有任何不相符之处都可能引起质疑突然提出出乎意料的问题或是非常难以回答的问题并用沉默的方式等待求职者给出回答其实压力面试只是一种特殊形式的行为面试无需感到恐慌所需要做的只是冷静冷静再冷静无论对方提出的问题有多刁难要保持冷静的应答如果遇到实在无法继续回答的情况可以将皮球踢回给面试官例如面对微笑的反问我在这个方面确实并不清楚或者接触的少非常希望能够得到您的指导或者您遇到这种情况该怎么处理在压力面试中面试官需要考察的是求职者面对压力的处理能力而不仅是那些不合理问题的答案有的面试官故意出一些难题打击你的自信心让你在要薪资的时候不敢多要因此放松心态做足准备面对即可十五电话面试避免没有重音没有语音语调这样会让听者变得非常的沉闷甚至错过所需要留意的内容由于没有目光的接触以及肢体语言等辅助沟通手段因此求职者必须把自己的回答尽可能整理的比较有逻辑条理清晰事例具体否则很难给面试官留下深刻的印象由于电话面试常常应用于初期审核阶段如果不能够较快抓住面试官的注意面试官可能未必会花太多的时间去了解你因此需要力求尽快地抓住面试官的注意十六你对加班的看法实际上好多公司问这个问题并不证明一定要加班只是想测试你是否愿意为公司奉献回答范例如果是工作需要我会义不容辞加班我现在单身没有任何家庭负担可以全身心的投入工作但同时我也会提高工作效率减少不必要的加班十七你朋友对你的评价回答提示想从侧面了解一下你的性格及与人相处的问题回答样本一我的朋友都说我是一个可以信赖的人因为我一旦答应别人的事情就一定会做到如果我做不到我就不会轻易许诺回答样本二我觉的我是一个比较随和的人与不同的人都可以友好相处在我与人相处时我总是能站在别人的角度考虑问题十八如果通过这次面试我们单位录用了你但工作一段时间却发现你根本不适合这个职位你怎么办回答提示一段时间发现工作不适合我有两种情况如果你确实热爱这个职业那你就要不断学习虚心向领导和同事学习业务知识和处事经验了解这个职业的精神内涵和职业要求力争减少差距你觉得这个职业可有可无那还是趁早换个职业去发现适合你的你热爱的职业那样你的发展前途也会大点对单位和个人都有好处十九在完成某项工作时你认为领导要求的方式不是最好的自己还有更好的方法你应该怎么做回答提示原则上我会尊重和服从领导的工作安排同时私底下找机会以请教的口吻婉转地表达自己的想法看看领导是否能改变想法如果领导没有采纳我的建议我也同样会按领导的要求认真地去完成这项工作还有一种情况假如领导要求的方式违背原则我会坚决提出反对意见如领导仍固执己见我会毫不犹豫地再向上级领导反映二十如果你的工作出现失误给本公司造成经济损失你认为该怎么办回答提示我本意是为公司努力工作如果造成经济损失我认为首要的问题是想方设法去弥补或挽回经济损失如果我无能力负责希望单位帮助解决分清责任各负其责如果是我的责任我甘愿受罚如果是一个我负责的团队中别人的失误也不能幸灾乐祸作为一个团队需要互相提携共同完成工作安慰同事并且帮助同事查找原因总结经验总结经验教训一个人的一生不可能不犯错误重要的是能从自己的或者是别人的错误中吸取经验教训并在今后的工作中避免发生同类的错误检讨自己的工作方法分析问题的深度和力度是否不够以致出现了本可以避免的错误二十一如果你做的一项工作受到上级领导的表扬但你主管领导却说是他做的你该怎样回答提示我首先不会找那位上级领导说明这件事我会主动找我的主管领导来沟通因为沟通是解决人际关系的最好办法但结果会有两种我的主管领导认识到自己的错误我想我会视具体情况决定是否原谅他他更加变本加厉的来威胁我那我会毫不犹豫地找我的上级领导反映此事因为他这样做会造成负面影响对今后的工作不利二十二谈谈你对跳槽的看法回答提示正常的跳槽能促进人才合理流动应该支持频繁的跳槽对单位和个人双方都不利应该反对二十三工作中你难以和同事上司相处你该怎么办回答提示我会服从领导的指挥配合同事的工作我会从自身找原因仔细分析是不是自己工作做得不好让领导不满意同事看不惯还要看看是不是为人处世方面做得不好如果是这样的话我会努力改正如果我找不到原因我会找机会跟他们沟通请他们指出我的不足有问题就及时改正作为优秀的员工应该时刻以大局为重即使在一段时间内领导和同事对我不理解我也会做好本职工作虚心向他们学习我相信他们会看见我在努力总有一天会对我微笑的二十四假设你在某单位工作成绩比较突出得到领导的肯定但同时你发现同事们越来越孤立你你怎么看这个问题你准备怎么办回答提示成绩比较突出得到领导的肯定是件好事情以后更加努力检讨一下自己是不是对工作的热心度超过同事间交往的热心了加强同事间的交往及共同的兴趣爱好工作中切勿伤害别人的自尊心不再领导前拨弄是非二十五你对于我们公司了解多少回答提示在去公司面试前上网查一下该公司主营业务如回答贵公司有意改变策略加强与国外大厂的合作自有品牌的部分则透过海外经销商二十六请说出你选择这份工作的动机回答提示这是想知道面试者对这份工作的热忱及理解度并筛选因一时兴起而来应试的人如果是无经验者可以强调就算职种不同也希望有机会发挥之前的经验二十七你最擅长的技术方向是什么回答提示说和你要应聘的职位相关的课程表现一下自己的热诚没有什么坏处二十八你能为我们公司带来什么呢回答提示技术能力人脉二十九最能概括你自己的三个词是什么回答提示我经常用的三个词是适应能力强有责任心和做事有始终结合具体例子向主考官解释三十你的业余爱好是什么回答提示找一些富于团体合作精神的这里有一个真实的故事有人被否决掉因为他的爱好是深海潜水主考官说因为这是一项单人活动我不敢肯定他能否适应团体工作多说团体合作爱浏览技术网站博客书籍最好提前想好最近在看那本书看到了哪个部分三十一作为被面试者给我打一下分回答提示试着列出四个优点和一个非常非常非常小的缺点可以抱怨一下设施没有明确责任人的缺点是不会有人介意的三十二你怎么理解你应聘的职位回答提示把岗位职责和任务及工作态度阐述一下三十三喜欢这份工作的哪一点回答提示相信其实大家心中一定都有答案了吧每个人的价值观不同自然评断的标准也会不同但是在回答面试官这个问题时可不能太直接就把自己心理的话说出来尤其是薪资方面的问题不过一些无伤大雅的回答是不错的考虑如交通方便工作性质及内容颇能符合自己的兴趣等等都是不错的答案不过如果这时自己能仔细思考出这份工作的与众不同之处相信在面试上会大大加分三十四说说你对行业技术发展趋势的看法回答提示企业对这个问题很感兴趣只有有备而来的求职者能够过关求职者可以直接在网上查找对你所申请的行业部门的信息只有深入了解才能产生独特的见解企业认为最聪明的求职者是对所面试的公司预先了解很多包括公司各个部门发展情况在面试回答问题的时候可以提到所了解的情况企业欢迎进入企业的人是知己而不是盲人三十五说你的家庭回答提示企业面试时询问家庭问题不是非要知道求职者家庭的情况探究隐私企业不喜欢探究个人隐私而是要了解家庭背景对求职者的塑造和影响企业希望听到的重点也在于家庭对求职者的积极影响企业最喜欢听到的是我很爱我的家庭我的家庭一向很和睦虽然我的父亲和母亲都是普通人但是从小我就看到我父亲起早贪黑每天工作特别勤劳他的行动无形中培养了我认真负责的态度和勤劳的精神我母亲为人善良对人热情特别乐于助人所以在单位人缘很好她的一言一行也一直在教导我做人的道理企业相信和睦的家庭关系对一个人的成长有潜移默化的影响三十六就你申请的这个职位你认为你还欠缺什么回答提示企业喜欢问求职者弱点但精明的求职者一般不直接回答他们希望看到这样的求职者继续重复自己的优势然后说对于这个职位和我的能力来说我相信自己是可以胜任的只是缺乏经验这个问题我想我可以进入公司以后以最短的时间来解决我的学习能力很强我相信可以很快融入公司的企业文化进入工作状态企业喜欢能够巧妙地躲过难题的求职者三十七你欣赏哪种性格的人回答提示诚实不死板而且容易相处的人有实际行动的人三十八你通常如何处理別人的批评回答提示沈默是金不必说什么否则情况更糟不过我会接受建设性的批评我会等大家冷靜下来再讨论三十九你为什么愿意到我们公司来工作回答提示对于这个问题你要格外小心如果你已经对该单位作了研究你可以回答一些详细的原因像公司本身的高技术开发环境很吸引我我同公司出生在同样的时代我希望能够进入一家与我共同成长的公司你们公司一直都稳定发展在近几年来在市场上很有竞争力我认为贵公司能够给我提供一个与众不同的发展道路这都显示出你已经做了一些调查也说明你对自己的未来有了较为具体的远景规划四十你和别人发生过争执吗你是怎样解决的回答提示这是面试中最险恶的问题其实是考官布下的一个陷阱千万不要说任何人的过错应知成功解决矛盾是一个协作团体中成员所必备的能力假如你工作在一个服务行业这个问题简直成了最重要的一个环节你是否能获得这份工作将取决于这个问题的回答考官希望看到你是成熟且乐于奉献的他们通过这个问题了解你的成熟度和处世能力在没有外界干涉的情况下通过妥协的方式来解决才是正确答案四十一你做过的哪件事最令自己感到骄傲回答提示这是考官给你的一个机会让你展示自己把握命运的能力这会体现你潜在的领导能力以及你被提升的可能性假如你应聘于一个服务性质的单位你很可能会被邀请去午餐记住你的前途取决于你的知识你的社交能力和综合表现四十二对这项工作你有哪些可预见的困难回答提示不宜直接说出具体的困难否则可能令对方怀疑应聘者不行可以尝试迂回战术说出应聘者对困难所持有的态度工作中出现一些困难是正常的也是难免的但是只要有坚忍不拔的毅力良好的合作精神以及事前周密而充分的准备任何困难都是可以克服分析一般问这个问题面试者的希望就比较大了因为已经在谈工作细节但常规思路中的回答又被面试官骗了当面试官询问这个问题的时候有两个目的第一看看应聘者是不是在行说出的困难是不是在这个职位中一般都不可避免的问题第二是想看一下应聘者解决困难的手法对不对及公司能否提供这样的资源而不是想了解应聘者对困难的态度四十三怎样对待自己的失敗回答提示我们大家生来都不是十全十美的我相信我有第二个机会改正我的错误四十四什么会让你有成就感回答提示为贵公司竭力效劳尽我所能完成一个项目四十五眼下你生活中最重要的是什么回答提示对我来说能在这个领域找到工作是最重要的能在贵公司任职对我说最重要四十六与上级意见不一是你将怎么办回答提示一般可以这样回答我会给上级以必要的解释和提醒在这种情况下我会服从上级的意见如果面试你的是总经理而你所应聘的职位另有一位经理且这位经理当时不在场可以这样回答对于非原则性问题我会服从上级的意见对于涉及公司利益的重大问题我希望能向更高层领导反映分析这个问题的标准答案是思路如果用的回答必死无疑你没有摸清楚改公司的内部情况先想打小报告这样的人没有人敢要四十七你工作经验欠缺如何能胜任这项工作常规思路如果招聘单位对应聘者提出这个问题说明招聘公司并不真正在乎经验关键看应聘者怎样回答对这个问题的回答最好要体现出应聘者的诚恳机智果敢及敬业如在项目经验方面的确会有所欠缺但我有较强的责任心适应能力和学习能力而且比较勤奋在上家公司无论遇到什么困难都能想办法完成各项工作从中获取的经验也令我受益非浅请贵公司放心我一定能胜任这个职位点评这个问题思路中的答案尚可突出自己的吃苦能力和适应性以及学习能力不是学习成绩为好四十八你希望与什么样的上级共事回答提示通过应聘者对上级的希望可以判断出应聘者对自我要求的意识这既上一个陷阱又是一次机会最好回避对上级具体的希望多谈对自己的要求如做为刚步入社会的新人我应该多要求自己尽快熟悉环境适应环境而不应该对环境提出什么要求只要能发挥我的专长就可以了分析这个问题比较好的回答是希望我的上级能够在工作中对我多指导对我工作中的错误能够立即指出总之从上级指导这个方面谈不会有大的纰漏四十九谈谈如何适应办公室工作的新环境回答提示办公室里每个人有各自的岗位与职责不得擅离岗位根据领导指示和工作安排制定工作计划提前预备并按计划完成多请示并及时汇报遇到不明白的要虚心请教抓间隙时间多学习努力提高自己的政治素质和业务水平五十为了做好你工作份外之事你该怎样获得他人的支持和帮助回答提示每个公司都在不断变化发展的过程中你当然希望你的员工也是这样你希望得到那些希望并欢迎变化的人因为这些人明白为了公司的发展变化是公司日常生活中重要组成部分这样的员工往往很容易适应公司的变化并会对变化做出积极的响应五十一如果你在这次面试中没有被录用你怎么打算回答提示现在的社会是一个竞争的社会从这次面试中也可看出这一点有竞争就必然有优劣有成功必定就会有失败往往成功的背后有许多的困难和挫折如果这次失败了也仅仅是一次而已只有经过经验经历的积累才能塑造出一个完全的成功者我会从以下几个方面来正确看待这次失败要敢于面对面对这次失败不气馁接受已经失去了这次机会就不会回头这个现实从心理意志和精神上体现出对这次失败的抵抗力要有自信相信自己经历了这次之后经过努力一定能行能够超越自我善于反思对于这次面试经验要认真总结思考剖析能够从自身的角度找差距正确对待自己实事求是地评价自己辩证的看待自己的长短得失做一个明白人走出阴影要克服这一次失败带给自己的心理压力时刻牢记自己弱点防患于未然加强学习提高自身素质再接再厉能进入像贵公司这样的平台一直是我的梦想以后如果有机会我仍然后再次参加竞争五十二谈谈你过去做过的成功案例回答提示举一个你最有把握的例子把来龙去脉说清楚而不要说了很多却没有重点切忌夸大其词把别人的功劳到说成自己的很多主管为了确保要用的人是最适合的会打电话向你的前一个主管征询对你的看法及意见所以如果说谎是很容易穿梆的五十三谈谈你过去的工作经验中最令你挫折的事情回答提示可以在网上查查其他人在开发过程中会出现哪些问题最后是怎么解决的分析借此了解你对挫折的容忍度及调解方式分析虽然不会有人心甘情愿的加班但依旧要表现出高配合度的诚意五十四为什么我们要在众多的面试者中选择你回答提示根据我对贵公司的了解以及我在这份工作上所累积的专业经验及人脉相信正是贵公司所找寻的人才而我在工作态度上也有圆融成熟的一面和主管同事都能合作愉快分析别过度吹嘘自己的能力或信口开河地乱开支票例如一定会为该公司带来多少钱的业务等这样很容易给人一种爱说大话不切实际的感觉五十五你并非毕业于名牌院校回答提示是否毕业于名牌院校不重要重要的是有能力完成您交给我的工作我想我更适合贵公司这个职位五十六怎样看待学历和能力回答提示学历我想只要是大学专科的学历就表明觉得我具备了根本的学习能力剩下的你是学士也好还是博士也好对于这一点的讨论不是看你学了多少知识而是看你在这个领域上发挥了什么也就是所说的能力问题一个人工作能力的高低直接决定其职场命运而学历的高低只是进入一个企业的敲门砖如果贵公司把学历卡在博士上我就无法进入贵公司当然这不一定只是我个人的损失如果一个专科生都能完成的工作您又何必非要招聘一位博士生呢五十七工作中学习到了些什么回答提示这是针对转职者提出的问题建议此时可以配合面试工作的特点作为主要依据来回答如业务工作需要与人沟通便可举出之前工作与人沟通的例子经历了哪些困难学习到哪些经验把握这些要点做陈述就可以轻易过关了五十八想过创业吗回答提示这个问题可以显示你的冲劲但如果你的回答是有的话千万小心下一个问题可能就是那么为什么你不这样做呢五十九除了本公司外还应聘了哪些公司回答提示很奇怪这是相当多公司会问的问题其用意是要概略知道应徵者的求职志向所以这并非绝对是负面答案就算不便说出公司名称也应回答类似的公司互联网如果应聘的其他公司是不同业界容易让人产生无法信任的感觉六十面试注意事项在面试官面前千万不要抖脚手脚不要动来动去不能有小动作在面试过程中千万不要跟面试官去争论说话太冲太能说抢话说乱说都不好遇到难题先思考一下切记心浮气燥表达时口气温和谦虚如果面试过程中都不错谈的也很好之后却没有给完全是自己意料之外的情况这个很有可能或许是因为公司有了其他的人选不用介意更不要沮丧在面试过程中切忌问关于公司计划行业机密等相关的东西不要打探公司的内幕机密敏感性的问题不要问东问西千万要注意仪容仪表要有礼貌最好不要有口吃口头表达逻辑思维很重要不要让面试官觉得你很幼稚太过小孩子气显的不够稳重踏实在去面试之前要熟悉自己的简历特别是工作经历准备好关于一些离职原因职业规划方面的问题的回答方式在面试过程中的面试官会让做自我介绍所以提前要准备一下说出的内容既要和简历相符又要有重点有突出的地方不能像背简历一样面试完后如果等待的时间较长没有回应就可能没有什么希望了自己可以打电话去了解情况在面试过程中谈到薪资的时候如果没有说明是税后工资就是税前假如是税前这里面就包括了公司给交的公积金还有其他五险要交的费用拿到手差不多左右',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-27 13:10:05',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom/schedule.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" href="/css/custom/aliicon.css"><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Lyon`s Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://ticket-event.oss-cn-beijing.aliyuncs.com/WechatPay.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://ticket-event.oss-cn-beijing.aliyuncs.com/WechatPay.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://ticket-event.oss-cn-beijing.aliyuncs.com/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://ticket-event.oss-cn-beijing.aliyuncs.com/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 1.05rem;">八股文<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>1</sup></a><a href="/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/" style="font-size: 1.05rem;">场景题<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 1.05rem;">尚硅谷<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a><a class="article-meta__tags" href="/tags/Java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Java</span></a><a class="article-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>八股文</span></a><a class="article-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>后端</span></a><a class="article-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>网络编程</span></a><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>多线程</span></a><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据库</span></a><a class="article-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>设计模式</span></a><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>计算机网络</span></a><a class="article-meta__tags" href="/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>场景题</span></a><a class="article-meta__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>尚硅谷</span></a></span></div></div><h1 class="post-title" itemprop="name headline">八股文详细版</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-03-26T14:48:51.000Z" title="发表于 2025-03-26 22:48:51">2025-03-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-03-27T05:10:05.368Z" title="更新于 2025-03-27 13:10:05">2025-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="八股文详细版"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/"><header><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><a href="/tags/Java/" tabindex="-1" itemprop="url">Java</a><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" tabindex="-1" itemprop="url">八股文</a><a href="/tags/%E5%90%8E%E7%AB%AF/" tabindex="-1" itemprop="url">后端</a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" tabindex="-1" itemprop="url">网络编程</a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url">多线程</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" tabindex="-1" itemprop="url">数据库</a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" tabindex="-1" itemprop="url">设计模式</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" tabindex="-1" itemprop="url">计算机网络</a><a href="/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/" tabindex="-1" itemprop="url">场景题</a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" tabindex="-1" itemprop="url">尚硅谷</a><h1 id="CrawlerTitle" itemprop="name headline">八股文详细版</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">lyon ai</span><time itemprop="dateCreated datePublished" datetime="2025-03-26T14:48:51.000Z" title="发表于 2025-03-26 22:48:51">2025-03-26</time><time itemprop="dateCreated datePublished" datetime="2025-03-27T05:10:05.368Z" title="更新于 2025-03-27 13:10:05">2025-03-27</time></header><h1 id="Java基础-100"><a href="#Java基础-100" class="headerlink" title="Java基础 100%"></a>Java基础 100%</h1><h2 id="JAVASE"><a href="#JAVASE" class="headerlink" title="JAVASE"></a>JAVASE</h2><h3 id="1、写出Java的四类八种基本数据类"><a href="#1、写出Java的四类八种基本数据类" class="headerlink" title="1、写出Java的四类八种基本数据类"></a>1、写出Java的四类八种基本数据类</h3><p>整数                      byte short int long</p>
<p>小数(浮点)             float double</p>
<p>布尔                      boolean</p>
<p>字符                      char</p>
<h3 id="2、-和-的区别-x20"><a href="#2、-和-的区别-x20" class="headerlink" title="2、&amp; 和 &amp;&amp; 的区别&#x20;"></a>2、&amp; 和 &amp;&amp; 的区别&#x20;</h3><p>&amp;  符号的左右两边,无论真或假都要执行</p>
<p>&amp;&amp; 符号的左边如果为假,符号的右边不再执行,提高了代码的执行效率</p>
<h3 id="3、switch的参数可以是什么类型"><a href="#3、switch的参数可以是什么类型" class="headerlink" title="3、switch的参数可以是什么类型"></a>3、switch的参数可以是什么类型</h3><p>byte，short，int，char，String，枚举</p>
<h3 id="4、说出实例变量和局部变量的区别"><a href="#4、说出实例变量和局部变量的区别" class="headerlink" title="4、说出实例变量和局部变量的区别"></a>4、说出实例变量和局部变量的区别</h3><p>1, 物理位置</p>
<p>成员变量: 类中方法外</p>
<p>局部变量: 方法中或方法定义的小括号里面 </p>
<p>2, 内存位置</p>
<p>成员变量: 在堆内存中</p>
<p>局部变量: 通常在栈内存中（栈帧）</p>
<p>3, 生命周期</p>
<p>成员变量: 随着对象创建而产生,随着对象的消失而消失</p>
<p>局部变量: 随着方法的调用而产生,随着方法调用结束而消失</p>
<p>4,有无默认值&#x20;</p>
<p>成员变量: 有默认值, 整数0,小数0.0 字符 ‘\u0000’ 布尔 false 引用数据类型 null</p>
<p>局部变量: 没有默认值,使用的时候,必须先赋值</p>
<h3 id="5、static关键字都能修饰什么？-都有什么特点"><a href="#5、static关键字都能修饰什么？-都有什么特点" class="headerlink" title="5、static关键字都能修饰什么？ 都有什么特点"></a>5、static关键字都能修饰什么？ 都有什么特点</h3><p>1, 修饰成员变量, 叫静态变量 具有共享性,节省内存空间；</p>
<p>2, 修饰方法: 静态方法: 可以直接使用类名.进行调用；</p>
<p>3, 修饰代码块: 静态代码块 ,给静态变量进行赋值；</p>
<p>4, 修饰类: 静态内部类；</p>
<h3 id="6、overload和override的区别"><a href="#6、overload和override的区别" class="headerlink" title="6、overload和override的区别"></a>6、overload和override的区别</h3><p>overload 是重载  要求在同一个类中,方法名相同,参数列表不同与返回值类型无关 。</p>
<p>参数列表不同表现在: 个数不同, 数据类型顺序不同,数据类型不同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5CSnipaste_2023-09-11_23-44-15_cGOhfc8JMK.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_NbyMFXIzrq.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_3LFML38aGN.png"></p>
<p>override是重写 要求发生在子父级的继承关系中,方法名相同,参数列表相同,返回值类型是父类返回值类型本身或其子类, 异常等于父类本身异常类型或小于父类本身异常。</p>
<p><strong>把控细节</strong>：构造方法不能被重写,因为构造方法要求,方法名与类名保持一致 <strong>.</strong></p>
<p><strong>返回值</strong>：</p>
<p><strong>父类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_XQ_B_s49j8.png"></p>
<p><strong>子类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_p0XDdRo9Hk.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_xE91sIqVK4.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_b5KwsPrYqU.png"></p>
<p>&#x20;<strong>异常</strong>：</p>
<p><strong>父类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_BWfXGqUFdK.png"></p>
<p><strong>子类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_CtFyF82WFI.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_0cNkUkp_CP.png"></p>
<h3 id="7、-final-和-finally的区别"><a href="#7、-final-和-finally的区别" class="headerlink" title="7、 final 和 finally的区别"></a>7、 final 和 finally的区别</h3><p><strong>final 是权限修饰符, 表示最终的, 能修饰 变量, 方法,和类</strong>。</p>
<p>修饰变量: 变成了常量。</p>
<p>修饰方法: 变成了最终的方法,不能被重写,但是可以被正常调用。</p>
<p>修饰类: 变成的最终的类,不能有子类,但是可以被正常创建对象。</p>
<p><strong>finally 是一个代码块,只能与我们的 try代码块连用,表示无论代码是否发生异常,finally里面的代码都要执行</strong>。</p>
<p>finally强制退出两种方式：System.exit()、</p>
<p><strong>Finally把控细节：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.finals;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinallyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">FinallyDemo</span> <span class="variable">finallyDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinallyDemo</span>();</span><br><span class="line">        <span class="comment">// finallyDemo.finallyTestTryNoResult(); </span></span><br><span class="line">        <span class="comment">// System.out.println(finallyDemo.finallyTestTryResult()); </span></span><br><span class="line">        / /System.out.println(finallyDemo.finallyTestCatchResult()); </span><br><span class="line"></span><br><span class="line">         System.out.println(finallyDemo.finallyTestFinallyResult()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.都没有返回值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finallyTestTryNoResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try code block invoked&quot;</span>);</span><br><span class="line">            <span class="comment">//int i = 1 / 0;</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch code block invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally code block invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.try有返回值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">finallyTestTryResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try code block invoked&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;no result&quot;</span>;</span><br><span class="line">            <span class="comment">//throw new Exception();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;catch code block invoked&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally code block invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.catch有返回值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">finallyTestCatchResult</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try code block invoked&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new Exception();</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;no result&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;catch code block invoked&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally code block invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.finally有返回值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">finallyTestFinallyResult</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;try code block invoked&quot;</span>);</span><br><span class="line">            <span class="comment">//throw new Exception();</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;no result&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;catch code block invoked&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally code block invoked&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、-this和super都能用到哪些地方"><a href="#8、-this和super都能用到哪些地方" class="headerlink" title="8、 this和super都能用到哪些地方"></a>8、 this和super都能用到哪些地方</h3><p>1、访问成员变量</p>
<p>this：可以区分成员变量与局部变量重名问题,如果本类没有这个成员变量,也可以调用父类的成员变量。</p>
<p>super：可以区分本类成员变量与父类成员变量重名问题，只能调用父类的成员变量。</p>
<p>2、访问成员方法                             &#x20;</p>
<p>this：可以调用本类的成员方法,如果本类没有这个成员方法,也可以调用父类的成员方法。</p>
<p>super：只能调用父类的成员方法。</p>
<p>3、访问构造器</p>
<p>this：可以通过this() 或 this(参数) 让其本类的构造方法直接相互调用。</p>
<p>super：子类通过super() 或 super(参数) 调用父类的构造方法。</p>
<h3 id="9、-接口与抽象类的区别"><a href="#9、-接口与抽象类的区别" class="headerlink" title="9、 接口与抽象类的区别"></a>9、 接口与抽象类的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_-q4Ewc-z0q.png"></p>
<p><strong>把控细节</strong>：</p>
<p><strong>抽象类：</strong></p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.abstracts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象类和普通类基本没有区别（只是多了一个可以定义抽象方法）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;<span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> b;<span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.抽象类中静态方法--有方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.抽象类中构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractDemo</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.抽象类中实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.抽象类中定义一个抽象方法，注意没有方法实现体。</span></span><br><span class="line">    <span class="comment">//public abstract void c()&#123; //fail</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">c</span><span class="params">()</span>;<span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>接口</strong>：</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.abstracts;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterfaceDemo</span> <span class="keyword">extends</span> <span class="title class_">InterfaceDemo1</span>, InterfaceDemo2 &#123;</span><br><span class="line">    <span class="comment">// 1.接口中不能定义静态方法--但是可以有静态方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//public static void b();//fail</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.接口中不可以定义构造方法</span></span><br><span class="line">    <span class="comment">//public InterfaceDemo()&#123;//fail</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.接口中不可以定义实例方法（没有static  也没有abstract关键字）</span></span><br><span class="line">    <span class="comment">//public void c();//fail</span></span><br><span class="line">    <span class="comment">// 4.接口中不能定义变量--只能有常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//public int x;//fail</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.接口中所有的默认方法都是public abstract修饰  且访问修饰符必须要是public或者不写，不写则使用默认(注意：默认指的不是default)</span></span><br><span class="line">    <span class="comment">// 抽象类中的访问修饰符四种都可以（public protected private 不写）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">world</span><span class="params">()</span>;<span class="comment">// public abstract</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.8允许接口中有方法的实现，但是必须用关键字default修饰</span></span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="10、-静态变量与实例变量的区别"><a href="#10、-静态变量与实例变量的区别" class="headerlink" title="10、 静态变量与实例变量的区别"></a>10、 静态变量与实例变量的区别</h3><p>内存位置 : 静态变量在方法区中,实例变量在堆内存中。</p>
<p>生命周期 : 静态变量随着.class文件加载而产生,随着.class文件结束而结束; 实例变量随着对象的创建而产生,随着对象的结束而结束。</p>
<p>调用方式: 静态变量既可以通过 类名.直接进行调用, 也可以通过对象名.进行调用; 实例变量只能通过 对象名.进行访问。</p>
<h3 id="11、throw和throws-的区别"><a href="#11、throw和throws-的区别" class="headerlink" title="11、throw和throws 的区别"></a>11、throw和throws 的区别</h3><p>throw 是具体抛出一个异常对象,在方法的内部, 后面有且只能有一个异常对象,代码一旦遇到了throw证明出现了问题,代码就会停止,线程会异常退出。</p>
<p>throws 是异常的声明, 在方法定义的小括号后面,后面可以跟多个异常的类型,方法有throws,代码不一定发生异常。</p>
<h3 id="12、String-StringBuilder-与-StringBuffer-的区别"><a href="#12、String-StringBuilder-与-StringBuffer-的区别" class="headerlink" title="12、String,StringBuilder 与 StringBuffer 的区别"></a>12、String,StringBuilder 与 StringBuffer 的区别</h3><p>String、StringBuilder、StringBuffer是不可变的字符串序列,因此该类不可以被继承，也即没有子类。</p>
<p><strong>相同点</strong>：</p>
<p><strong>String类</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5C1_jv4gzKqvxS.png"></p>
<p><strong>StringBuilder类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_CT1w2movtT.png"></p>
<p><strong>StringBuffer类：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_o9-91DL0VR.png"></p>
<p><strong>不同点：</strong></p>
<p>StringBuilder类中的大多数方法没有加Synchronized关键字修饰。而StringBuffer类中的大多数方法都是加了Synchronized关键字修饰，正因为如此，在多线程操作的时候，StringBuffer会比StringBuilder安全，但是其效率会偏低。</p>
<h3 id="13、-和-equals的区别"><a href="#13、-和-equals的区别" class="headerlink" title="13、 &#x3D;&#x3D; 和 equals的区别"></a>13、 &#x3D;&#x3D; 和 equals的区别</h3><p>=&#x3D; 既可以比较基本数据类型,也可以比较引用数据类型,比较基本数据类型,比较的是具体的值,比较引用数据类型比较是地址值。</p>
<p>equals只能比较引用数据类型,重写之前比较的是引用数据类型的地址值,重写之后,根据重自定义写的规则，比较的是引用数据类型的内容。</p>
<h3 id="14、包装类拆箱装箱"><a href="#14、包装类拆箱装箱" class="headerlink" title="14、包装类拆箱装箱"></a>14、包装类拆箱装箱</h3><p><strong>装箱：</strong> 将基本类型转换成包装类对象。 int -integer–int</p>
<p><strong>拆箱：</strong> 将包装类对象转换成基本类型的值。</p>
<p><strong>区别：</strong> 以int和Integer为例。</p>
<p>（1）Integer是int的包装类，int则是java的一种基本数据类型；</p>
<p>（2）Integer变量必须实例化后才能使用，而int变量不需要；</p>
<p>（3）Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值；</p>
<p>（4）Integer的默认值是null，int的默认值是0。</p>
<p>java为什么要引入自动装箱和拆箱的功能？主要是用于java集合中，List&lt;Inteter&gt;list&#x3D;new ArrayList&lt;Integer&gt;();</p>
<p>list集合如果要放整数的话，只能放对象，不能放基本类型，因此需要将整数自动装箱成对象。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.packing;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--08--31:14:45</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntAndIntegerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一组：两个Integer对象比较</span></span><br><span class="line">        <span class="comment">// 结论：两个对象比较 地址一定不等，则结果为false</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">66</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">66</span>);</span><br><span class="line">        System.out.println(integer == integer1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二组：Integer类型属性值和int属性值比较</span></span><br><span class="line">        <span class="comment">// 结论：包装类Integer和基本数据类型比较的时候，将包装类自动拆箱为int，然后进行比较，本质就是两个int变量进行比较，只要两个变量的值相等，则结果就为true</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">88</span>);</span><br><span class="line">        <span class="comment">//Integer a = 88;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line">        System.out.println(integer2 == i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 三组：new Integer()类型变量值和Integer类型的变量值比较</span></span><br><span class="line">        <span class="comment">// 结论：new Integer() 堆中地址 Integer 常量池中地址，地址不等</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">88</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line">        System.out.println(integer3 == j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四组：Integer类型的变量值和Integer类型的变量值(范围在：[-128~127]相等,)</span></span><br><span class="line">        <span class="comment">// 其它则不相等会创建新的Integer对象</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">129</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">129</span>;</span><br><span class="line">        System.out.println(k == l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15、异常结构图"><a href="#15、异常结构图" class="headerlink" title="15、异常结构图"></a>15、异常结构图</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Error和Exception的区别</span></span><br><span class="line">在Java中，Error和Exception都是表示程序运行过程中出现的问题。它们的主要区别在于：</span><br><span class="line">Error（错误）：表示程序无法处理的严重问题，通常是由系统内部错误引起的，如内存溢出、虚拟机错误等。Error通常不允许被捕获和处理，因为它们表示程序无法继续运行。</span><br><span class="line">Exception（异常）：表示程序可以处理的问题，通常是由程序逻辑错误或外部因素引起的，如文件不存在、空指针异常等。Exception可以被捕获和处理，以便程序能够恢复正常运行或者给出友好的错误提示。</span><br><span class="line">总结：Error是严重的问题，通常不需要程序员处理；Exception是可处理的问题，需要程序员根据具体情况进行处理。</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行时异常和非运行时异常区别</span></span><br><span class="line">运行时异常（RuntimeException）包括诸如空指针异常、数组越界等，这些通常是由程序逻辑错误引起的，并且可以被捕获和处理。程序员可以根据具体情况进行处理，以防止程序意外终止并恢复正常运行。</span><br><span class="line">非运行时异常则是在编译阶段就会被检测到的异常，例如文件找不到异常、输入输出异常等。这种异常如果未被捕获处理，将无法通过编译。Java编译器要求程序员必须对这种异常进行处理，因为Java认为这类异常都是可以被修复的。</span><br><span class="line">因此，运行时异常与非运行时异常的主要区别在于它们的触发时机和处理方式：运行时异常在程序运行时被触发，而非运行时异常在编译阶段就被检测并处理。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_n65MRvxzxu.png"></p>
<h3 id="16、-HashSet-的去重原理"><a href="#16、-HashSet-的去重原理" class="headerlink" title="16、 HashSet 的去重原理"></a>16、 HashSet 的去重原理</h3><p>如果两个对象的hashCode值不同，直接插入成功。<br>如果两个对象的hashCode值相同，再比较两个对象的地址值。如果地址值相同，即同一个对象，插入失败（无需继续判断）反之，则会继续调用equals方法比较，如果equals方法返回true，插入失败；如果equals方法返回false，插入成功。</p>
<p>理解：hashSet的键值存储设计</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet是Java中的一个集合类，它实现了Set接口。在HashSet的内部实现中，它维护了一个HashMap。当我们向HashSet中添加元素时，这些元素会被存储在HashMap的key中，而value则是一个固定的Object对象。这个固定的对象通常被称为PRESENT，它是一个private static final Object，定义了一个虚拟的Object对象作为HashMap的value。</span><br><span class="line"></span><br><span class="line">这样的设计背后的原因有以下几点：</span><br><span class="line">  简化代码：由于所有的value都是同一个对象，这使得HashSet的内部实现更加简单。</span><br><span class="line">  性能考虑：使用一个固定的Object对象作为value可以减少内存分配和垃圾回收的开销。</span><br><span class="line">  明确性：这种设计使得我们清楚地知道HashSet中的每个元素都是独立的，不会与其他元素关联。</span><br><span class="line">   </span><br><span class="line">值得注意的是，虽然HashSet的底层使用HashMap来支持其操作，但它们之间存在一些区别。例如，HashMap存储的是键值对（key-value），而HashSet其实也是存储的键值对，但是键值对的value是一个默认值。</span><br></pre></td></tr></table></figure>



<h3 id="17、集合与数组的区别"><a href="#17、集合与数组的区别" class="headerlink" title="17、集合与数组的区别"></a>17、集合与数组的区别</h3><p>集合与数组都是容器</p>
<p>数组既可以存基本数据类型也可以存引用数据类型,数组的长度固定不能发生改变</p>
<p>集合只能存引用数据类型,可以存任意的引用数据类型,长度可变</p>
<p>理解：各自场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组适合需要有序存储和快速访问数据的场景，而集合则适用于需要灵活添加、删除和修改元素的场景。</span><br></pre></td></tr></table></figure>



<h3 id="18、多线程的五种实现方式"><a href="#18、多线程的五种实现方式" class="headerlink" title="18、多线程的五种实现方式"></a>18、多线程的五种实现方式</h3><p>1, 继承Thread,重写run方法,最后创建Thread 的子类对象,调用start()方法开启线程任务</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.create;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do some  thing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2, 实现Runnable接口,重写run方法,创建Runnable 的实现类对象,通过Thread 的构造传递,调用start() 方法开启线程任务</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.create;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3, 实现Callable接口,重写call方法,创建Callable的实现类对象,将Callable 的实现类对象,传递到FutureTask的构造方法中,最后将FutureTask传递到Thread 的构造方法中,通过start()方法开启线程任务</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread_3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callable 和Runnable接口有什么区别</span></span><br><span class="line"><span class="comment"> * 1、Callable接口中也是一个函数式接口 里面拥有一个call方法</span></span><br><span class="line"><span class="comment"> * 2、Callable接口的call方法可以有返回值。</span></span><br><span class="line"><span class="comment"> * 3、Callable接口中的call方法可以抛异常（run()方法和call()方法都能抓异常）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// 抛异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 抓异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 抓异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、使用线程池创建</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread_4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如使用线程池工具类</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比如自定义线程池</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,TimeUnit.MINUTES,<span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、使用jdk1.8自带的异步编排方式</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.create;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread_5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用异步编排</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始执行一个任务&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>把控细节</strong>：其实不管是哪种方式创建，底层都是通过实现Runnable接口方式创建线程。</p>
<p><strong>值得注意的是</strong>，无论是通过哪种方式创建线程，底层都是依赖于操作系统的线程实现</p>
<p>理解：几种方式创建的有缺点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">继承Thread类并重写run()方法：这种方式的优点是编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法。但缺点是Java的单继承特性，一个类继承了Thread之后就不能再继承其它类了。同时，run方法不能有返回值并且不能抛出异常。</span><br><span class="line"></span><br><span class="line">实现Runnable接口并重写run()方法：这种方式可以避免Java中的单继承带来的问题，适合多个相同程序代码的线程去处理同一资源的情况。但不能获取到线程执行的结果。</span><br><span class="line"></span><br><span class="line">实现Callable接口并重写call()方法：与Runnable相比，它可以处理更复杂的数据类型，并且可以获取到线程执行的结果。但是，使用时比Runnable稍显复杂。</span><br><span class="line"></span><br><span class="line">使用线程池例如Executor框架来创建线程：这种方式是一种十分高效的线程管理方式，它可以根据系统资源和任务数量来创建适当数量的线程，很好地做到了节省和管理系统资源。但相比于前面的方式，使用线程池需要更多的配置和编码工作。</span><br></pre></td></tr></table></figure>



<h3 id="19、多线程的生命周期"><a href="#19、多线程的生命周期" class="headerlink" title="19、多线程的生命周期"></a>19、多线程的生命周期</h3><p>源码中一共定义了6钟状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_YqoM7Um4ux.png"></p>
<p>（1）新建（<em>NEW</em>）：线程对象刚给创建，但未启动（start）</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_New</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();<span class="comment">// 只要线程new出来</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程的名字&quot;</span>+thread.getName()+<span class="string">&quot;线程的状态:&quot;</span>+thread.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）可运行（<em>RUNNABLE</em>）：线程已被启动，可以被调度或正在被调度。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程的状态&quot;</span>+Thread.currentThread().getState());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程的状态&quot;</span>+thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）锁阻塞（<em>BLOCKED</em>）：当前线程要获取的锁对象正在被其他线程占用，此时该线程处于Blocked状态。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Blocked</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;11111&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        threadB.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span>+threadB.getName()+<span class="string">&quot;状态&quot;</span>+threadB.getState());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）等待阻塞（<em>WAITING</em>）：当前线程遇到了wait()，join()等方法。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Waiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用wait、notify或者notifyAll的时候必须要要结合synchronized使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;i---&quot;</span>+i);</span><br><span class="line">                        <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                            o.wait();<span class="comment">// 使用对象的wait方法时 必要要有一个对象和synchronized</span></span><br><span class="line">                            <span class="comment">// 如若不结合synchronized  那么就会出现一个监视器对象状态异常IllegalMonitorStateException。</span></span><br><span class="line">                            <span class="comment">// 任何一个对象中都有一个ObjectMonitor对象。监视器锁。管程技术。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="comment">//  o.notify();//使用notify或者notifyAll()都要结合synchronized使用，不然就会出现监视器异常IllegalMonitorStateException</span></span><br><span class="line">           <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;do some thing&quot;</span>);</span><br><span class="line">            o.notify();</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（5）限时等待（<em>TIMED_WAITING</em>）：当前线程调用了sleep(时间)，wait(时间)，join(时间)等方法。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_TimeWaiting</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 线程调用wait(5000)方法</span></span><br><span class="line">                  o.wait(<span class="number">5000</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 线程调用sleep(5000)方法</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// 线程调用join(5000)方法</span></span><br><span class="line">        thread.join(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）终止（<em>TERMINATED</em>）：线程正常结束或异常提前退出。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.thread.life;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Terminated</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        System.out.println(thread.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="20、TreeSet和HashSet的区别"><a href="#20、TreeSet和HashSet的区别" class="headerlink" title="20、TreeSet和HashSet的区别"></a>20、TreeSet和HashSet的区别</h3><p><strong>1、速度和内部实现</strong>：</p>
<p>HashSet 内部使用哈希表来存储元素，因此它的查找、插入和删除操作的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3049364903%7D" title="时间复杂度">时间复杂度</a>都是 O(1)。而 TreeSet 内部使用的是红黑树，因此它的时间复杂度为 O(logn)。</p>
<p><strong>2、排序方式：</strong></p>
<p>HashSet 不保证元素的顺序，因为它是根据哈希值来存储和检索元素的。而 TreeSet 则可以保证元素的顺序，因为它是根据元素的自然顺序或者比较器来进行排序的,默认是升序。</p>
<p><strong>3、接口：</strong></p>
<p>HashSet 实现了 Set 接口，而 TreeSet 实现了 SortedSet 接口。</p>
<p><strong>4 使用场景</strong>：</p>
<p>如果需要快速地插入、删除和查找元素，并且不关心它们的顺序，那么可以使用 HashSet。如果需要对元素进行比较、排序，那么可以使用 TreeSet。</p>
<h3 id="21、所学习的io流一共分为几类"><a href="#21、所学习的io流一共分为几类" class="headerlink" title="21、所学习的io流一共分为几类"></a>21、所学习的io流一共分为几类</h3><p>IO流根据流向 有输入流和输出流两种</p>
<p>IO流根据类型分类有 字节输入输出流 和 字符输入输出流 &#x20;</p>
<p>字节输入流  InputStream</p>
<p>字节输出流 OutputStream</p>
<p>字符输入流 Reader</p>
<p>字符输出流 Writer</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_IavBSdntFt.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_8OVV7Wdg-K.png"></p>
<p><strong>把控细节：</strong></p>
<p>字节流是万能流,可以处理任意的文件。</p>
<p>字符流不是万能流,基本上用来处理纯文本文件。</p>
<p>理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符流和字节流是Java中的两种主要I/O类，它们在处理数据时有着明显的区别。字符流主要是用于处理文本数据，它支持写入和读取Unicode码元。而字节流则主要用于处理二进制数据，不支持写入或读取Unicode码元。</span><br><span class="line"></span><br><span class="line">具体来说，字符流是以字符为单位进行数据传输的，一次可能读取多个字节的数据并将其转换为一个字符。相反，字节流则是以字节为单位进行数据传输，每次只读取一个字节的数据。</span><br><span class="line"></span><br><span class="line">此外，两者的处理方式也有所不同。字节流是一种按字节顺序存储和读取数据的方式，而字符流则是按照字符顺序存储和读取数据。因此，只要是处理纯文本数据，就优先考虑使用字符流，否则使用字节流。</span><br></pre></td></tr></table></figure>

<h3 id="22、map的三种遍历方式"><a href="#22、map的三种遍历方式" class="headerlink" title="22、map的三种遍历方式"></a>22、map的三种遍历方式</h3><p>方式一：增强for</p>
<p>方式二：EntrySet迭代</p>
<p>方式三：KeySet迭代</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.collect.map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--09--19:09:03</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapForDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;武汉市&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式一：增强for</span></span><br><span class="line">        <span class="comment">//for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;map的key:&quot;+entry.getKey()+&quot;,map的value:&quot;+entry.getValue());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 方式二：EntrySet迭代</span></span><br><span class="line">        <span class="comment">//Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span></span><br><span class="line">        <span class="comment">//Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span></span><br><span class="line">        <span class="comment">//while (iterator.hasNext()) &#123;</span></span><br><span class="line">        <span class="comment">//    Map.Entry&lt;String, String&gt; next = iterator.next();</span></span><br><span class="line">        <span class="comment">//    System.out.println(&quot;map的key:&quot; + next.getKey() + &quot;,map的value:&quot; + next.getValue());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：keySet迭代</span></span><br><span class="line">        Iterator&lt;String&gt; keySetIterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (keySetIterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keySetIterator.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;map的key:&quot;</span>+key+<span class="string">&quot;,map的value:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>理解：三种方式适合的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map有三种主要的遍历方式，各自适应不同的场景需求：</span><br><span class="line"></span><br><span class="line">遍历Map.entrySet()：这种方式的每个元素都是Map.Entry对象，其中包含了键值对（key-value）。当需要访问或操作每一个键值对时，这是最佳选择。例如，你可以很容易地获取每个条目的key和value。</span><br><span class="line"></span><br><span class="line">遍历Map.keySet()：这种方式通过遍历键的集合来访问Map中的元素。这在你需要基于键执行某些操作，而不需要关心对应的值的场景中很有用。</span><br><span class="line"></span><br><span class="line">遍历Map.values()：这种方式是通过遍历值的集合来访问Map中的元素。当你需要处理Map中所有的值，而不考虑其对应的键的场景中，这种方式很适用。</span><br></pre></td></tr></table></figure>





<h3 id="23、HashMap与HashTable-的区别"><a href="#23、HashMap与HashTable-的区别" class="headerlink" title="23、HashMap与HashTable 的区别"></a>23、HashMap与HashTable 的区别</h3><p><strong>（1</strong>）线程安全性不同</p>
<p>HashMap是线程不安全的，HashTable是线程安全的，其中的方法大多数是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理（Collections库中的synchronizedMap()方法）。</p>
<p><strong>HashMap:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_jmI6y9tfgf.png"></p>
<p><strong>HashTable:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_xgx1scpo4a.png"></p>
<p><strong>（2</strong>）是否提供<strong>contains</strong>方法</p>
<p>HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。</p>
<p><strong>HashMap:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_HEQ6q3lmDi.png"></p>
<p><strong>HashTable:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_T-9szbF4sx.png"></p>
<p><strong>（3</strong>）<strong>key</strong>和<strong>value</strong>是否允许<strong>null</strong>值</p>
<p>Hashtable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p>
<p><strong>HashMap:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_vTc6NXU7xi.png"></p>
<p><strong>HashTable:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_8F_nj6g8JV.png"></p>
<p><strong>（4</strong>）数组初始化和扩容机制</p>
<p><strong>初始化</strong>：HashTable在不指定容量的情况下的默认容量为11；而HashMap在不指定容量的时候，并不会提前构建指定长度大小的数组。而是当第一次put元素的时候才会去创建一个容量大小为16的数组，这点一定要注意！！！</p>
<p><strong>HashTable:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_DWoR0_oGl7.png"></p>
<p><strong>HashMap:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_aSPhBh5OM1.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5C2__ZlUqi0oMp.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5C3_DGOJNxeBsm.png"></p>
<p><strong>扩容</strong>：Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p>
<p><strong>HashMap:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_DvqppfWZih.png"></p>
<p><strong>HashTable:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5C4_nsQ8c6bYq6.png"></p>
<h3 id="24、ArrayList和LinkedList的区别"><a href="#24、ArrayList和LinkedList的区别" class="headerlink" title="24、ArrayList和LinkedList的区别"></a>24、ArrayList和LinkedList的区别</h3><p><strong>ArrayList</strong>：基于动态数组，连续内存存储，适合下标访问（随机访问），扩容机制：因为数组长度固定，超出长度存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动（往后复制一份，插入新元素），使用尾插法并指定初始容量可以极大提升性能、甚至超过linkedList（需要创建大量的node对象）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/image-20231227220844681.png" alt="image-20231227220844681"></p>
<p><strong>LinkedList</strong>：基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询：需要逐一遍历。遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通get(i)取得某一元素时都需要对list重新进行遍历，性能消耗极大。另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexlOf对list进行了遍历，当结果为空时会遍历整个列表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/image-20231227220901654.png" alt="image-20231227220901654"></p>
<h3 id="25、什么是反射"><a href="#25、什么是反射" class="headerlink" title="25、什么是反射"></a>25、什么是反射</h3><p><strong>什么是Java反射机制：</strong></p>
<p>反射就是在<strong>程序运行时期</strong>，动态的获取类信息并操作该类成员（构造方法，成员变量，成员方法）的过程，这种动态获取类的信息以及动态调用对象的方法的功能来自于Java 语言的反射。</p>
<p>Java的反射机制的实现要借助于4个类Class，Constructor，Field，Method;</p>
<p>其中Class代表的是类对象，Constructor－类的构造器对象，Field－类的属性对象，Method－类的方法对象。通过这四个对象我们可以粗略的看到一个类的各个组成部分。</p>
<p><strong>Java</strong> <strong>反射机制提供功能</strong></p>
<p>在运行时判断任意一个对象所属的类。</p>
<p>在运行时构造任意一个类的对象。</p>
<p>在运行时判断任意一个类所具有的成员变量和方法。</p>
<p>在运行时调用任意一个对象的方法。</p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.reflective;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--09--19:10:30</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取任意一个对象所属的类</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">            Class&lt;? <span class="keyword">extends</span> <span class="title class_">Student</span>&gt; aClass1 = student.getClass();</span><br><span class="line">            System.out.println(aClass1);</span><br><span class="line">            <span class="comment">//2.构造任意一个类对象</span></span><br><span class="line">            <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> aClass1.newInstance();</span><br><span class="line">            System.out.println(student1);</span><br><span class="line">            <span class="comment">//3.获取任意一个类中的构造方法</span></span><br><span class="line">            Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;se.reflective.Student&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : aClass.getDeclaredConstructors()) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">                System.out.println(instance);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 获取任意一个类中的方法</span></span><br><span class="line">            <span class="keyword">for</span> (Method declaredMethod : aClass.getDeclaredMethods()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Student类中的方法:&quot;</span> + declaredMethod.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//5. 获取任意一个类中的成员变量</span></span><br><span class="line">            <span class="keyword">for</span> (Field declaredField : aClass.getDeclaredFields()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Student类中的成员变量&quot;</span> + declaredField.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//6.调用任意一个对象的方法</span></span><br><span class="line">            System.out.println(student1.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>#理解：反射的场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java反射主要用在以下几种场景：</span><br><span class="line"></span><br><span class="line">框架开发：反射是许多流行框架（如Spring、Hibernate等）的基础，通过反射机制可以简化开发过程，提高代码的可重用性和扩展性。例如，Spring框架中的依赖注入（Dependency Injection）和动态代理（Dynamic Proxy）等功能就是通过反射实现的。</span><br><span class="line"></span><br><span class="line">动态代理：利用反射机制，可以在运行时动态生成代理类，从而实现对目标对象的代理访问。常见的应用场景如AOP编程（面向切面编程）。</span><br><span class="line"></span><br><span class="line">单元测试：反射能够帮助我们编写出能够对任意对象进行操作的测试代码，这在单元测试中非常有用。例如，JUnit框架就提供了一系列的反射API来支持其功能实现。</span><br><span class="line"></span><br><span class="line">动态装配：通过反射，我们可以在程序运行时动态地装载类，这对于实现插件化架构或者热部署等功能非常有用。</span><br><span class="line"></span><br><span class="line">服务任务调度：在一些复杂的业务场景中，服务任务的执行逻辑可能会根据前一个任务的执行结果而变化。这时候就可以利用反射来实现这种动态的任务调度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="26、深拷贝和浅拷贝"><a href="#26、深拷贝和浅拷贝" class="headerlink" title="26、深拷贝和浅拷贝"></a>26、深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。</p>
<p>1.浅拷贝是指，对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝。</p>
<p>2.深拷贝是指，对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_306ijJ6YzJ.png"></p>
<p><strong>浅拷贝例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.copy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--08--31:13:59</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Phone phone;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShallowCopy</span> &#123;</span><br><span class="line">    <span class="comment">// 浅拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        phone.setName(<span class="string">&quot;小米&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Person对象（原对象）</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;hzk&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置引用类型属性</span></span><br><span class="line">        person.setPhone(phone);</span><br><span class="line">        <span class="comment">// 打印原对象的属性值</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        System.out.println(person.getPhone());</span><br><span class="line">        System.out.println(person.getPhone().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 克隆一个Person对象(克隆对象)</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">copyPerson</span> <span class="operator">=</span> (Person) person.clone();</span><br><span class="line">        <span class="comment">// 打印克隆对象的属性值</span></span><br><span class="line">        System.out.println(copyPerson);</span><br><span class="line">        System.out.println(copyPerson.getName());</span><br><span class="line">        System.out.println(copyPerson.getPhone());</span><br><span class="line">        System.out.println(copyPerson.getPhone().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 浅拷贝由于会拷贝引用数据类型的地址，因此修改拷贝对象的值，其被拷贝对象的值也会跟着变化。反之，同理。</span></span><br><span class="line">        copyPerson.getPhone().setName(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原对象的引用类型Phone值&quot;</span> + person.getPhone().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象的引用类型Phone值&quot;</span> + copyPerson.getPhone().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5Cimage_voIXPNScw5.png"></p>
<p><strong>深拷贝例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--08--31:13:59</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone1 <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(Phone1 phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Phone1 phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"><span class="comment">//        return super.clone();</span></span><br><span class="line">        <span class="comment">//继续利用clone()方法，对该对象的引用类型变量再实现一次clone()方法。</span></span><br><span class="line">        <span class="comment">// 要想深克隆 要不就是序列化和反序列化 要不就是继续clone</span></span><br><span class="line">        <span class="type">Person1</span> <span class="variable">person</span> <span class="operator">=</span> (Person1) <span class="built_in">super</span>.clone();</span><br><span class="line">        person.setPhone((Phone1) person.getPhone().clone());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone1</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepCopy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Phone1</span> <span class="variable">phone1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone1</span>();</span><br><span class="line">        phone1.setName(<span class="string">&quot;小米&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person1</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line">        person1.setName(<span class="string">&quot;hzk&quot;</span>);</span><br><span class="line">        person1.setPhone(phone1);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);</span><br><span class="line">        System.out.println(person1.getName());</span><br><span class="line">        System.out.println(person1.getPhone());</span><br><span class="line">        System.out.println(person1.getPhone().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="type">Person1</span> <span class="variable">copyPerson1</span> <span class="operator">=</span> (Person1) person1.clone();</span><br><span class="line">        System.out.println(copyPerson1);</span><br><span class="line">        System.out.println(copyPerson1.getName());</span><br><span class="line">        System.out.println(copyPerson1.getPhone());</span><br><span class="line">        System.out.println(copyPerson1.getPhone().getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 深拷贝不会拷贝引用数据类型的地址（而是会创建一个新对象空间），因此修改拷贝对象的值，其被拷贝对象的值不会跟着变化。反之，同理。</span></span><br><span class="line">        copyPerson1.getPhone().setName(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;原对象的引用类型Phone值---&quot;</span> + person1.getPhone().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象的引用类型Phone值---&quot;</span> + copyPerson1.getPhone().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5CJAVASE%5Cimage%5C%E5%9B%BE%E7%89%87_HMK6d_wm1r.png"></p>
<p>理解：深拷贝和浅拷贝的作用和场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">深拷贝和浅拷贝在编程中都有重要的应用场景。</span><br><span class="line"></span><br><span class="line">深拷贝主要用于需要修改原对象但又不希望影响原对象的场景。例如，当您需要使用一个对象作为参数传递给函数，同时又不想因为这个函数内部对对象的修改而改变原对象时，就需要使用深拷贝来创建一个新的独立的对象副本。此外，当您从数据库中读取一些数据并想在此基础上做一些改动，但又希望保持原数据的完整性时，深拷贝也是一个理想的选择。</span><br><span class="line"></span><br><span class="line">相反，浅拷贝通常用于原始对象和拷贝对象需要共享相同数据的场景。例如，如果您有一个包含大量数据的对象，并且您只想复制该对象的一部分数据到另一个新的对象中，那么浅拷贝就非常适用，因为它只复制了对象的引用，而不是对象本身。此外，如果对象非常大，并且只需要偶尔进行修改，那么浅拷贝由于其较低的内存消耗可能会是更好的选择。</span><br><span class="line"></span><br><span class="line">总的来说，深拷贝和浅拷贝的选择取决于具体的应用场景和需求，理解它们的区别对于正确处理对象和数组的复制至关重要。</span><br></pre></td></tr></table></figure>



<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><h3 id="1、Java集合框架是什么-说出集合框架的一些优点"><a href="#1、Java集合框架是什么-说出集合框架的一些优点" class="headerlink" title="1、Java集合框架是什么?说出集合框架的一些优点?"></a>1、Java集合框架是什么?说出集合框架的一些优点?</h3><p>答：每种编程语言中都有集合，最初的Java版本包含几种集合类：Vector、Stack、HashTable和Arrays。随着集合的广泛使用，Java1.2提出了囊括所有集合接口和实现类、算法的集合框架。</p>
<p>在保证线程安全的情况下使用泛型和并发集合类，Java已经经历了很久。集合框架的部分优点如下：</p>
<p>(1)使用核心集合类降低开发成本，而非实现我们自己的集合类。</p>
<p>(2)使用经过严格测试的集合框架类，代码质量会得到提高。</p>
<p>(3)通过使用JDK附带的集合类，可以降低代码维护成本。</p>
<p>(4)复用性和可操作性。</p>
<h3 id="2、集合接口的常见实现类"><a href="#2、集合接口的常见实现类" class="headerlink" title="2、集合接口的常见实现类"></a>2、集合接口的常见实现类</h3><p>1、<strong>List接口的实现类</strong></p>
<p>List接口的实现类最常用的有ArrayList和LinkedList、Vector</p>
<p>ArrayList类实现了可变的数组，可以根据索引位置对集合进行快速的随机访问。</p>
<p>LinkedList类采用链表结构保存对象，便于向集合中插入和删除对象，但是如果将元素插入到集合的尾部，其实ArrayList原比LinkedList快。</p>
<p>Vector:也是List的一个常见实现类，但是在该类中的大多数方法都加了synchronized关键字，因此相比ArrayList、LinkedList集合在多线程访问时是线程的安全的。</p>
<p>2 <strong>、Set接口的实现类</strong></p>
<p>Set接口的实现类常用的有HashSet和TreeSet、LinkedHashSet。它们的元素都不可重复。</p>
<p>HashSet：底层是哈希表，遍历元素和添加顺序、大小顺序无关。</p>
<p>TreeSet：底层是红黑树，元素按照大小顺序存储和遍历。</p>
<p>LinkedHashSet：底层是哈希表+双链表，遍历元素可以体现添加时顺序。顺序性是体现和HashSet不同之处。</p>
<p><strong>3、Map接口的实现类</strong></p>
<p>Map接口的实现类常用的有HashMap、LinkedHashMap和TreeMap。它们的key都不可重复。这里面的key不可重复 <strong>，指的是容器中对于同一个Key只会存在一个。</strong></p>
<p>HashMap：哈希表，底层是数组+链表+红黑树。遍历元素和添加顺序、大小顺序无关。</p>
<p>LinkedHashMap：哈希表+双链表，遍历元素可以体现添加顺序。</p>
<p>TreeMap：红黑树，元素按照key大小顺序存储和遍历。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/image-20231228114945443.png" alt="image-20231228114945443"></p>
<p><strong>例子（example）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.collect.map;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--09--19:14:22</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;input          1 : 1     3 : 3     2 : 2     4 : 4     5 : 5&quot;</span>);</span><br><span class="line">        <span class="comment">//HashMap</span></span><br><span class="line">        Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">        hashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;HashMap        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : hashMap.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot; : &quot;</span> + hashMap.get(key) + <span class="string">&quot;     &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//LinkedHashMap</span></span><br><span class="line">        Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;LinkedHashMap  &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : linkedHashMap.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot; : &quot;</span> + linkedHashMap.get(key) + <span class="string">&quot;     &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//TreeMap</span></span><br><span class="line">        Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;String, String&gt;();</span><br><span class="line">        treeMap.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;TreeMap        &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String key : treeMap.keySet()) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">&quot; : &quot;</span> + treeMap.get(key) + <span class="string">&quot;     &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3、List和Map区别"><a href="#3、List和Map区别" class="headerlink" title="3、List和Map区别?"></a>3、List和Map区别?</h3><p>答：在数据结构方面，List存储的是单列数据的集合，而Map存储的是key、value类型的数据集合。在数据存储方面，List存储的数据是有序且可以重复的，而Map中存储的数据是无序（不同的子类也可以保证有序）且key值不会重复(value值可以重复)。</p>
<h3 id="4、List、Map、Set三个接口，存取元素时，各有什么特点"><a href="#4、List、Map、Set三个接口，存取元素时，各有什么特点" class="headerlink" title="4、List、Map、Set三个接口，存取元素时，各有什么特点?"></a>4、List、Map、Set三个接口，存取元素时，各有什么特点?</h3><p>List与Set具有相似性，它们都是单列元素的集合，所以，它们有一个共同的父接口，叫Collection。</p>
<p>Set里面不允许有重复（即相等）的元素。Set取元素时，没法说取第几个，只能通过for循环或者迭代器逐一遍历各个元素。</p>
<p>List表示有先后顺序的集合， 注意，不是那种按年龄、按大小、按价格之类的排序。当我们多次调用add(Object e)方法时，每次加入的对象就像火车站买票有排队顺序一样，按先来后到的顺序排序。有时候，也可以插队，即调用add(int index,Object e)方法，就可以指定当前对象在集合中的存放位置。一个对象可以被反复存储进List中，每调用一次add方法，这个对象就被插入进集合中一次，其实，并不是把这个对象本身存储进了集合中，而是在集合中用一个索引变量指向这个对象，当这个对象被add多次时，即相当于集合中有多个索引指向了这个对象。List除了通过迭代器逐一遍历各个元素，还可以调用get(index i)来明确说明取第几个。</p>
<p>Map与List和Set不同，它是双列的集合，用put方法存储一对key&#x2F;value，不能存储重复的key。取则可以根据key获得相应的value，即get(Object key)返回值为key 所对应的value。另外，也可以获得所有的key的集合(map.keySet())，还可以获得所有的value的结合(map.values())，还可以获得key和value组合成的Map.Entry对象的集合(map.entrySet())。</p>
<h3 id="5、为什么Map接口不继承Collection接口"><a href="#5、为什么Map接口不继承Collection接口" class="headerlink" title="5、为什么Map接口不继承Collection接口?"></a>5、为什么Map接口不继承Collection接口?</h3><p>首先Map提供的是键值对映射（即Key和value的映射），而collection提供的是一组数据（并不是键值对映射）。</p>
<p>其次如果map继承了collection接口，那么所有实现了map接口的类到底是用map的键值对映射数据还是用collection的一组数据呢（就我们平常所用的hashMap、hashTable、treeMap等都是键值对，所以它继承collection完全没意义），而且map如果继承了collection接口的话还违反了面向对象的<strong>接口分离原则</strong>。</p>
<h3 id="6、Iterator和ListIterator之间有什么区别"><a href="#6、Iterator和ListIterator之间有什么区别" class="headerlink" title="6、Iterator和ListIterator之间有什么区别?"></a>6、Iterator和ListIterator之间有什么区别?</h3><p>(1)我们可以使用Iterator来遍历Set和List集合，而ListIterator只能遍历List;</p>
<p>(2)Iterator只可以向前遍历，而LIstIterator可以双向遍历;</p>
<p>(3)ListIterator从Iterator接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> se.collect.list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.ListIterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2023--09--19:15:04</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListIteratorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正向遍历结果:&quot;</span>);</span><br><span class="line">        <span class="comment">// 正向遍历</span></span><br><span class="line">        ListIterator&lt;String&gt; listIterator = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(listIterator.next());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;反向遍历结果:&quot;</span>);</span><br><span class="line">        <span class="comment">// 反向遍历</span></span><br><span class="line">        <span class="keyword">while</span> (listIterator.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator.previous());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;插入元素：&quot;</span>);</span><br><span class="line">        <span class="comment">//插入元素</span></span><br><span class="line">        ListIterator&lt;String&gt; listIterator1 = list.listIterator();</span><br><span class="line">        listIterator1.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (listIterator1.hasPrevious()) &#123;</span><br><span class="line">            System.out.println(listIterator1.previous());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        ListIterator&lt;String&gt; listIterator2 = list.listIterator();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;替换元素:&quot;</span>);</span><br><span class="line">        <span class="comment">// 替换元素</span></span><br><span class="line">        <span class="keyword">while</span> (listIterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> listIterator2.next();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;5&quot;</span>.equals(next)) &#123;</span><br><span class="line">                listIterator2.set(<span class="string">&quot;155&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7、集合框架中的泛型有什么优点"><a href="#7、集合框架中的泛型有什么优点" class="headerlink" title="7、集合框架中的泛型有什么优点?"></a>7、集合框架中的泛型有什么优点?</h3><p><strong>类型安全：</strong></p>
<p>通过知道使用泛型定义的变量的类型限制，编译器可以在非常高的层次上验证类型假设。没有泛型，这些假设就只能在于程序员编码时候去考虑了。</p>
<p><strong>消除</strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020" title="强制类型转换"><strong>强制类型转换</strong></a><strong>：</strong></p>
<p>消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。</p>
<p><strong>更高的效率：</strong></p>
<p>在非泛型编程中，将筒单类型作为引用类型传递时会引起（装箱）和（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行装箱和拆箱操作了，所以运行效率相对较高。</p>
<h3 id="8、Map接口提供了哪些不同的集合视图"><a href="#8、Map接口提供了哪些不同的集合视图" class="headerlink" title="8、Map接口提供了哪些不同的集合视图?"></a>8、Map接口提供了哪些不同的集合视图?</h3><p>Map接口提供三个集合视图：</p>
<p>(1)Set keyset()：返回map中包含的所有key的一个Set视图。此Set集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个此Set集合时，若map被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为不确定。此Set集合支持元素查找和删除，从此Set中删除元素会从map中移除对应的映射，它不支持add和addAll添加操作。</p>
<p>(2)Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历此collection时，若map被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为不确定。此Collection集合支持元素查找和删除，从此Collection中删除元素会从map中移除对应的映射，它不支持add和addAll添加操作。</p>
<p>(3)Set entrySet()：返回一个map钟包含的所有映射的一个Set集合视图。这个Set集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历此Set集合时，若map被修改了(除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外)，迭代器的结果会变为未定义。此Set集合支持元素查找和删除，从此Set中删除元素会从map中移除对应的映射，它不支持add和addAll添加操作。</p>
<h3 id="9、jdk1-7HashMap"><a href="#9、jdk1-7HashMap" class="headerlink" title="9、jdk1.7HashMap"></a>9、jdk1.7HashMap</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5C%E9%9B%86%E5%90%88%E7%B1%BB%5Cimage%5C%E5%9B%BE%E7%89%87_iJH6LY605q.png"></p>
<p><strong>数据结构：数组+链表</strong></p>
<p><strong>put方法的流程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5C%E9%9B%86%E5%90%88%E7%B1%BB%5Cimage%5C%E5%9B%BE%E7%89%87_soZg5MHbr3.png"></p>
<p>理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">问题一：初始化大小选择2的幂方好处</span><br><span class="line">HashMap初始化为2的幂方主要是为了加快哈希计算以及减少哈希冲突。具体来说，当长度为2的整数次幂时，hash &amp; (length - 1) 的操作结果等于 hash % length。此外，HashMap在扩容时，如果是2的幂次方，只需要进行左移操作，这因为位操作的速度相对较快。</span><br><span class="line"></span><br><span class="line">问题二：处理key为null的情况</span><br><span class="line">注意：在Java中，null的哈希码是0</span><br><span class="line">HashMap 在存储 key 为 null 的数据时，会将该数据存储在一个特殊的桶中，这个桶被称为“null 桶”或“空桶”。</span><br><span class="line">具体来说，当使用 put() 方法插入一个 key 为 null 的数据时，HashMap 会先检查当前桶数组的长度是否为 0，如果是，则直接将该数据存储到数组的第一个位置上；如果不是，则会遍历整个桶数组，找到第一个空的位置，然后将该数据存储到该位置上。</span><br><span class="line">需要注意的是，由于 null 没有哈希码，因此无法通过哈希函数计算得到对应的桶位置。此外，如果多个键都为 null，它们会被存储在同一个桶中，因为它们的哈希码都是相同的。这种情况下，可以使用 containsKey() 方法来检查是否存在某个特定的 null 键。</span><br><span class="line"></span><br><span class="line">问题三：扩容</span><br><span class="line">HashMap中的threshold是指HashMap在进行扩容操作时的阈值，即当HashMap中的元素个数达到threshold时，HashMapHashMap中的threshold是指HashMap在进行扩容操作时的阈值，即当HashMap中的元素个数达到threshold时，HashMap会自动进行扩容操作。threshold的值为capacity * loadFactor，其中capacity是HashMap的容量，loadFactor是HashMap的负载因子。具体来说，当元素数量增加到阈值时，HashMap会创建一个新的桶数组，并将原来的元素重新计算哈希值后放入新的桶数组中</span><br><span class="line"></span><br><span class="line">问题四：hashcode值和hash()的区别</span><br><span class="line">在Java中，hashCode()是Object类的一个方法，而key的hash()方法是String类的一个方法。它们的主要区别在于：</span><br><span class="line">hashCode()方法是Java中的一个通用方法，用于获取对象的哈希码值。任何对象都可以调用这个方法来获取其哈希码值。而key的hash()方法是String类的一个特有方法，用于获取字符串的哈希码值。只有字符串对象才能调用这个方法来获取其哈希码值。</span><br><span class="line">对于同一个对象，如果不改变内部属性的话，每次调用hashCode()必须返回相同数值。这是因为如果每次调用返回不同的hashcode，那么每次在HashMap中寻找这个对象的时候，会找到其他桶去，从而判定错误。而hashCode的返回值，要尽可能的散列开来，意思是，尽量减少不同对象的哈希码值相同的可能性。</span><br><span class="line"></span><br><span class="line">在HashMap中，如果要找到某个元素，需要根据key的hash值来求得对应数组中的位置。这里的key可以是任何对象，因此我们需要使用对象的hashCode()方法来获取其哈希码值。而对于字符串类型的key，我们可以直接使用其自带的hash()方法来获取其哈希码值。</span><br></pre></td></tr></table></figure>





<h3 id="10、jdk1-8HashMap"><a href="#10、jdk1-8HashMap" class="headerlink" title="10、jdk1.8HashMap"></a><strong>10、jdk1.8HashMap</strong></h3><p><strong>数据结构：数组+链表+（红黑树）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5C%E9%9B%86%E5%90%88%E7%B1%BB%5Cimage%5C%E5%9B%BE%E7%89%87_CWy0BsWOt3.png"></p>
<p><strong>put方法流程：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E5%9F%BA%E7%A1%80%5C%E9%9B%86%E5%90%88%E7%B1%BB%5Cimage%5C%E5%9B%BE%E7%89%87_Reb-1ZPS9o.png"></p>
<p><strong>注意细节：</strong></p>
<p>HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。</p>
<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 treeifyBin方法。</p>
<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。</p>
<h3 id="11、JDK8中的HashMap为什么要使用红黑树？"><a href="#11、JDK8中的HashMap为什么要使用红黑树？" class="headerlink" title="11、JDK8中的HashMap为什么要使用红黑树？"></a>11、JDK8中的HashMap为什么要使用红黑树？</h3><p>当元素个数小于一个阈值时，链表整体的插入查询效率要高于红黑树，当元素个数大于此阈值时，链表整体的插入查询效率要低于红黑树。此阈值在HashMap中为8。</p>
<h3 id="12、JDK8中的HashMap什么时候将链表转化为红黑树？"><a href="#12、JDK8中的HashMap什么时候将链表转化为红黑树？" class="headerlink" title="12、JDK8中的HashMap什么时候将链表转化为红黑树？"></a>12、JDK8中的HashMap什么时候将链表转化为红黑树？</h3><p>这个题很容易答错，大部分答案就是：当链表中的元素个数大于8时就会把链表转化为红黑树。但是其实还有另外一个限制：当发现链表中的元素个数大于8之后，还会判断一下当前数组的长度，如果数组长度小于64时，此时并不会转化为红黑树，而是进行扩容。只有<strong>当链表中的元素个数大于8，并且数组的长度大于等于64</strong>时才会将链表转为红黑树。</p>
<p>上面扩容的原因是，如果数组长度还比较小，就先利用扩容来缩小链表的长度。</p>
<h3 id="13、JDK7与JDK8中HashMap的不同点？"><a href="#13、JDK7与JDK8中HashMap的不同点？" class="headerlink" title="13、JDK7与JDK8中HashMap的不同点？"></a>13、JDK7与JDK8中HashMap的不同点？</h3><ol>
<li>JDK8中使用了红黑树</li>
<li>JDK7中链表的插入使用的<strong>头插法</strong>（扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升），JDK8中链表使用的<strong>尾插法</strong>（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）</li>
<li>JDK7的Hash算法比JDK8中的更复杂，Hash算法越复杂，生成的hashcode则更散列，那么hashmap中的元素则更散列，更散列则hashmap的查询性能更好，JDK7中没有红黑树，所以只能优化Hash算法使得元素更散列，而JDK8中增加了红黑树，查询性能得到了保障，所以可以简化一下Hash算法，毕竟Hash算法越复杂就越消耗CPU。</li>
<li>扩容的过程中JDK7中有可能会重新对key进行哈希（重新Hash跟哈希种子有关系），而JDK8中没有这部分逻辑。</li>
<li>JDK8中扩容的条件和JDK7中不一样，除开判断size是否大于阈值之外，JDK7中还判断了table[i]是否为空，不为空的时候才会进行扩容，而JDK8中则没有该条件了。</li>
<li>JDK8中还多了一个API：putIfAbsent(key,value)</li>
<li>JDK7和JDK8扩容过程中转移元素的逻辑不一样，JDK7是每次转移一个元素，JDK8是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移。</li>
</ol>
<h3 id="14、jdk1-7ConcurrentHashMap"><a href="#14、jdk1-7ConcurrentHashMap" class="headerlink" title="14、jdk1.7ConcurrentHashMap"></a>14、jdk1.7ConcurrentHashMap</h3><p>jdk1.7ConcurrentHashMap底层是由两层嵌套数组来实现的：</p>
<ol>
<li>ConcurrentHashMap对象中有一个属性segments，类型为Segment[];</li>
<li>Segment对象中有一个属性table，类型为HashEntry[];</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap是Java中的一个线程安全的哈希表数据结构，它通过分割桶（Segment）来实现并发访问。ConcurrentHashMap的底层数据结构由数组、链表和红黑树组成，核心是基于数组实现的，为了解决哈希冲突，采用拉链法，于是引入了链表结构。为了解决链表过长，造成的查询性能下降，又引入了红黑树结构。</span><br><span class="line">ConcurrentHashMap的图解说明地址：</span><br><span class="line">		https://www.cnblogs.com/echola/p/11227689.html</span><br></pre></td></tr></table></figure>

<p><strong>put流程：</strong></p>
<p>1、当调用ConcurrentHashMap的put方法时，先根据key计算出对应的Segment[]的数组下标j，确定好当前key,value应该插入到哪个Segment对象中，如果segments[j]为空，则利用自旋锁的方式在j位置生成一个Segment对象。</p>
<p>2、然后调用Segment对象的put方法。</p>
<p>&#x20;  2.1 Segment对象的put方法会先加锁，然后也根据key计算出对应的HashEntry[]的数组下标i，然后将key,value封装为HashEntry对象放入该位置，此过程和JDK7的HashMap的put方法一样，然后解锁。</p>
<p>&#x20;  2.2 在加锁的过程中逻辑比较复杂，先通过自旋加锁，如果超过一定次数就会直接阻塞等等加锁。</p>
<p>理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在ConcurrentHashMap中，Segment是一个核心的内部类，它扮演着关键的角色。每个Segment实际上都是一个HashEntry类型的数组，这个数组中的每个元素都代表了一条链表的节点。</span><br><span class="line"></span><br><span class="line">Segment的主要特点包括：</span><br><span class="line"></span><br><span class="line">拥有独立的锁：每个Segment对象都拥有一个独立的锁，这可以确保在进行写操作时，只需锁定对应的Segment，而其他Segment的数据则可以被并行访问。</span><br><span class="line">实现了分段锁技术：通过使用段(Segment)将ConcurrentHashMap划分为不同的部分，ConcurrentHashMap就可以使用不同的锁来控制对哈希表的不同部分的修改，从而允许多个修改操作并发进行。</span><br><span class="line">结构复杂性：由于支持并发操作，因此Segment的实现相对复杂。整个ConcurrentHashMap就是由这些Segment组成的。</span><br><span class="line">总的来说，Segment是ConcurrentHashMap能够实现高效并发操作的关键因素之一。</span><br></pre></td></tr></table></figure>







<h3 id="15、jdk1-8ConcurrentHashMap"><a href="#15、jdk1-8ConcurrentHashMap" class="headerlink" title="15、jdk1.8ConcurrentHashMap"></a>15、jdk1.8ConcurrentHashMap</h3><p><strong>put流程：</strong></p>
<p>1、当向ConcurrentHashMap中put一个key,value时，首先根据key计算对应的数组下标i，如果该位置没有元素，则通过自旋的方法去向该位置赋值。如果该位置有元素，则synchronized会加锁</p>
<p>2、加锁成功之后，在判断该元素的类型。</p>
<p>2.1 如果是链表节点则进行添加节点到链表中</p>
<p>2.2 如果是红黑树则添加节点到红黑树</p>
<p>3、添加成功后，判断是否需要进行树化</p>
<p>4、addCount，这个方法的意思是ConcurrentHashMap的元素个数加1，但是这个操作也是需要并发安全的，并且元素个数加1成功后，会继续判断是否要进行扩容，如果需要，则会进行扩容，所以这个方法很重要。</p>
<p>5、同时一个线程在put时如果发现当前ConcurrentHashMap正在进行扩容则会去帮助扩容。</p>
<h3 id="16、jdk1-7ConcurrentHashMap如何保证并发"><a href="#16、jdk1-7ConcurrentHashMap如何保证并发" class="headerlink" title="16、jdk1.7ConcurrentHashMap如何保证并发"></a>16、jdk1.7ConcurrentHashMap如何保证并发</h3><p>主要利用Unsafe操作+ReentrantLock+分段思想。</p>
<p>主要使用了Unsafe操作中的：</p>
<ol>
<li>compareAndSwapObject：通过cas的方式修改对象的属性</li>
<li>putOrderedObject：并发安全的给数组的某个位置赋值</li>
<li>getObjectVolatile：并发安全的获取数组某个位置的元素</li>
</ol>
<p>分段思想是为了提高ConcurrentHashMap的并发量，分段数越高则支持的最大并发量越高，程序员可以通过concurrencyLevel参数来指定并发量。ConcurrentHashMap的内部类Segment就是用来表示某一个段的。</p>
<p>每个Segment就是一个小型的HashMap的，当调用ConcurrentHashMap的put方法是，最终会调用到Segment的put方法，而Segment类继承了ReentrantLock，所以Segment自带可重入锁，当调用到Segment的put方法时，会先利用可重入锁加锁，加锁成功后再将待插入的key,value插入到小型HashMap中，插入完成后解锁。</p>
<p>理解：cas原理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CAS，全称Compare-And-Swap，是一种无锁算法，被用于实现多线程同步的原子指令。它的基本操作逻辑是：如果内存位置的值与预期值相匹配，那么就将该位置的值更新为新值；否则，就不做任何操作，但是需要返回原来的值。因此，CAS的核心是“比较并替换”，这也是它的英文名称的由来。</span><br><span class="line"></span><br><span class="line">在Java中，CAS常常用于实现原子类，乐观锁的原理也是基于CAS来实现的。相对于使用互斥锁（synchronized或Lock）来说，CAS是一种轻量级的实现方案，因为它避免了线程阻塞和唤醒的开销，可以有效提高程序的执行效率。</span><br></pre></td></tr></table></figure>





<h3 id="17、jdk1-8ConcurrentHashMap如何保证并发"><a href="#17、jdk1-8ConcurrentHashMap如何保证并发" class="headerlink" title="17、jdk1.8ConcurrentHashMap如何保证并发"></a>17、jdk1.8ConcurrentHashMap如何保证并发</h3><p>主要利用Unsafe操作+synchronized关键字。</p>
<p>Unsafe操作的使用仍然和JDK7中的类似，主要负责并发安全的修改对象的属性或数组某个位置的值。</p>
<p>synchronized主要负责在需要操作某个位置时进行加锁（该位置不为空），比如向某个位置的链表进行插入结点，向某个位置的红黑树插入结点。</p>
<p>JDK8中其实仍然有分段锁的思想，只不过JDK7中段数是可以控制的，而JDK8中是数组的每一个位置都有一把锁。</p>
<p>理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap是Java中一个线程安全的哈希表实现，它通过以下几种方式来保证并发安全：</span><br><span class="line"></span><br><span class="line">分段锁技术：ConcurrentHashMap将数据分成多个段（Segment），每个段都是一个独立的哈希表。不同线程访问不同的段时，不需要加锁，从而提高了并发性能。当需要对整个ConcurrentHashMap进行操作时，只需要锁定整个对象即可。</span><br><span class="line"></span><br><span class="line">CAS无锁算法：ConcurrentHashMap在更新元素值时，使用了CAS（Compare and Swap）无锁算法，避免了使用传统的synchronized锁带来的性能开销。</span><br><span class="line"></span><br><span class="line">volatile关键字：ConcurrentHashMap中的一些变量使用了volatile关键字修饰，保证了多线程之间的可见性。</span><br><span class="line"></span><br><span class="line">分段计数器：ConcurrentHashMap中使用了一个分段计数器，用于记录每个段中元素的个数。这个计数器采用了原子操作，保证了并发安全性。</span><br><span class="line"></span><br><span class="line">综上所述，ConcurrentHashMap通过分段锁技术、CAS无锁算法、volatile关键字和分段计数器等方式来保证并发安全</span><br></pre></td></tr></table></figure>







<h1 id="Java高级-建议会"><a href="#Java高级-建议会" class="headerlink" title="Java高级-建议会"></a>Java高级-建议会</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="１、说一下JVM的主要组成部分？及其作用？"><a href="#１、说一下JVM的主要组成部分？及其作用？" class="headerlink" title="１、说一下JVM的主要组成部分？及其作用？"></a>１、说一下JVM的主要组成部分？及其作用？</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C1562481030796_jT_cKkOBdI.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_mM-c2odRAV.png"></p>
<p>**类加载器 (Class Loader) **：将.class字节码文件加载到内存中。类加载器只管加载，不管运行。只要符合文件结构就会加载。</p>
<p>**执行引擎（Execution Engine) ** ：也叫解释器，负责解释命令，其任务就是将<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020" title="字节码">字节码</a>指令解释&#x2F;编译为对应平台上的本地机器指令。</p>
<p><strong>本地接口（Native Interface）</strong>：本地接口。本地接口的作用是融合不同的语言为java所用。</p>
<p><strong>栈（Stack）</strong>：也叫栈内存，是java程序的运行区，用于存储<strong>局部变量表</strong>、<strong>操作栈</strong>、<strong>动态链接(即引用，比如方法区的成员变量)</strong>、<strong>方法出口等信息</strong>。<strong>它随着线程的创建而创建，随着线程结束而释放，只要线程一结束，该栈就结束；</strong> 对于栈来说不存在垃圾回收的问题(垃圾回收只针对于堆和方法区)。<strong>栈中的数据以栈帧的形式存在</strong>，是一个数据集，是一个有关方法和运行期数据的集合，当方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，执行完毕后，先弹出F2栈帧，再弹出F1栈帧，遵循“<strong>先进后出</strong>”原则。</p>
<p><strong>堆（Heap）</strong> <strong>：</strong> 存放的是实例对象。<strong>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的</strong>。**堆内存分三部分：<strong><strong>永久区</strong>（即存储的是运行环境必须的类信息，被装载至此区域的数据是不会被垃圾回收掉的，只有关闭jvm释放此区域所占用的内存）、<strong>新生区</strong></strong>、**<strong>老年代</strong></p>
<p><strong>方法区（Method Area）</strong>：方法区只是<strong>JVM规范</strong>中定义的一个概念，它用于存储已被虚拟机加载的类的信息（类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码缓存等。</p>
<p><strong>程序计数器（PC Register）</strong>：每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码（<strong>用来存储下一条将要执行的字节码指令的地址</strong>），由执行引擎读取下一条指令</p>
<h3 id="2、说一下JVM运行时数据区？"><a href="#2、说一下JVM运行时数据区？" class="headerlink" title="2、说一下JVM运行时数据区？"></a>2、说一下JVM运行时数据区？</h3><p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p>
<p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p>
<p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p>
<p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p>
<p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，存放对象实例</p>
<p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p>
<h3 id="3、什么是类加载器？"><a href="#3、什么是类加载器？" class="headerlink" title="3、什么是类加载器？"></a>3、什么是类加载器？</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
<p>类加载器分类：</p>
<ul>
<li><p>启动类加载器（Bootstrap）C++</p>
<p>负责加载$JAVA_HOME中jre&#x2F;lib&#x2F;下的某些jre包中的类【比如rt.jar】，该类加载器由C++实现，不是ClassLoader子类。</p>
</li>
<li><p>扩展类加载器（Extension）Java</p>
<p>负责加载java平台中<strong>扩展功能</strong>的一些jar包，包括$JAVA_HOME中jre&#x2F;lib&#x2F;ext&#x2F; *.jar或-Djava.ext.dirs指定目录下的jar包</p>
</li>
<li><p>应用程序类加载器（AppClassLoader）</p>
<p>也叫系统类加载器，负责加载<strong>classpath</strong>中指定的jar包及目录中class。或-Djava.class.path目录下的jar包或者.class文件。</p>
</li>
<li><p>用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式</p>
</li>
</ul>
<p>注意：各种类加载器之间存在着逻辑上的父子关系，但不是真正意义上的父子关系，因为它们直接没有从属关系。</p>
<h3 id="4、双亲委派模型"><a href="#4、双亲委派模型" class="headerlink" title="4、双亲委派模型"></a>4、双亲委派模型</h3><p>双亲委派机制是 Java 虚拟机加载一个类时为该类确定类加载器的一种机制。</p>
<p>简单的来说：如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。</p>
<p>具体的来说：例如有一个类 com.atguigu.classloader.Math需要加载，在双亲委派机制下流程是怎么样的呢？</p>
<ul>
<li>首先 <strong>应用类加载器</strong> 会判断之前是否加载过这个类，如果加载过则返回，如果没有加载过，则会<strong>向上</strong>委托给<strong>扩展类加载器</strong>；</li>
<li><strong>扩展类加载器</strong>同样会去判断之前是否加载过这个类，如果加载过则返回，如果没有加载过，则继续<strong>向上</strong>委托给 <strong>引导类加载器</strong>；</li>
<li><strong>引导类加载器</strong>则会去 jre&#x2F;lib 目录下去查询是否有这个类（注意：不会在问是否加载过），如果有这个类则加载，如果没有就<strong>向下回传</strong>给扩展类加载器加载； &#x20;</li>
<li><strong>扩展类加载器</strong>去 jre&#x2F;lib&#x2F;ext 目录下去查询是否有这个类，如果有这个类则加载，如果没有这个类就<strong>向下</strong>回传给应用类加载器；</li>
<li><strong>应用类加载器</strong>会去项目的类路径下 （classPath） 下去查询是否有这个类，如果有这个类则加载，如果没有这个类就会抛出经典的 <strong>ClassNotFoundException</strong>。</li>
</ul>
<p>流程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_Bm7nNYaxpd.png"></p>
<p>理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双亲委派机制的主要作用包括：</span><br><span class="line">1.防止重复加载同一个 .class 文件。通过委托的方式，如果一个类已经被加载过了，就不会再次被加载，从而保证了数据安全。</span><br><span class="line">2.保证核心 .class 文件不能被篡改。由于所有的类加载请求都需要经过父类加载器的检查，因此可以确保核心 .class 文件不会被篡改。即使有人尝试篡改，由于父类加载器不会加载被篡改的 .class 文件，所以即使加载了也不会是同一个 .class 对象。这样保证了 Class 的执行安全性。</span><br></pre></td></tr></table></figure>





<h3 id="５、说一下类装载的执行过程？"><a href="#５、说一下类装载的执行过程？" class="headerlink" title="５、说一下类装载的执行过程？"></a>５、说一下类装载的执行过程？</h3><p>类装载简单分为以下 5 个步骤：</p>
<p><strong>加载</strong>：根据查找路径找到相应的 class 文件然后导入；</p>
<p><strong>验证</strong>：检查加载的 class 文件的正确性；</p>
<p><strong>准备</strong>：给类中的静态变量分配内存空间；</p>
<p><strong>解析</strong>：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p>
<p><strong>初始化</strong>：对静态变量和静态代码块执行初始化工作。</p>
<p>细节过程理解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java类从加载到卸载出内存的整个生命周期可以分为七个阶段：加载、验证、准备、解析、初始化、使用和卸载。首先，java源文件通过java编译器编译成.class文件，也就是所说的字节码文件。然后，JVM虚拟机执行类的加载过程，这是类加载过程的第一个阶段。在这个阶段，JVM的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在JVM的方法区创建一个对应的Class对象，这个Class对象就是这个类各种数据的访问入口。</span><br><span class="line"></span><br><span class="line">具体来说，加载阶段之后是验证阶段，这一阶段的目的是确保加载的字节流符合Java虚拟机规范，并且不会危害虚拟机自身的安全。准备阶段则为类的静态变量分配存储空间，并设置默认初始值。解析阶段是将符号引用转换为直接引用的过程。初始化阶段则是真正执行类中定义的静态代码块和静态变量的初始化逻辑。</span><br><span class="line"></span><br><span class="line">使用阶段则是开始调用类的构造器创建对象和调用类的成员方法。最后是卸载阶段，当一个类不再被使用时，JVM会进行卸载操作。以上就是Java类从加载到卸载的整个过程。</span><br></pre></td></tr></table></figure>



<h3 id="６、怎么判断对象是否可以被回收？"><a href="#６、怎么判断对象是否可以被回收？" class="headerlink" title="６、怎么判断对象是否可以被回收？"></a>６、怎么判断对象是否可以被回收？</h3><p>一般有两种方法来判断：</p>
<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点<strong>不能解决循环引用的问题</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  Object instance=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigObject= <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        <span class="type">ReferenceCount</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCount</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可达性分析：</strong> 这个算法的基本思想就是通过一系列的称为**“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_X6HeANyTQ-.png"></p>
<h3 id="7、哪些对象可以作为GC-Roots"><a href="#7、哪些对象可以作为GC-Roots" class="headerlink" title="7、哪些对象可以作为GC-Roots"></a>7、哪些对象可以作为GC-Roots</h3><p>在Java语言中，可以作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中的常量引用的对象。</li>
<li>本地方法栈中JNI（Native方法）的引用对象</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_i-kPsui5EZ.png"></p>
<p>小技巧：</p>
<p>由于Root 采用栈方式存放指针，所以如果一个指针，它保存了堆里面的对象，但是自己又不存放在堆里面，那他就可以作为一个Root.</p>
<h3 id="8、Java中都有哪些引用类型？"><a href="#8、Java中都有哪些引用类型？" class="headerlink" title="8、Java中都有哪些引用类型？"></a>8、Java中都有哪些引用类型？</h3><p>强引用：发生 gc 的时候不会被回收。</p>
<p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
<p>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
<p>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。（临死之前收到一个通知）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jvm;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022--07--25:22:55</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        softReference();<span class="comment">// 软引用</span></span><br><span class="line">        weakReferenceTest();<span class="comment">// 弱引用</span></span><br><span class="line">        phantomReference();<span class="comment">// 虚引用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 软引用测试</span></span><br><span class="line"><span class="comment">     * 会发现gc后，软引用对象的值获仍然能够获取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">softReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzk 666!!!&quot;</span>);</span><br><span class="line">        SoftReference&lt;String&gt; stringSoftReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br><span class="line">        System.out.println(<span class="string">&quot;软引用的值&quot;</span> + stringSoftReference.get());<span class="comment">//没有进行gc前软引用能得到对象</span></span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        stringSoftReference.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象被垃圾回收了,软引用对象的值&quot;</span> + stringSoftReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弱引用测试</span></span><br><span class="line"><span class="comment">     * 会发现gc后，弱引用对象的值获取不到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">weakReferenceTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzk 666!!!&quot;</span>);</span><br><span class="line">        WeakReference&lt;String&gt; stringWeakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;软引用的值&quot;</span> + stringWeakReference.get());<span class="comment">//没有进行gc前软引用能得到对象</span></span><br><span class="line">        System.gc();<span class="comment">//进行垃圾回收</span></span><br><span class="line">        stringWeakReference.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象被垃圾回收了,软引用对象的值&quot;</span> + stringWeakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚引用测试</span></span><br><span class="line"><span class="comment">     * 会发现gc前，弱引用对象的值都获取不到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">phantomReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">helloWorldString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hzk 666!!!&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">        <span class="type">PhantomReference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(helloWorldString, queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        System.gc();<span class="comment">//进行垃圾回收</span></span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java中主要有四种引用方式：强引用、软引用、弱引用和虚引用，各自的使用场景如下：</span><br><span class="line"></span><br><span class="line">强引用是Java中最常见的引用方式。只要还有一个强引用指向一个对象，垃圾回收机制就不会回收这个对象。强引用适用于大部分情况，例如#对象的正常赋值操作。</span><br><span class="line"></span><br><span class="line">软引用是一种相对较强的引用。只有当JVM认为内存不足时，才会对被软引用关联的对象进行垃圾回收。因此，软引用通常用于一些需要缓存但并非关键数据的情况，例如#缓存大图片。</span><br><span class="line"></span><br><span class="line">弱引用的强度比软引用更弱。只要垃圾回收机制运行，无论JVM是否内存不足，都可能对被弱引用关联的对象进行回收。弱引用一般用于维护一些非必须的对象，例如#缓存大对象。</span><br><span class="line"></span><br><span class="line">虚引用是最弱的一种引用，它并不会决定对象的生命周期。虚引用主要用于跟踪对象被垃圾回收的状态或者在某些特殊需求下，例如#记录系统的运行状态或者监控对象的回收过程。</span><br></pre></td></tr></table></figure>



<h3 id="9、说一下JVM有哪些垃圾回收算法？"><a href="#9、说一下JVM有哪些垃圾回收算法？" class="headerlink" title="9、说一下JVM有哪些垃圾回收算法？"></a>9、说一下JVM有哪些垃圾回收算法？</h3><p><strong>标记复制算法：<strong><strong>该算法将内存</strong></strong>平均分成两部分****，然后每次只使用其中的一部分，当这部分内存满的时候，会将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。</strong> ​</p>
<p><strong>标记-清除算法：</strong> 1、使用可达性算法标记出需要回收的对象，且有根可达的就不会被标记清理。</p>
<p>&#x20;                              2、回收被标记的对象</p>
<p><strong>标记-整理算法：</strong> ​<strong>标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</strong></p>
<p><strong>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</strong></p>
<p>分代回收算法实际上是把复制算法和标记整理法的结合，并不是真正一个新的算法，一般分为：老年代（Old Generation）和新生代（Young Generation），老年代就是很少垃圾需要进行回收的，新生代就是有很多的内存空间需要回收，所以不同代就采用不同的回收算法，以此来达到高效的回收算法。</p>
<h3 id="10、说一下JVM有哪些垃圾回收器？"><a href="#10、说一下JVM有哪些垃圾回收器？" class="headerlink" title="10、说一下JVM有哪些垃圾回收器？"></a>10、说一下JVM有哪些垃圾回收器？</h3><p>理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收器的性能也是一个重要的评判标准，包括吞吐量和停顿时间等。吞吐量是指垃圾回收器在特定时间段内所能处理的对象数量，而停顿时间则是指在执行垃圾回收时，应用程序被暂停执行的时间。（stop the world）</span><br></pre></td></tr></table></figure>



<p>垃圾回收器总体分为三大类:</p>
<p><strong>串行：</strong></p>
<p>Serial、Serial Old、</p>
<p><strong>并行</strong>：</p>
<p>ParNew、Parallel、Parallel Old</p>
<p><strong>并发：</strong></p>
<p>CMS、G1</p>
<p>Serial：最早的单线程串行垃圾回收器。</p>
<p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的。</p>
<p>ParNew：是 Serial 的多线程版本。</p>
<p>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p>
<p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B&#x2F;S 系统。</p>
<p>G1：一种兼顾吞吐量和停顿时间的 GC 实现。</p>
<h3 id="11、详细介绍一下CMS垃圾回收器？"><a href="#11、详细介绍一下CMS垃圾回收器？" class="headerlink" title="11、详细介绍一下CMS垃圾回收器？"></a>11、详细介绍一下CMS垃圾回收器？</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
<p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><p>初始标记（CMS initial mark）</p>
</li>
<li><p>并发标记（CMS concurrent mark）</p>
</li>
<li><p>重新标记（CMS remark）</p>
</li>
<li><p>并发清理（CMS concurrent sweep）</p>
</li>
<li><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是枚举全部的GC Roots对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程【采用三色标记算法】，<strong>这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行</strong>。因为用户程序继续运行，可能会有导致已经<strong>标记过的对象状态发生改变</strong>。而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。并发清理这个阶段、清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活对象，因此这个阶段可以与用户线程同时发生。</p>
<p>初始标记：迄今为止在进行根节点枚举这一步骤都是需要暂停用户线程的，必须要保证在一个能够保证一致性的快照中得以进行。这里的一致性指的是，不会出现在分析过程中，根节点集合的对象的引用关系还在不断地变化。因为如果这点不能满足，那么分析结果就不能保证。</p>
<p>那么对于目前的Java应用来说，光是方法区的大小就有数百上千兆，里面的类或者常量更是恒河数沙，若是检查这里为起源的引用就需要消耗很多的时间，所以虚拟机自当是有办法直接得到哪些地方存在着对象的引用。在HotSpot虚拟机中，是使用的一组称为OopMap的数据结构来达存放这些引用。一旦类加载完成的时候，虚拟机就会把对象的偏移量数据计算出来。并且在JIT即时编译中也会在特定的位置记录下栈里的寄存器中存放哪些位置是引用。这样收集器在扫描的时候就可以得知这些信息了。并不需要真正的一个不漏的从方法区等GCROOT开始查找。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_HiGQG5FGqo.png"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面几个明显的缺点：</p>
<ul>
<li>对CPU资源敏感（会和服务抢资源，降低吞吐量）；当然，这是所有并发收集器的缺点</li>
<li>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾在本次收集中无法干掉他们，只能等到下一次gc再清理了，这一部分垃圾成为浮动垃圾)；</li>
<li>它使用的回收算法-<strong>“标记-清除”算法</strong>会导致收集结束时会有<strong>大量空间碎片</strong>产生</li>
</ul>
<p>同样由于垃圾收集阶段用户程序还需要持续运行，那就还需要预留足够的空间给用户线程使用，因此CMS垃圾回收器不能像其他的收集器那样等待老年代几乎完全被填满在进行垃圾收集。如果CMS运行期间预留的内存无法满足程序分配新对象的空间，就会出现并发失败。这时候虚拟机就启动默认的备预案，冻结用户线程，临时启用·重新对老年代的垃圾收集。这样就导致停顿时间很长了，性能反而降低。</p>
<h3 id="12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h3><p>新生代回收器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代回收器：Serial Old、Parallel Old、CMS整堆回收器：</p>
<p>G1新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</p>
<p>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>
<h3 id="13、简述分代垃圾回收器是怎么工作的？"><a href="#13、简述分代垃圾回收器是怎么工作的？" class="headerlink" title="13、简述分代垃圾回收器是怎么工作的？"></a>13、简述分代垃圾回收器是怎么工作的？</h3><p>分代回收器有两个分区：老年代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老年代的默认占比是 2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；清空 Eden 和 From Survivor 分区；From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老年代。大对象也会直接进入老年代。</p>
<p>老年代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<h3 id="14、垃圾回收器的比较"><a href="#14、垃圾回收器的比较" class="headerlink" title="14、垃圾回收器的比较"></a>14、垃圾回收器的比较</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_ccfAgNEr1S.png"></p>
<h3 id="15、三色标记"><a href="#15、三色标记" class="headerlink" title="15、三色标记"></a>15、三色标记</h3><p>所有的垃圾回收算法都要经历标记阶段。如果GC线程在标记的时候暂停所有用户线程（STW），那就没三色标记什么事了。但是这样会有一个问题，用户线程需要等到GC线程标记完才能运行，给用户的感觉就是很卡，用户体验很差。</p>
<p>现在主流的垃圾收集器都支持并发标记。什么是并发标记呢？就是标记的时候不暂停或少暂停用户线程，一起运行。这势必会带来三个问题：多标、漏标。垃圾收集器是如何解决这个问题的呢：三色标记+读写屏障。</p>
<p>把遍历对象过程中遇到的对象，按照“是否访问过”这个条件标记成三种颜色：</p>
<ul>
<li><strong>白色</strong>：尚未访问过。</li>
<li><strong>黑色</strong>：本对象已访问过，而且本对象 引用到 的其他对象 也全部访问过了。</li>
<li><strong>灰色</strong>：本对象已访问过，但是本对象 引用到 的其他对象 尚未全部访问完。全部访问后，会转换为黑色。</li>
</ul>
<p><strong>多标浮动垃圾：</strong></p>
<p>GC线程正在标记B，此时用户代码中A断开了对B的引用，但此时B已经被标记成了灰色，本轮GC不会被回收，这就是所谓的多标，多标的对象即成为浮动垃圾，躲过了本次GC。</p>
<p>多标对程序逻辑是没有影响的，唯一的影响是该回收的对象躲过了一次GC，造成了些许的内存浪费。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_0E4Q8ypraR.png"></p>
<p><strong>漏标 程序会出错</strong>：</p>
<p>漏标是如何产生的呢？GC把B标记完，准备标记B引用的对象，这时用户线程执行代码，代码中断开了B对D的引用，改为A对D的引用。但是A已经被标记成黑色，不会再次扫描A，而D还是白色，执行垃圾回收逻辑的时候D会被回收，程序就会出错了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E9%AB%98%E7%BA%A7%5CJVM%5Cimage%5C%E5%9B%BE%E7%89%87_3dnznkLoPV.png"></p>
<p><strong>如何解决漏标问题：</strong></p>
<p>先分析下漏标问题是如何产生的：</p>
<p>条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。</p>
<p>条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。</p>
<p>知道了问题所在就知道如何解决了。</p>
<h4 id="写屏障-增量更新（IU）"><a href="#写屏障-增量更新（IU）" class="headerlink" title="写屏障 + 增量更新（IU）"></a>写屏障 + 增量更新（IU）</h4><p>这种方式解决的是条件二，即通过写后屏障记录下更新，具体做法如下：</p>
<p>对象A对D的引用关系建立时，将D加入带扫描的集合中等待扫描</p>
<p>当对象A的成员变量的引用发生变化时，比如新增引用（a.d &#x3D; d），我们可以利用写屏障，将A新的成员变量引用对象D 记录下来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#写后</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> &#123;</span><br><span class="line"> remark_set.add(new_value); <span class="comment">// 记录新引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="写屏障-原始快照（SATB）"><a href="#写屏障-原始快照（SATB）" class="headerlink" title="写屏障 + 原始快照（SATB）"></a>写屏障 + 原始快照（SATB）</h4><p>这种方式解决的是条件一，带来的结果是依然能够标记到D，具体做法如下：</p>
<p>对象B的引用关系变动的时候，即给B对象中的某个属性赋值时，将之前的引用关系记录下来。</p>
<p>当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d &#x3D; null），我们可以利用写屏障，将B原来成员变量的引用 对象D记录下来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#写前 </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">pre_write_barrier</span><span class="params">(oop* field)</span> &#123;</span><br><span class="line"> <span class="type">oop</span> <span class="variable">old_value</span> <span class="operator">=</span> *field; <span class="comment">// 获取旧值</span></span><br><span class="line"> remark_set.add(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重标记的时候，扫描旧的对象图，这个旧的对象图即原始快照。</p>
<p>实际应用：</p>
<p>CMS：写屏障 + 增量更新</p>
<p>G1：写屏障 + SATB</p>
<h3 id="16、说一下JVM调优的工具？"><a href="#16、说一下JVM调优的工具？" class="headerlink" title="16、说一下JVM调优的工具？"></a>16、说一下JVM调优的工具？</h3><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p>
<p>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>
<h3 id="17、常用的JVM调优的参数都有哪些？"><a href="#17、常用的JVM调优的参数都有哪些？" class="headerlink" title="17、常用的JVM调优的参数都有哪些？"></a>17、常用的JVM调优的参数都有哪些？</h3><p>常用的JVM调优参数有很多，以下是一些常见的参数：</p>
<ol>
<li><code>-Xms</code>：设置JVM的初始堆大小。</li>
<li><code>-Xmx</code>：设置JVM的最大堆大小。</li>
<li><code>-Xss</code>：设置线程的栈大小。</li>
<li><code>-XX:NewRatio</code>：设置新生代和老年代的比例。</li>
<li><code>-XX:SurvivorRatio</code>：设置Eden区和Survivor区的比例。</li>
<li><code>-XX:MaxPermSize</code>（在JDK 8之前）或<code>-XX:MaxMetaspaceSize</code>（在JDK 8及以后）：设置永久代（或元空间）的最大大小。</li>
<li><code>-XX:ParallelGCThreads</code>：设置并行垃圾收集器的线程数。</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：启用并发标记清除垃圾收集器。</li>
<li><code>-XX:+UseG1GC</code>：启用G1垃圾收集器。</li>
<li><code>-XX:+UseSerialGC</code>：启用串行垃圾收集器。</li>
</ol>
<p>这只是一小部分常用的JVM调优参数，具体使用哪些参数需要根据应用程序的需求和环境进行调整。调优参数的选择和调整需要根据具体情况进行实验和评估。</p>
<h3 id="18、你能保证GC执行吗？"><a href="#18、你能保证GC执行吗？" class="headerlink" title="18、你能保证GC执行吗？"></a>18、你能保证GC执行吗？</h3><p>不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。</p>
<p>GC（垃圾收集）是由JVM自动管理的过程，它负责回收不再使用的内存资源。JVM根据一定的策略和算法来触发和执行GC操作。</p>
<p>虽然无法保证GC的执行，但是你可以通过调整JVM的参数和配置来影响GC的行为和性能。例如，可以调整堆大小、选择合适的垃圾收集器、调整GC线程数等来优化GC的性能和效果。</p>
<p>请注意，在进行GC调优时，需要仔细评估和测试不同的配置和参数，以确保在特定的应用程序和环境中获得最佳的性能和内存管理。</p>
<h3 id="19、怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#19、怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="19、怎么获取Java程序使用的内存？堆使用的百分比？"></a>19、怎么获取Java程序使用的内存？堆使用的百分比？</h3><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及 最大堆内存。</p>
<p>通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。 Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1-、什么是设计模式？有什么好处？"><a href="#1-、什么是设计模式？有什么好处？" class="headerlink" title="1 、什么是设计模式？有什么好处？"></a>1 、什么是设计模式？有什么好处？</h3><p>设计模式是一种被反复使用、经过验证的解决特定问题的软件设计思想。它是对软件设计中常见问题的一种抽象和总结，提供了一套经验丰富的解决方案。设计模式不是具体的实现代码，而是关于类和对象之间交互和组织的一种结构化的描述。</p>
<p>设计模式的好处如下：</p>
<ol>
<li>提高代码的重用性：设计模式通过提供通用的解决方案，可以使得代码更加可复用。它们通过抽象和封装常见的问题和解决方法，使得开发人员可以在不同的项目中重用已经验证的设计思想和实践。</li>
<li>提高代码的可维护性：设计模式通过将代码分离成不同的组件和层次，使得代码更模块化和可维护。它们提供了清晰的结构和约定，使得代码更易于理解、调试和修改。</li>
<li>提高软件的可扩展性：设计模式通过解耦、松散耦合和抽象等方式，使得软件系统更容易进行扩展和修改。它们使得系统的各个部分之间的依赖关系更加灵活，可以方便地添加新的功能和改变现有的实现。</li>
<li>提高团队协作效率：设计模式提供了一种共享的设计语言和思想，使得团队成员之间更容易理解和交流。它们可以作为团队共享的设计原则和规范，促进团队成员之间的合作和协作。</li>
<li>提高软件系统的可靠性：设计模式通过经过验证和优化的解决方案，减少了软件系统中的常见错误和问题。它们提供了一种结构化的方法和实践，可以帮助开发避免一些潜在的设计和实现问题。</li>
</ol>
<p>综上所，设计模式是一种被广泛应用的软件设计思想，通过提供通用的解决方案，提高了代码的重用性、可维护性、可扩展性和团队协作效率，同时也提高了软件系统的可靠性。</p>
<h3 id="2、-设计模式的7大基本原则有哪些？"><a href="#2、-设计模式的7大基本原则有哪些？" class="headerlink" title="2、 设计模式的7大基本原则有哪些？"></a>2、 设计模式的7大基本原则有哪些？</h3><p>设计模式的7大基本原则是指软件设计中的基本原则和准则，它们可以指导我们在使用设计模式时做出正确的设计决策。这些原则包括：</p>
<ol>
<li>单一职责原则（Single Responsibility Principle，SRP）：一个类只负责一项职责。一个类应该只有一个引起它变化的原因。</li>
<li>开放封闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。通过抽象和多态来实现对软件实体的扩展，而不是通过修改已有的代码。</li>
<li>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替换掉父类并且工作正常，子类必须能够完全替代父类的行为。</li>
<li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖它不需要的接口。类之间的依赖关系应该建立在最小的接口上。</li>
<li>迪米特法则（Law of Demeter，LoD）：一个对象应该对其他对象有尽可能少的了解。只与其直接的朋友进行通信，不需要了解朋友的朋友。</li>
<li>合成复用原则（Composite Reuse Principle，CRP）：尽量使用对象组合和聚合，而不是继承来达到复用的目的。通过组合已有的对象来实现新的功能。</li>
</ol>
<p>这些原则旨在指导我们进行良好的软件设计，提高软件的可读性、可维护性、可扩展性和可测试性。同时，它们也是设计模式的基础，设计模式的目的就是通过遵循这些原则来实现灵活、可复用和可扩展的软件系统。</p>
<h3 id="3-、使用哪种设计模式可以提高代码可维护性？"><a href="#3-、使用哪种设计模式可以提高代码可维护性？" class="headerlink" title="3 、使用哪种设计模式可以提高代码可维护性？"></a>3 、使用哪种设计模式可以提高代码可维护性？</h3><p>有多种设计模式可以提高代码的可维护性，以下是其中几种常见的设计模式：</p>
<ol>
<li>单一职责原则（Single Responsibility Principle，SRP）：将一个类或模块的功能限制在一个单一的责任范围内，避免功能的混杂和耦合，使得代码更容易理解和修改。</li>
<li>开放封闭原则（Open-Closed Principle，OCP）：通过抽象和多态来实现对软件实体的扩展，而不是通过修改已有的代码。这样可以避免修改已有代码带来的风险和影响，提高代码的可维护性。</li>
<li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们应该依赖于抽象。通过依赖注入等技术，将依赖关系从高层模块中抽离出来，使得代码更加灵活、可扩展和可维护。</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖它不需要的接口。通过定义细粒度的接口，可以避免接口的臃肿和不必要的依赖关系，提高代码的可维护性。</li>
<li>组合模式（Composite Pattern）：通过将对象组合成树状结构，使得客户端可以一致地处理单个对象和组合对象。这样可以减少代码的重复和冗余，提高代码的可维护性。</li>
<li>策略模式（Strategy Pattern）：将不同的算法封装为独立的策略对象，并通过组合和委托来实现运行时的动态算法选择。这样可以降低代码的复杂性，使得算法的变化和扩展更加容易。</li>
<li>观察者模式（Observer Pattern）：通过定义一种一对多的依赖关系，使得当一个对象状态发生变化时，所有依赖于它的对象都会得到通知和更新。这样可以减少对象之间的显式耦合，提高代码的可维护性。</li>
</ol>
<p>以上只是举例了几种常见的设计模式，实际上，许多设计模式都有助于提高代码的可维护性。选择合适的设计模式取决于具体的情况和需求，需要综合考虑项目的特点、团队的技术水平和开发成本等因素。</p>
<h3 id="4、-使用哪种设计模式可以提高代码的复用性？"><a href="#4、-使用哪种设计模式可以提高代码的复用性？" class="headerlink" title="4、 使用哪种设计模式可以提高代码的复用性？"></a>4、 使用哪种设计模式可以提高代码的复用性？</h3><p>设计模式中的许多模式都可以提高代码的复用性，以下是一些常用的设计模式，它们有助于代码的复用：</p>
<ol>
<li>工厂模式（Factory Pattern）：通过工厂类创建对象，将对象的创建与使用分离，提供了一种灵活的对象创建方式，方便代码复用和扩展。</li>
<li>单例模式（Singleton Pattern）：确保一个类只有一个实例，并提供全局访问点，可以在系统中复用同一个实例。</li>
<li>适配器模式（Adapter Pattern）：将一个类的接口转换成客户端所期望的另一个接口，使得原本不兼容的类可以一起工作，提高代码的复用性。</li>
<li>装饰器模式（Decorator Pattern）：动态地给一个对象添加额外的功能，通过装饰器类包装原始对象，可以在不修改原始对象的情况下进行功能扩展，提高代码的复用性。</li>
<li>观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都会得到通知，可以实现松耦合的对象之间的消息传递，提高代码的复用性。</li>
<li>策略模式（Strategy Pattern）：定义一系列算法，将每个算法封装起来，并使它们可以互换，使得算法可以独立于客户端变化，提高代码的复用性。</li>
<li>模板方法模式（Template Method Pattern）：定义一个算法的骨架，将一些步骤延迟到子类中实现，可以复用算法的结构，而具体的实现可以在子类中灵活变化。</li>
</ol>
<p>这只是一小部分常用的设计模式，每个设计模式都有不同的应用场景和优势。选择适合的设计模式可以提高代码的复用性、可维护性和扩展性。在实际开发中，根据具体需求和情况选择合适的设计模式是很重要的。</p>
<h3 id="5-、你在工作中是如何使用设计模式的？"><a href="#5-、你在工作中是如何使用设计模式的？" class="headerlink" title="5 、你在工作中是如何使用设计模式的？"></a>5 、你在工作中是如何使用设计模式的？</h3><p>在实际软件开发中，使用设计模式可以提高代码的可读性、可维护性和可扩展性，降低耦合度，增加代码的复用性。以下是一些常见的使用场景和设计模式示例：</p>
<ol>
<li>在面向对象的编程中，可以使用工厂模式来创建对象，将对象的创建与使用分离，提高代码的灵活性和可复用性。</li>
<li>当需要适配不兼容的接口时，可以使用适配器模式进行接口转换，使得原本不兼容的类可以一起工作。</li>
<li>如果需要在不修改原始对象的情况下动态地给对象添加额外的功能，可以使用装饰器模式。</li>
<li>当需要实现一对多的依赖关系，实现事件驱动的消息传递时，可以使用观察者模式。</li>
<li>在涉及多种算法选择和切换的情况下，可以使用策略模式来封装和切换不同的算法实现。</li>
<li>当需要定义一个算法的骨架，而将一些具体步骤延迟到子类中实现时，可以使用模板方法模式。</li>
</ol>
<p>这些只是一些示例，实际使用设计模式的情况会根据具体的需求和应用场景而有所不同。在软件开发中，根据具体问题的复杂性和需求的变化，选择合适的设计模式可以提高代码的质量和可维护性。</p>
<h3 id="6、单例模式的多种写法"><a href="#6、单例模式的多种写法" class="headerlink" title="6、单例模式的多种写法"></a>6、单例模式的多种写法</h3><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问点。以下是几种常见的单例模式的实现方式：</p>
<ol>
<li>懒汉式，线程不安全：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>懒汉式，线程安全：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>饿汉式：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>双重检查锁定：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>静态内部类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是几种常见的单例模式的实现方式。每种方式都有其优缺点，选择合适的实现方式取决于具体的需求和场景。需要考虑线程安全性、延迟加载、性能等方面的因素。</p>
<h3 id="7、-如何破坏单例模式？"><a href="#7、-如何破坏单例模式？" class="headerlink" title="7、 如何破坏单例模式？"></a>7、 如何破坏单例模式？</h3><p>破坏单例模式的方法主要有以下几种：</p>
<ol>
<li>反射破坏：通过反射机制，可以访问私有构造函数并创建多个实例。可以构造函数中添加逻辑来防止反射破坏单例模式。</li>
<li>序列化与反序列化破坏：当一个单例类被序列化后，再次反序列化会创建一个新的实例。可以通过在单例类中添加<code>readResolve()</code>方法，返回已有的实例，从而避免破坏。</li>
<li>多线程环境下的破坏：在多线程环境下，如果没有合适的同步机制，可能会创建多个实例。可以使用双重检查锁定或者静态内部类等线程安全的方式来防止破坏。</li>
<li>克隆破坏：如果单例类实现了<code>Cloneable</code>接口并重写了<code>clone()</code>方法，可以通过克隆对象创建多个实例。可以在<code>clone()</code>方法中抛出<code>CloneNotSupportedException</code>异常，阻止克隆破坏。</li>
</ol>
<p>破坏单例模式需要在特殊情况下有意识地使用上述方法，一般情况下，单例模式是为了保证全局唯一性和访问性，不建议破坏。</p>
<h3 id="8-、为什么说枚举是实现单例最好的方式？"><a href="#8-、为什么说枚举是实现单例最好的方式？" class="headerlink" title="8 、为什么说枚举是实现单例最好的方式？"></a>8 、为什么说枚举是实现单例最好的方式？</h3><p>枚举是实现单例模式最好的方式之一，原因如下：</p>
<ol>
<li>线程安全性：枚举实例的创建是由JVM在加载枚举类的时候保证的，因此在多线程环境下也能保证单例的唯一性。枚举的实例创建是线程安全的，无需担心并发访问导致的多实例问题。</li>
<li>反射安全性：枚举类的实例是在枚举类加载的时候被创建的，而且枚举类不支持通过反射来创建实例。即使使用反射强制访问枚举类的私有构造函数，也无法创建新的实例，因为枚举类的构造函数默认是私有的。</li>
<li>序列化安全性：枚举类默认实现了<code>java.io.Serializable</code>接口，因此可以安全地进行序列化和反序列化。枚举实例在序列化和反序列化过程中保持单例的状态，不会创建新的实例。</li>
<li>简洁性和可读性：使用枚举实现单例模式非常简洁，只需定义一个枚举类型，枚举值即为单例实例。同时，使用枚举实现的单例模式也更易于理解和维护。</li>
</ol>
<p>综上所述，由于枚举具有线程安全、反射安全、序列化安全以及简洁可读的特性，因此被认为是实现单例模式最好的方式之一。</p>
<h3 id="9-、不使用锁如何实现线程安全的单例？"><a href="#9-、不使用锁如何实现线程安全的单例？" class="headerlink" title="9 、不使用锁如何实现线程安全的单例？"></a>9 、不使用锁如何实现线程安全的单例？</h3><p>除了使用如双重检查锁定）来实现线程安全的单例模式，还有其他几种方式可以实现线程安全的单例，而不需要使用锁。以下是其中两种常见的方式：</p>
<ol>
<li>饿汉式：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在饿汉式中，单例实例在类加载时就被创建，因此不存在并发访问的问题。由于实例的创建是在静态初始化阶段完成的，所以可以保证线程安全性。</p>
<ol>
<li>静态内部类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在静态内部类中，单例实例的创建是在调用 <code>getInstance()</code> 方法时进行的，利用了类加载的特性实现了懒加载。由于静态内部类只有在被使用时才会被加载，所以</p>
<p>也能保证线程安全性。</p>
<p>这些方式都不需要显式地使用锁，因此可以避免锁带来的性能开销。不过需要注意的是，这些方式在某些特殊情况下（如序列化、反射等）可能仍然存在安全问题，需要进行适当的处理来防止破坏单例模式。</p>
<h3 id="10、什么是享元模式，有哪些具体应用？"><a href="#10、什么是享元模式，有哪些具体应用？" class="headerlink" title="10、什么是享元模式，有哪些具体应用？"></a>10、什么是享元模式，有哪些具体应用？</h3><p>享元模式（Flyweight Pattern）是一种结构型设计模式，其目的是通过共享对象来减少内存使用和提高性能。享元模式通过将对象的状态划分为内部状态（Intrinsic State）和外部状态（Extrinsic State），来实现对象的共享。</p>
<p>具体用场景和示例：</p>
<ol>
<li>文字编辑器：在文字编辑器中，每个字符都是一个对象，但是字符的属性（如字体、颜色等）可以作为内部状态进行共享，而文字的位置等属性可以作为外部状态进行传递。</li>
<li>线程池：在线程池中，每个线程对象可以看作是一个享元对象，线程的内部状态（如线程ID、状态标识等）是可以共享的，而外部状态（如任务）是不同的，通过外部传入。</li>
<li>资源池：在数据库连接池、连接池等资源管理中，可以使用享元模式来共享和复用资源对象，提高资源的利用率。</li>
<li>游戏中的角色：在游戏中，角色的外观、动作等可以作为内部状态进行共享，而角色的位置、血量等信息可以作为外部状态。</li>
</ol>
<p>总的来说，享元模式适用于存在大量细粒度对象的场景，通过共享内部状态来减少对象的开销，提高系统的性能和资源利用率。</p>
<h1 id="Java框架-–必会100"><a href="#Java框架-–必会100" class="headerlink" title="Java框架 –必会100%"></a>Java框架 –必会100%</h1><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><h3 id="1、Mybatis中-和-的区别？"><a href="#1、Mybatis中-和-的区别？" class="headerlink" title="1、Mybatis中#和$的区别？"></a>1、Mybatis中#和$的区别？</h3><p>在MyBatis中，<code>#</code>和<code>$</code>是两种不同的参数占位符使用方式。</p>
<ol>
<li><p><code>#</code>占位符：<code>#</code>占位符是使用预编译的方式进行参数传递。在SQL语句中，使用<code>#</code>可以将参数值安全地替换到SQL语句中，并自动进行参数类型转换和防止SQL注入攻击。使用<code>#</code>占位符时，MyBatis会将参数值作为一个整体传递给数据库，因此可以有效地防止SQL注入问题。</p>
<p>例如：</p>
<p><code>SELECT * FROM users WHERE id = #&#123;userId&#125;</code>&#x20;</p>
<p>在上述示例中，<code>#&#123;userId&#125;</code>会被替换为具体的参数值，并且会根据参数类型进行合适的转换。</p>
</li>
<li><p><code>$</code>占位符：<code>$</code>占位符是使用字符串拼接的方式进行参数传递。在SQL语句中，使用<code>$</code>可以将参数值直接拼接到SQL语句中，不进行预编译和参数类型转换。使用<code>$</code>占位符时，需要注意潜在的安全风险，因为参数值直接拼接到SQL语句中，可能会导致SQL注入攻击。</p>
<p>例如：</p>
<p><code>SELECT * FROM users WHERE id = $&#123;userId&#125;</code>&#x20;</p>
<p>在上述示例中，<code>$&#123;userId&#125;</code>会被替换为具体的参数值，但不会进行参数类型转换和安全检查。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>使用<code>#</code>占位符可以提供更安全和可靠的参数传递方式，适用于大多数情况。</li>
<li>使用<code>$</code>占位符可以提供更灵活的参数传递方式，但需要注意安全性和潜在的SQL注入问题。</li>
</ul>
<p>在选择使用<code>#</code>还是<code>$</code>时，需要根据具体的需求和安全考虑来决定。一般来说，推荐使用<code>#</code>占位符，除非有特殊的需求需要使用<code>$</code>占位符。</p>
<h3 id="2、Mybatis的编程步骤是什么样的？"><a href="#2、Mybatis的编程步骤是什么样的？" class="headerlink" title="2、Mybatis的编程步骤是什么样的？"></a>2、Mybatis的编程步骤是什么样的？</h3><p>● 创建SqlSessionFactory</p>
<p>● 通过SqlSessionFactory创建SqlSession</p>
<p>● 通过sqlsession执行数据库操作</p>
<p>● 调用session.commit()提交事务</p>
<p>● 调用session.close()关闭会话</p>
<h3 id="3、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#3、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="3、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>3、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><p>JDBC编程在某些方面存在一些不足之处，而MyBatis通过提供一种更高级的抽象层来解决这些问题。以下是JDBC编程的一些不足之处以及MyBatis是如何解决这些问题的：</p>
<ol>
<li><strong>繁琐的代码</strong>：JDBC编程需要编写大量的重复代码，包括连接数据库、创建和释放资源、处理结果集等。这使得代码冗长、难以维护和理解。<ul>
<li>MyBatis通过提供一个简洁的配置文件和映射文件，将数据库操作的细节抽象出来，使得开发者只需关注SQL语句和参数映射，大大减少了繁琐的代码量。</li>
</ul>
</li>
<li><strong>SQL与Java代码的耦合</strong>：在JDBC编程中，SQL语句通常直接嵌入在Java代码中，导致SQL与Java代码紧密耦合，不易于维护和修改。<ul>
<li>MyBatis使用了面向SQL的思想，将SQL语句与Java代码分离，通过映射文件将SQL语句与Java对象进行映射，使得SQL与Java代码解耦，提高了代码的可维护性和可读性。</li>
</ul>
</li>
<li><strong>手动参数设置和结果集处理</strong>：在JDBC编程中，需要手动设置参数并处理结果集，包括类型转换、结果集遍历等，增加了开发的工作量和出错的可能性。<ul>
<li>MyBatis通过提供参数映射和结果集映射的功能，自动处理参数设置和结果集转换，开发者只需定义映射关系，MyBatis会自动完成参数设置和结果集处理，简化了开发过程。</li>
</ul>
</li>
<li><strong>缺乏对象关系映射（ORM）支持</strong>：JDBC编程需要手动将数据库查询结果映射到Java对象中，缺乏对对象关系映射的支持，增加了开发的复杂性。<ul>
<li>MyBatis提供了强大的对象关系映射（ORM）功能，可以将查询结果自动映射到Java对象中，支持一对一、一对多、多对一等复杂的关系映射，简化了数据操作的过程。</li>
</ul>
</li>
<li><strong>缺乏缓存支持</strong>：JDBC编程没有内置的缓存机制，每次查询都需要访问数据库，降低了性能。<ul>
<li>MyBatis提供了一级缓存和二级缓存的支持。一级缓存是在同一个会话中的缓存，可以减少对数据库的访问；二级缓存是在多个会话中的缓存，可以共享缓存结果，提高了查询性能。</li>
</ul>
</li>
</ol>
<p>总的来说，MyBatis通过提供简洁的配置和映射文件、解耦SQL与Java代码、自动处理参数和结果集、支持对象关系映射和缓存等功能，弥补了JDBC编程的不足之处，提供了更便捷、高效和可维护的数据库访问解决方案。</p>
<h3 id="4、使用MyBatis的mapper接口调用时有哪些要求？"><a href="#4、使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="4、使用MyBatis的mapper接口调用时有哪些要求？"></a>4、使用MyBatis的mapper接口调用时有哪些要求？</h3><p>● Mapper接口方法名和mapper.xml中定义的每个sql的id相同</p>
<p>● Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同</p>
<p>● Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</p>
<p>● Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h3 id="5、Mybatis中一级缓存与二级缓存？"><a href="#5、Mybatis中一级缓存与二级缓存？" class="headerlink" title="5、Mybatis中一级缓存与二级缓存？"></a>5、Mybatis中一级缓存与二级缓存？</h3><p>在 MyBatis 中，存在一级缓存和二级缓存两种缓存机制。</p>
<ol>
<li>一级缓存：<ul>
<li>一级缓存是 MyBatis 默认开启的缓存机制，也被称为本地缓存。</li>
<li>一级缓存的作用范围是在同一个 SqlSession 内部，即在同一个会话期间，多次执行相同的查询语句，第一次查询结果会被缓存到一级缓存中，后续的查询会直接从缓存中获取结果，而不再去查询数据库。</li>
<li>一级缓存是基于对象引用的方式实现的，因此在同一个会话期间，如果对查询结果进行了修改（例如更新、插入、删除等操作），则会清空一级缓存，以保证数据的一致性。</li>
</ul>
</li>
<li>二级缓存：<ul>
<li>二级缓存是 MyBatis 的全局缓存机制，作用范围是在同一个 Mapper 的 namespace 中，即多个 SqlSession 共享同一个 Mapper 的缓存。</li>
<li>二级缓存可以跨越多个会话，当多个会话执行相同的查询语句时，第一个会话的查询结果会被缓存到二级缓存中，后续的会话可以直接从缓存中获取结果，而不再去查询数据库。</li>
<li>二级缓存是基于序列化的方式实现的，因此要求缓存的对象必须是可序列化的。</li>
<li>默认情况下，二级缓存是关闭的，需要在 Mapper 的配置文件中显式配置开启。</li>
</ul>
</li>
</ol>
<p>需要注意的是：</p>
<ul>
<li>一级缓存和二级缓存是独立的，互不影响。</li>
<li>二级缓存是可选的，可以根据需要选择是否开启。</li>
<li>二级缓存的使用需要注意数据的一致性和并发访问的问题，特别是在多线程环境下。</li>
</ul>
<p>总结： &#x20;<br>一级缓存是在同一个会话期间的缓存，而二级缓存是在同一个 Mapper 的命名空间中的缓存。一级缓存是默认开启的，二级缓存是可选的。在实际应用中，可以根据需求选择合适的缓存机制来提高查询性能。</p>
<p>理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一级缓存指的就是sqlsession，在sqlsession中有一个数据区域，是map结构，这个区域就是一级缓存区域。</span><br><span class="line">一级缓存中的key是由sql语句、条件、statement等信息组成一个唯一值。</span><br><span class="line">一级缓存中的value，就是查询出的结果对象。</span><br><span class="line">二级缓存指的就是同一个namespace下的mapper</span><br><span class="line">二级缓存中，也有一个map结构。具体的结构和一级缓存是一样的，key和value的结构都相同。</span><br><span class="line">但是生命周期比一级缓存的生命周期要长。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6、MyBatis在insert插入操作时如何返回主键ID？"><a href="#6、MyBatis在insert插入操作时如何返回主键ID？" class="headerlink" title="6、MyBatis在insert插入操作时如何返回主键ID？"></a>6、MyBatis在insert插入操作时如何返回主键ID？</h3><p>在 MyBatis 中，可以通过以下几种方式来获取插入操作后生成的主键 ID：</p>
<ol>
<li><p>使用数据库的自增主键：</p>
<ul>
<li>如果你的表使用了数据库的自增主键（如 MySQL 的 AUTO_INCREMENT），则在执行插入操作后，可以通过 <code>SELECT LAST_INSERT_ID()</code> 来获取最后插入的主键 ID。</li>
<li>在 MyBatis 的映射文件（Mapper XML）中，可以使用 <code>&lt;selectKey&gt;</code> 元素来配置获取主键的语句，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;Long&quot; order=&quot;AFTER&quot;&gt;</span><br><span class="line">    SELECT LAST_INSERT_ID()</span><br><span class="line">  &lt;/selectKey&gt;</span><br><span class="line">  INSERT INTO user (username, password) VALUES (#&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在执行插入操作后，MyBatis 会自动执行 <code>&lt;selectKey&gt;</code> 中配置的语句，并将获取到的主键值设置到对应的属性（<code>keyProperty</code>）中。</li>
</ul>
</li>
<li><p>使用数据库的序列（Sequence）：</p>
<ul>
<li>如果你的表使用了数据库的序列（如 Oracle 的序列），则可以通过调用序列的 <code>NEXTVAL</code> 函数来获取下一个序列值作为主键 ID。</li>
<li>在 MyBatis 的映射文件中，可以使用 <code>&lt;selectKey&gt;</code> 元素来配置获取序列值的语句，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;User&quot;&gt;</span><br><span class="line">  &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;Long&quot; order=&quot;BEFORE&quot;&gt;</span><br><span class="line">    SELECT user_seq.NEXTVAL FROM DUAL</span><br><span class="line">  &lt;/selectKey&gt;</span><br><span class="line">  INSERT INTO user (id, username, password) VALUES (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在执行插入操作前，MyBatis 会先执行 <code>&lt;selectKey&gt;</code> 中配置的语句，并将获取到的序列值设置到对应的属性（<code>keyProperty</code>）中。</li>
</ul>
</li>
<li><p>使用数据库的触发器（Trigger）：</p>
<ul>
<li>如果你的表使用了数据库的触发器，在触发器中可以获取插入操作后生成的主键 ID，并将其设置到对应的列中。</li>
<li>在 MyBatis 中，执行插入操作后，可以通过查询插入的记录来获取主键 ID，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 执行插入操作</span><br><span class="line">sqlSession.insert(&quot;insertUser&quot;, user);</span><br><span class="line"></span><br><span class="line">// 获取插入后的主键 ID</span><br><span class="line">Long id = user.getId();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>根据你所使用的数据库和表的配置，选择适合的方式来获取插入操作后的主键 ID。</p>
<h3 id="7、简述-Mybatis-的插件运行原理，如何编写一个插件"><a href="#7、简述-Mybatis-的插件运行原理，如何编写一个插件" class="headerlink" title="7、简述 Mybatis 的插件运行原理，如何编写一个插件"></a>7、简述 Mybatis 的插件运行原理，如何编写一个插件</h3><p>答： Mybatis 只支持针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这4 种接口的插件， Mybatis 使用 JDK 的动态代理， 为需要拦截的接口生成代理对象以实现接口方法拦截功能， 每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的invoke() 方法， 拦截那些你指定需要拦截的方法。</p>
<p>编写插件： 实现 Mybatis 的 Interceptor 接口并复写 intercept()方法， 然后在给插件编写注解， 指定<br>要拦截哪一个接口的哪些方法即可， 在配置文件中配置编写的插件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args =</span></span><br><span class="line"><span class="meta">&#123;Statement.class, ResultHandler.class&#125;),</span></span><br><span class="line"><span class="meta">@Signature(type = StatementHandler.class, method = &quot;update&quot;, args =</span></span><br><span class="line"><span class="meta">&#123;Statement.class&#125;),</span></span><br><span class="line"><span class="meta">@Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;</span></span><br><span class="line"><span class="meta">Statement.class &#125;)&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">invocation.proceed()执行具体的业务逻辑</span><br></pre></td></tr></table></figure>

<p>理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这段代码是一个Java注解，用于拦截和处理数据库操作。它使用了Spring框架的AOP（面向切面编程）功能。下面是对这段代码的解释：</span><br><span class="line"></span><br><span class="line">@Intercepts：这是一个自定义注解，用于定义拦截器的行为。</span><br><span class="line">@Signature：这是一个自定义注解，用于指定拦截的方法签名。</span><br><span class="line">type = StatementHandler.class：表示拦截的目标类型是StatementHandler类。</span><br><span class="line">method = &quot;query&quot;、method = &quot;update&quot;、method = &quot;batch&quot;：表示拦截的方法名分别为&quot;query&quot;、&quot;update&quot;和&quot;batch&quot;。</span><br><span class="line">args = &#123;Statement.class, ResultHandler.class&#125;：表示拦截的方法参数类型为Statement和ResultHandler。</span><br><span class="line">@Component：表示将这个类作为Spring组件进行管理。</span><br><span class="line">invocation.proceed()：表示在拦截到方法调用后，执行具体的业务逻辑。</span><br><span class="line">这段代码的作用是在执行数据库查询、更新或批量操作时，拦截并添加额外的逻辑。通过使用@Intercepts注解，可以定义多个拦截规则，每个规则对应一个或多个方法签名。当拦截到符合条件的方法调用时，会执行invocation.proceed()方法，即执行具体的业务逻辑。</span><br><span class="line"></span><br><span class="line">请注意，这只是代码片段的一部分，无法直接运行。要完整地理解这段代码的功能，需要结合完整的上下文和项目结构。</span><br></pre></td></tr></table></figure>





<h2 id="Spring、SpringMVC、SpringBoot"><a href="#Spring、SpringMVC、SpringBoot" class="headerlink" title="Spring、SpringMVC、SpringBoot"></a>Spring、SpringMVC、SpringBoot</h2><h3 id="1-什么是-Spring-IOC-容器？"><a href="#1-什么是-Spring-IOC-容器？" class="headerlink" title="1. 什么是 Spring IOC 容器？"></a>1. 什么是 Spring IOC 容器？</h3><p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p>(ioc是spring框架的两大核心之一。ioc就是控制反转，简单的来说就是将创建对象的权利交由spring框架进行管理，spring会根据配置文件去创建实例对象以及管理依赖。以前创建对象的时机都是自己把握，主动权在自己的手上，现在可以使用java的反射机制进行自动生产，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法。DI依赖注入，是IOC的一种具体实现方式，就是通过容器获取对象，并进行属性的赋值。IOC是一种思想，而DI是一种实现。)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5Cimage_hSHMCVzNU0.png"></p>
<h3 id="2-如何实现一个Spring容器"><a href="#2-如何实现一个Spring容器" class="headerlink" title="2. 如何实现一个Spring容器"></a>2. 如何实现一个Spring容器</h3><p>1、配置文件配置包扫描路径<br>2、递归包扫描获取.class文件<br>3、反射、确定需要交给IOC管理的类<br>4、对需要注入的类进行依赖注入</p>
<p>配置文件中指定需要扫描的包路径<br>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注<br>解<br>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路<br>径下所有以.class结尾的文件添加到一个Set集合中进行存储<br>遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象<br>遍历这个IOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入。</p>
<h3 id="3-什么是依赖注入？可以通过多少种方式完成依赖注入？"><a href="#3-什么是依赖注入？可以通过多少种方式完成依赖注入？" class="headerlink" title="3. 什么是依赖注入？可以通过多少种方式完成依赖注入？"></a>3. 什么是依赖注入？可以通过多少种方式完成依赖注入？</h3><p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<p>理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.jianshu.com/p/c17ee0a5d59c</span></span><br><span class="line"><span class="meta">@Autowired</span>注解属于构造函数注入和setter方法注入两种方式的结合。它通过注解的方式自动将匹配的依赖项注入到对象的字段中。</span><br><span class="line"></span><br><span class="line">具体来说，当使用<span class="meta">@Autowired</span>注解时，Spring容器会自动查找与该注解匹配的Bean，并将其注入到被注解的字段中。如果存在多个匹配的Bean，则会抛出异常（可以通过设置<span class="meta">@Qualifier</span>注解来指定具体的Bean）。</span><br></pre></td></tr></table></figure>





<h3 id="4-BeanFactory-和-ApplicationContext的区别？"><a href="#4-BeanFactory-和-ApplicationContext的区别？" class="headerlink" title="4. BeanFactory 和 ApplicationContext的区别？"></a>4. BeanFactory 和 ApplicationContext的区别？</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jelly12345/p/15341951.html">https://www.cnblogs.com/jelly12345/p/15341951.html</a></p>
<p>ApplicationContext是BeanFactory的子接口<br>ApplicationContext提供了更完整的功能：<br>①继承MessageSource，因此支持国际化。<br>②统一的资源文件访问方式。<br>③提供在监听器中注册bean的事件。<br>④同时加载多个配置文件。<br>⑤载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。<br>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用<br>getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问<br>题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</p>
<p>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我<br>们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。<br>ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。<br>相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置<br>Bean较多时，程序启动较慢。<br>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用<br>ContextLoader。<br>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的<br>使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册</p>
<h3 id="5-构造函数注入和-setter-注入"><a href="#5-构造函数注入和-setter-注入" class="headerlink" title="5. 构造函数注入和 setter 注入"></a>5. 构造函数注入和 setter 注入</h3><p>构造函数注入和setter注入是依赖注入（Dependency Injection）中两种常见的方式，用于将依赖对象注入到目标对象中。它们在注入方式和使用方式上有所不同。</p>
<ol>
<li>构造函数注入（Constructor Injection）：<ul>
<li>构造函数注入是通过目标对象的构造函数来接收依赖对象的注入。</li>
<li>依赖对象在创建目标对象时通过构造函数的参数传递进来。</li>
<li>一旦目标对象被创建，其依赖对象就不能再改变。</li>
<li>构造函数注入可以保证目标对象在创建时就具备了必要的依赖，使得目标对象的状态是完整和一致的。</li>
</ul>
</li>
</ol>
<p>示例（Java）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    public UserService(UserRepository userRepository) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用userRepository进行用户操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>Setter注入（Setter Injection）：<ul>
<li>Setter注入是通过目标对象的setter方法来接收依赖对象的注入。</li>
<li>依赖对象通过setter方法设置到目标对象中。</li>
<li>可以在任何时候通过调用setter方法来改变目标对象的依赖对象。</li>
<li>Setter注入可以提供更灵活的依赖注入方式，允许在运行时动态地改变依赖对象。</li>
</ul>
</li>
</ol>
<p>示例（Java）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line">    private UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    public void setUserRepository(UserRepository userRepository) &#123;</span><br><span class="line">        this.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用userRepository进行用户操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>构造函数注入适用于那些在目标对象创建时就必须具备依赖对象的情况，可以保证目标对象的依赖是不可变的。</li>
<li>Setter注入适用于那些依赖对象可以在运行时动态改变的情况，提供了更大的灵活性。</li>
<li>在选择注入方式时，应根据具体的需求和设计考虑使用哪种方式，或者在需要时结合两种方式使用。</li>
</ul>
<h3 id="6-spring-提供了哪些配置方式？"><a href="#6-spring-提供了哪些配置方式？" class="headerlink" title="6. spring 提供了哪些配置方式？"></a>6. spring 提供了哪些配置方式？</h3><ul>
<li>基于 xml 配置</li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;studentbean&quot; class=&quot;org.edureka.firstSpring.StudentBean&quot;&gt;</span><br><span class="line"> &lt;property name=&quot;name&quot; value=&quot;Edureka&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于注解配置</li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">&lt;context:annotation-config/&gt;</span><br><span class="line">&lt;!-- bean definitions go here --&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于 Java Config配置—目前使用主流。</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
<li>@Component注解</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">Student</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-Spring-中的-bean-的作用域有哪些"><a href="#7-Spring-中的-bean-的作用域有哪些" class="headerlink" title="7. Spring 中的 bean 的作用域有哪些?"></a>7. Spring 中的 bean 的作用域有哪些?</h3><p><strong>singleton</strong>：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）</p>
<p><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例</p>
<p><strong>request：</strong> bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</p>
<p><strong>session</strong>：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</p>
<p><strong>application</strong>：bean被定义为在ServletContext的生命周期中复用一个单例对象。</p>
<p><strong>global-session</strong>：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</p>
<p><strong>refresh</strong>:Springcloud组件扩展了Bean对象的作用域在一次配置文件修改之后有效。</p>
<h3 id="8-深入谈谈对Ioc的理解？"><a href="#8-深入谈谈对Ioc的理解？" class="headerlink" title="8. 深入谈谈对Ioc的理解？"></a>8. 深入谈谈对Ioc的理解？</h3><p>容器概念、控制反转、依赖注入&#x20;</p>
<p><strong>Ioc容器</strong>：</p>
<p>实际上就是个map（key，value），里面存的是各种对象（在xml里配置的bean节点、@repository、@service、@controller、@component），在项目启动的时候会读取配置文件里面的bean节点，根据全限定类名使用反射创建对象放到map里、扫描到打上上述注解的类还是通过反射创建对象放到map里。这个时候map里就有各种对象了，接下来我们在代码里需要用到里面的对象时，再通过DI注入（@autowired、@resource等注解，xml里bean节点内的ref属性，项目启动的时候会读取xml节点ref属性根据id注入，也会扫描这些注解，根据类型或id注入；id就是对象名）。</p>
<p><strong>控制反转</strong>：<br>没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。引入IOC容器之后，对象A与对象B之间失去了直接联系，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。<br>通过前后的对比，不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>
<p><strong>依赖注入：</strong><br>“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。依赖注入是实现IOC的方法，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<h3 id="9-将一个类声明为Spring的-bean-的注解有哪些"><a href="#9-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="9. 将一个类声明为Spring的 bean 的注解有哪些?"></a>9. 将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。&#x20;</li>
<li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
<li>@Configuration+@Bean的方式</li>
</ul>
<h3 id="10-Spring-中的-bean-生命周期"><a href="#10-Spring-中的-bean-生命周期" class="headerlink" title="10. Spring 中的 bean 生命周期?"></a>10. Spring 中的 bean 生命周期?</h3><p>1.扫描生成BeanDefinition,并注册到BeanDefinitionMap中</p>
<p>2.合并得到BeanDefiniton.</p>
<p>3.加载类resolveBeanClass</p>
<p>4.实例化前</p>
<p>5.实例化</p>
<p>6.实例化后</p>
<p>7.属性填充</p>
<p>8.执行各种Aware</p>
<p>9.初始化前</p>
<p>10.初始化</p>
<p>11.初始化后</p>
<p>12.放入单例池</p>
<p>13.使用Bean对象</p>
<p>14.销毁Spring容器关闭时调用DisposableBean中destory()方法。</p>
<p>其中在实例化前后以及初始化前后程序员都可以通过BeanPostProcessor或者BeanPostProcessor接口的子接口InstantiationAwareBeanPostProcessor进行扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinition是Spring IoC容器中用于描述bean对象定义的接口</span><br></pre></td></tr></table></figure>

<h3 id="11-什么是bean的自动装配，有哪些方式？"><a href="#11-什么是bean的自动装配，有哪些方式？" class="headerlink" title="11.什么是bean的自动装配，有哪些方式？"></a>11.什么是bean的自动装配，有哪些方式？</h3><p>Bean的自动装配是SpringIoC容器在初始化bean时自动根据一定的规则将依赖注入到bean中的过程。</p>
<p>开启自动装配，只需要在xml配置文件中定义“autowire”属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Customer&quot;</span> autowire=<span class="string">&quot;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>autowire属性有六种装配的方式：</p>
<p>1、no – 缺省情况下，自动配置是通过“ref”属性手动设定 。</p>
<p>手动装配：以value或ref的方式明确指定属性值都是手动装配。<br>需要通过‘ref’属性来连接bean。</p>
<p>2、byName-根据bean的属性名称进行自动装配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性名称是person，Spring会将bean id为person的bean通过setter方法进行自动装</span><br><span class="line">配。</span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;byName&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>3、byType-根据bean的类型进行自动装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cutomer的属性person的类型为Person，Spirng会将Person类型通过setter方法进行自动装配。</span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;byType&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>4、constructor-类似byType，不过是应用于构造器的参数。如果一个bean与构造器参数的类型形相同，则进行自动装配，否则导致失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cutomer构造函数的参数person的类型为Person，Spirng会将Person类型通过构造方法进行自动装</span><br><span class="line">配。</span><br><span class="line">&lt;bean id=<span class="string">&quot;cutomer&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Cutomer&quot;</span> autowire=<span class="string">&quot;construtor&quot;</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;person&quot;</span> class=<span class="string">&quot;com.xxx.xxx.Person&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>5、autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。但是spring3.0+已将该值废弃。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配</span><br></pre></td></tr></table></figure>

<p>6、 default：由上级标签&lt;beans&gt;的default-autowire属性确定。</p>
<p>@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。相比Spring自带的自动注入方式，更加灵活。</p>
<h3 id="12-Spring中出现同名bean怎么办？"><a href="#12-Spring中出现同名bean怎么办？" class="headerlink" title="12. Spring中出现同名bean怎么办？"></a>12. Spring中出现同名bean怎么办？</h3><ul>
<li>如果是在不同的@Component注解中定义的同一个BeanName，那么Spring会直接报错。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_jTMLr9a8Cg.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_hP3d0bat68.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_lnhfbl70uZ.png"></p>
<ul>
<li>如果是ComponentScan和@Bean出现同名Bean。那么@Bean的会生效，@ComponentScan扫描进来不会生效。原因就是扫描进来的Bean定义是最先被注册的,而Spring默认又是支持BeanDefinition重写。也即allowBeanDefinitionOverriding为true,因此Spring底层就会以后解析的@Bean生成一个新BeanDefinition,且名字仍然是BeanName.然后注册到BeanDefinitonMap中，因此对于Map来说，同一个key的value值以最后一次为准。</li>
</ul>
<h3 id="13-Spring-怎么解决循环依赖问题？"><a href="#13-Spring-怎么解决循环依赖问题？" class="headerlink" title="13. Spring 怎么解决循环依赖问题？"></a>13. Spring 怎么解决循环依赖问题？</h3><h4 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖:"></a>什么是循环依赖:</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_35rH4qa-5a.png"></p>
<p>这里不会对Bean的生命周期进行详细的描述，只描述一下大概的过程。</p>
<p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p>
<p>被Spring管理的对象叫做Bean。Bean的生成步骤如下：</p>
<ol>
<li>Spring扫描class得到BeanDefinition</li>
<li>根据得到的BeanDefinition去生成bean</li>
<li>首先根据class推断构造方法</li>
<li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li>
<li>填充原始对象中的属性（依赖注入）</li>
<li>如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</li>
<li>把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</li>
</ol>
<p>可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的7步，还有很多很多，比如Aware回调、初始化等等，不详细讨论。</p>
<p>可以发现，在Spring中，构造一个Bean，包括了new这个步骤（第4步构造方法反射）。</p>
<p>得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？</p>
<p>比如上文说的A类，A类中存在一个B类的b属性，所以，当A类生成了一个原始对象之后，就会去给b属性去赋值，此时就会根据b属性的类型和属性名去BeanFactory中去获取B类所对应的单例bean。如果此时BeanFactory中存在B对应的Bean，那么直接拿来赋值给b属性；如果此时BeanFactory中不存在B对应的Bean，则需要生成一个B对应的Bean，然后赋值给b属性。</p>
<p>问题就出现在第二种情况，如果此时B类在BeanFactory中还没有生成对应的Bean，那么就需要去生成，就会经过B的Bean的生命周期。</p>
<p>那么在创建B类的Bean的过程中，如果B类中存在一个A类的a属性，那么在创建B的Bean的过程中就需要A类对应的Bean，但是，触发B类Bean的创建的条件是A类Bean在创建过程中的依赖注入，所以这里就出现了循环依赖：</p>
<p>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean（但ABean还在创建过程中）</p>
<p>从而导致ABean创建不出来，BBean也创建不出来。</p>
<h4 id="如何解决循环依赖："><a href="#如何解决循环依赖：" class="headerlink" title="如何解决循环依赖："></a>如何解决循环依赖：</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_O_52PBEwhK.png"></p>
<p>Spring底层最终解决靠的是四个Map（其中三个缓存Map,还有一个是判断有没有提前进行过Aop的Map以及一个Set（判断当前对象是否处于正在创建中）</p>
<ol>
<li><strong>singletonObjects</strong>：缓存某个beanName对应的经过了完整生命周期的bean也即我们平时说的单例池。</li>
<li><strong>earlySingletonObjects</strong>：缓存提前通过原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</li>
<li><strong>singletonFactories</strong>：缓存的是一个ObjectFactory，也就是一个Lambda表达式。在创建一个Bean时，在每个Bean的生成过程中，都会提前暴露一个Lambda表达式，并保存到三级缓存中，这个Lambda表达式<strong>可能用到，也可能用不到</strong>，如果没有出现循环依赖依赖本bean，那么这个Lambda表达式无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则从三级缓存中获取Lambda表达式，并执行Lambda表达式得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)，并把得到的对象放入二级缓存</li>
<li>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP了。</li>
<li>**creatingMap **这个作用是去判断是不是出现了循环依赖 也即是不是某个类是不是在创建中。</li>
</ol>
<h3 id="14-Spring-中的单例-bean-的线程安全问题？"><a href="#14-Spring-中的单例-bean-的线程安全问题？" class="headerlink" title="14. Spring 中的单例 bean 的线程安全问题？"></a>14. Spring 中的单例 bean 的线程安全问题？</h3><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。<br>如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域 把 “singleton”改为”protopyte” 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了。有状态就是有数据存储功能。无状态就是不会保存数据 controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</p>
<p>Dao会操作数据库Connection，Connection是带有状态的，比如说数据库事务，Spring的事务管理器使用Threadlocal为不同线程维护了一套独立的connection副本，保证线程之间不会互相影响（Spring是如何保证事务获取同一个Connection的）</p>
<p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了.</p>
<h3 id="15-什么是-AOP？"><a href="#15-什么是-AOP？" class="headerlink" title="15. 什么是 AOP？"></a>15. 什么是 AOP？</h3><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p>
<h3 id="16-谈谈对Aop的理解"><a href="#16-谈谈对Aop的理解" class="headerlink" title="16. 谈谈对Aop的理解"></a>16. 谈谈对Aop的理解</h3><p>系统是由许多不同的组件所组成的，每一个组件各负责一块特定功能。除了实现自身核心功能之外，这些组件还经常承担着额外的职责。例如日志、事务管理和安全这样的核心服务经常融入到自身具有核心业务逻辑的组件中去。这些系统服务经常被称为横切关注点，因为它们会跨越系统的多个组件。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。<br>日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。<br>在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情。</p>
<h3 id="17-AOP-有哪些实现方式？"><a href="#17-AOP-有哪些实现方式？" class="headerlink" title="17. AOP 有哪些实现方式？"></a>17. AOP 有哪些实现方式？</h3><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<ul>
<li>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</li>
<li>CGLIB动态代理： 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB ，是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</li>
</ul>
</li>
</ul>
<h3 id="18-Spring-框架中用到了哪些设计模式？"><a href="#18-Spring-框架中用到了哪些设计模式？" class="headerlink" title="18. Spring 框架中用到了哪些设计模式？"></a>18. Spring 框架中用到了哪些设计模式？</h3><p><strong>1</strong>、<strong>工厂设计模式</strong> :&#x20;</p>
<p><strong>简单工厂</strong>：由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p>
<p>Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是<br>在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</p>
<p><strong>工厂方法：</strong></p>
<p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p>
<p><strong>2、单例模式</strong></p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p>spring对单例的实现： spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为Spring管理的是任意的java对象。</p>
<p><strong>3、适配器模式：</strong></p>
<p>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替<br>controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p>
<p><strong>4、装饰器模式：</strong></p>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类<br>更为灵活。</p>
<p>Spring中用到的装饰器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p>
<p><strong>5、代理模式：</strong></p>
<p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</p>
<p>织入：把切面应用到目标对象并创建新的代理对象的过程。</p>
<p><strong>6、观察者模式</strong>：</p>
<p>spring的事件驱动模型使用的是观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p>
<p><strong>7、策略模式：</strong></p>
<p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了Resource 接口来访问底层资源。</p>
<p><strong>8、模板方法模式</strong> :&#x20;</p>
<p>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</p>
<p>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p>
<h3 id="19-Spring-事务实现方式有哪些以及原理"><a href="#19-Spring-事务实现方式有哪些以及原理" class="headerlink" title="19. Spring 事务实现方式有哪些以及原理"></a>19. Spring 事务实现方式有哪些以及原理</h3><ul>
<li>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
<li>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。@Transactional注解就是声明式事务。</li>
</ul>
<p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。<br>比如我们可以通过在某个方法上增加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功或失败。<br>在一个方法上加了@Transactional注解后，Spring会基于这个类生成一个代理对象，会将这个代理对象作为bean，当在使用这个代理对象的方法时，如果这个方法上存在@Transactional注解，那么代理逻辑会先把事务的自动提交设置为false，然后再去执行原本的业务逻辑方法，如果执行业务逻辑方法没有出现异常，那么代理逻辑中就会将事务进行提交，如果执行业务逻辑方法出现了异常，那么则会将事务进行回滚。当然，针对哪些异常回滚事务是可以配置的，可以利用@Transactional注解中的rollbackFor属性进行配置，默认情况下会对RuntimeException和Error进行回滚。</p>
<h3 id="20-Spring事务的隔离级别"><a href="#20-Spring事务的隔离级别" class="headerlink" title="20. Spring事务的隔离级别"></a>20. Spring事务的隔离级别</h3><p>spring事务隔离级别就是数据库的隔离级别：外加一个默认级别<br>read uncommitted（未提交读）<br>read committed（提交读、不可重复读）<br>repeatable read（可重复读）<br>serializable（可串行化）</p>
<p><strong>注意：</strong></p>
<p>数据库的配置隔离级别是Read Commited,而Spring配置的隔离级别是Repeatable Read，请问这时隔离级别是以哪一个为准？<br>以Spring配置的为准，如果spring设置的隔离级别数据库不支持，效果取决于数据库。</p>
<h3 id="21-Spring事务定义的传播规则"><a href="#21-Spring事务定义的传播规则" class="headerlink" title="21. Spring事务定义的传播规则"></a>21. Spring事务定义的传播规则</h3><p>多个事务方法相互调用时,事务如何在这些方法间传播。</p>
<p>方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。</p>
<p><strong>REQUIRED(</strong> Spring默认的事务传播类型)：如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务。</p>
<p><strong>SUPPORTS</strong>：当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行。<br><strong>MANDATORY</strong>：当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。<br><strong>REQUIRES_NEW</strong>：创建一个新事务，如果存在当前事务，则挂起该事务。<br><strong>NOT_SUPPORTED</strong>：以非事务方式执行,如果当前存在事务，则挂起当前事务。<br><strong>NEVER</strong>：不使用事务，如果当前事务存在，则抛出异常。<br><strong>NESTED</strong>：如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）。</p>
<p><strong>NESTED</strong>和<strong>REQUIRES_NEW</strong>的区别<br>REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。 在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。</p>
<p><strong>NESTED</strong>和<strong>REQUIRED</strong>的区别<br>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚 而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</p>
<h3 id="22-Spring事务什么时候会失效"><a href="#22-Spring事务什么时候会失效" class="headerlink" title="22. Spring事务什么时候会失效"></a>22. Spring事务什么时候会失效</h3><p>Spring事务的原理是AOP，进行了切面增强，那么失效的根本原因是<strong>这个AOP不起作用了</strong>！常见情况有如下几种<br>1、发生自调用，类里面使用this调用本类的方法（this通常省略），此时这个this对象不是代理类，而是该类的实例对象本身！<br>解决方法很简单，让那个this变成该类的的代理类实例对象即可！<br>2、方法不是public的<br>3、数据库不支持事务<br>4、没有被Spring管理<br>5、异常被吃掉，事务不会回滚(或者抛出的异常没有被定义，默认为RuntimeException)</p>
<h3 id="23-SpringMVC-工作原理了解吗"><a href="#23-SpringMVC-工作原理了解吗" class="headerlink" title="23. SpringMVC 工作原理了解吗?"></a>23. SpringMVC 工作原理了解吗?</h3><p><strong>流程说明（重要）：</strong></p>
<p>1)  用户发送请求至前端控制器 DispatcherServlet。<br>2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。<br>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。<br>4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。<br>5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)<br>6）Controller 执行完成返回 ModelAndView。<br>7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p>
<p>8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。<br>9）ViewReslover 解析后返回具体 View。<br>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。<br>11）DispatcherServlet 响应用户。</p>
<h3 id="24-简单介绍-Spring-MVC-的核心组件"><a href="#24-简单介绍-Spring-MVC-的核心组件" class="headerlink" title="24. 简单介绍 Spring MVC 的核心组件"></a>24. 简单介绍 Spring MVC 的核心组件</h3><p>Handler：也就是处理器。它直接应对着MVC中的C也就是Controller层，它的具体表现形式有很多，可以是类，也可以是方法。在Controller层中@RequestMapping标注的所有方法都可以看成是一个Handler，只要可以实际处理请求就可以是Handler。<br>1、<strong>HandlerMapping</strong><br>initHandlerMappings(context)，处理器映射器，根据用户请求的资源uri来查找Handler的。在SpringMVC中会有很多请求，每个请求都需要一个Handler处理，具体接收到一个请求之后使用哪个Handler进行，这就是HandlerMapping需要做的事。</p>
<p>2、<strong>HandlerAdapter</strong><br>initHandlerAdapters(context)，适配器。因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就ok，但是Servlet需要的处理方法的结构却是固定的，都是以request和response为参数的方法。如何让固定的Servlet处理方法调用灵活的Handler来进行处理呢？这就是HandlerAdapter要做的事情。Handler是用来干活的工具；HandlerMapping用于根据需要干的活找到相应的工具；HandlerAdapter是使用工具干活的人</p>
<p>。<br>3、<strong>HandlerExceptionResolver</strong><br>initHandlerExceptionResolvers(context)， 其它组件都是用来干活的。在干活的过程中难免会出现问题，出问题后怎么办呢？这就需要有一个专门的角色对异常情况进行处理，在SpringMVC中就是HandlerExceptionResolver。具体来说，此组件的作用是根据异常设置ModelAndView，之后再交给render方法进行渲染。</p>
<p>4、<strong>ViewResolver</strong><br>initViewResolvers(context)，ViewResolver用来将String类型的视图名和Locale解析为View类型的视图。View是用来渲染页面的，也就是将程序返回的参数填入模板里，生成html（也可能是其它类型）文件。这里就有两个关键问题：使用哪个模板？用什么技术（规则）填入参数？这其实是ViewResolver主要要做的工作，ViewResolver需要找到渲染所用的模板和所用的技术（也就是视图的类型）进行渲染，具体的渲染过程则交由不同的视图自己完成。</p>
<p>5、<strong>RequestToViewNameTranslator</strong><br>initRequestToViewNameTranslator(context)，ViewResolver是根据ViewName查找View，但有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。RequestToViewNameTranslator在Spring MVC容器里只可以配置一个，所以所有request到ViewName的转换规则都要在一个Translator里面全部实现。</p>
<p>6、<strong>LocaleResolver</strong><br>initLocaleResolver(context)， 解析视图需要两个参数：一是视图名，另一个是Locale。视图名是处理器返回的，Locale是从哪里来的？这就是LocaleResolver要做的事情。LocaleResolver用于从request解析出Locale，Locale就是zh-cn之类，表示一个区域，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p>
<p>7、<strong>ThemeResolver</strong><br>initThemeResolver(context)，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源、如图片、css样式等。SpringMVC的主题也支持国际化，同一个主题不同区域也可以显示不同的风格。SpringMVC中跟主题相关的类有 ThemeResolver、ThemeSource和Theme。主题是通过一系列资源来具体体现的，要得到一个主题的资源，首先要得到资源的名称，这是ThemeResolver的工作。然后通过主题名称找到对应的主题（可以理解为一个配置）文件，这是ThemeSource的工作。最后从主题中获取资源就可以了。</p>
<p>8、<strong>MultipartResolver</strong><br>initMultipartResolver(context)，用于处理上传请求。处理方法是将普通的request包装成<br>MultipartHttpServletRequest，后者可以直接调用getFile方法获取File，如果上传多个文件，还可以调用getFileMap得到FileName-&gt;File结构的Map。此组件中一共有三个方法，作用分别是判断是不是上传请求，将request包装成MultipartHttpServletRequest、处理完后清理上传过程中产生的临时资源。</p>
<p>9、<strong>FlashMapManager</strong><br>initFlashMapManager(context)，用来管理FlashMap的，FlashMap主要用在redirect中传递参数。</p>
<h3 id="25-Controller-注解有什么用？"><a href="#25-Controller-注解有什么用？" class="headerlink" title="25. @Controller 注解有什么用？"></a>25. @Controller 注解有什么用？</h3><p>@Controller 注解标记一个类为 Spring Web MVC <strong>控制器</strong> Controller。Spring MVC 会将扫描到该注解的类，然后扫描这个类下面带有 @RequestMapping 注解的方法，根据注解信息，为这个方法生成一个对应的<strong>处理器</strong>对象，在上面的 HandlerMapping 和 HandlerAdapter组件中讲到过。当然，除了添加 @Controller 注解这种方式以外，你还可以实现 Spring MVC 提供的 Controller 或者 HttpRequestHandler 接口，对应的实现类也会被作为一个<strong>处理器</strong>对象</p>
<h3 id="26-RestController-和-Controller-有什么区别？"><a href="#26-RestController-和-Controller-有什么区别？" class="headerlink" title="26. @RestController 和 @Controller 有什么区别？"></a>26. @RestController 和 @Controller 有什么区别？</h3><p>@RestController 注解，在 @Controller 基础上，增加了 @ResponseBody 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 ACCEPT 请求头来决定。</p>
<h3 id="27-RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#27-RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="27. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>27. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><ol>
<li>@RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上</li>
<li>@RequestMapping：可进行 GET、POST、PUT、DELETE 等请求方法；@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ol>
<h3 id="28-RequestParam-和-PathVariable-两个注解的区别"><a href="#28-RequestParam-和-PathVariable-两个注解的区别" class="headerlink" title="28. @RequestParam 和 @PathVariable 两个注解的区别"></a>28. @RequestParam 和 @PathVariable 两个注解的区别</h3><p>两个注解都用于方法参数，获取参数值的方式不同，@RequestParam 注解的参数从请求携带的参数中获取，而 @PathVariable 注解从请求的 URI 中获取。</p>
<h3 id="29-返回-JSON-格式使用什么注解？"><a href="#29-返回-JSON-格式使用什么注解？" class="headerlink" title="29. 返回 JSON 格式使用什么注解？"></a>29. 返回 JSON 格式使用什么注解？</h3><p>可以使用 <strong>@ResponseBody</strong> 注解，或者使用包含 @ResponseBody 注解的 <strong>@RestController</strong> 注解。</p>
<p>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter。</p>
<h3 id="30-什么是springmvc拦截器以及如何使用它？"><a href="#30-什么是springmvc拦截器以及如何使用它？" class="headerlink" title="30. 什么是springmvc拦截器以及如何使用它？"></a>30. 什么是springmvc拦截器以及如何使用它？</h3><p>Spring MVC拦截器（Interceptor）是一种用于拦截和处理请求的组件，它可以在请求的前后进行处理，并对请求进行修改或添加额外的功能。拦截器可以用于实现一些通用的功能，例如身份验证、日志记录、性能监控等。</p>
<p>以下是使用Spring MVC拦截器的步骤：</p>
<ol>
<li>创建拦截器类：<ul>
<li>创建一个实现HandlerInterceptor接口的拦截器类。</li>
<li>拦截器类可以包含在Spring MVC应用程序的任何位置，例如包下的一个单独类或者一个独立的模块。</li>
</ul>
</li>
<li>实现拦截器方法：<ul>
<li>在拦截器类中实现preHandle、postHandle和afterCompletion等方法。</li>
<li>preHandle方法在请求处理之前执行，可以进行一些前置处理，例如身份验证、权限检查等。</li>
<li>postHandle方法在请求处理之后、视图渲染之前执行，可以对模型数据进行处理或添加额外的功能。</li>
<li>afterCompletion方法在整个请求完成之后执行，可以进行一些资源清理或日志记录等操作。</li>
</ul>
</li>
<li>配置拦截器：<ul>
<li>在Spring MVC配置文件（如XML配置文件或Java配置类）中配置拦截器。</li>
<li>通过注册拦截器类的方式将其添加到拦截器链中。</li>
<li>可以指定拦截器的拦截路径（URL模式）或排除路径，以确定哪些请求会被拦截。</li>
</ul>
</li>
<li>测试拦截器：<ul>
<li>启动Spring MVC应用程序，并发送请求进行测试。</li>
<li>拦截器将根据配置的规则拦截相应的请求，并执行拦截器方法。</li>
</ul>
</li>
</ol>
<p>通过使用Spring MVC拦截器，您可以在请求的前后进行处理，实现一些通用的功能和逻辑。拦截器提供了一种灵活的方式来对请求进行拦截和处理，使您能够在应用程序中添加额外的功能和行为。</p>
<h3 id="31-为什么要用SpringBoot"><a href="#31-为什么要用SpringBoot" class="headerlink" title="31. 为什么要用SpringBoot?"></a>31. 为什么要用SpringBoot?</h3><p>在使用Spring框架进行开发的过程中，需要配置很多Spring框架包的依赖，如spring-core、spring-bean、spring-context等，而这些配置通常都是重复添加的，而且需要做很多框架使用及环境参数的重复配置，如开启注解、配置日志等。Spring Boot致力于弱化这些不必要的操作，提供默认配置，当然这些默认配置是可以按需修改的，快速搭建、开发和运行Spring应用。</p>
<p>以下是使用SpringBoot的一些好处：</p>
<ul>
<li>自动配置，使用基于类路径和应用程序上下文的智能默认值，当然也可以根据需要重写它们以满足开发人员的需求。</li>
<li>创建Spring Boot Starter 项目时，可以选择选择需要的功能，Spring Boot将为你管理依赖关系。</li>
<li>SpringBoot项目可以打包成jar文件。可以使用Java-jar命令从命令行将应用程序作为独立的Java应用程序运行。</li>
<li>在开发web应用程序时，springboot会配置一个嵌入式Tomcat服务器，以便它可以作为独立的应用程序运行。（Tomcat是默认的，当然你也可以配置Jetty或Undertow）</li>
<li><h2 id="SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。"><a href="#SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。" class="headerlink" title="SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。"></a>SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。</h2></li>
</ul>
<h3 id="32-Spring-Boot-自动配置原理？"><a href="#32-Spring-Boot-自动配置原理？" class="headerlink" title="32.Spring Boot 自动配置原理？"></a>32.Spring Boot 自动配置原理？</h3><p>@Import + @Configuration + Spring spi<br>自动配置类由各个starter提供，使用@Configuration + @Bean定义配置类，放到META-<br>INF&#x2F;spring.factories下。<br>使用Spring spi扫描META-INF&#x2F;spring.factories下的配置类。<br>使用@Import导入自动配置类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpring%E3%80%81SpringMVC%E3%80%81SpringBoot%5Cimage%5C%E5%9B%BE%E7%89%87_3e5Q5o8qjK.png"></p>
<p>详细流程原理分析，参考毕业精讲课。</p>
<h3 id="33-Spring-Boot中如何实现对不同环境的属性配置文件的支持？"><a href="#33-Spring-Boot中如何实现对不同环境的属性配置文件的支持？" class="headerlink" title="33. Spring Boot中如何实现对不同环境的属性配置文件的支持？"></a>33. Spring Boot中如何实现对不同环境的属性配置文件的支持？</h3><p>Spring Boot支持不同环境的属性配置文件切换，通过创建application-{profile}.properties文件，其中{profile}是具体的环境标识名称，</p>
<p>例如：</p>
<p>application-dev.properties用于开发环境，</p>
<p>application-test.properties用于测试环境，</p>
<p>application-uat.properties用于uat环境。</p>
<p>如果要想使用application-dev.properties文件，则在application.properties文件中添加spring.profiles.active&#x3D;dev。</p>
<p>如果要想使用application-test.properties文件，则在application.properties文件中添加spring.profiles.active&#x3D;test。</p>
<h3 id="34-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#34-Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="34. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>34. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<h3 id="35-你如何理解-Spring-Boot-中的-Starter？"><a href="#35-你如何理解-Spring-Boot-中的-Starter？" class="headerlink" title="35. 你如何理解 Spring Boot 中的 Starter？"></a>35. 你如何理解 Spring Boot 中的 Starter？</h3><p>使用spring + springmvc使用，如果需要引入mybatis等框架，需要到xml中定义mybatis需要的bean.</p>
<p>starter就是定义一个starter的jar包，写一个@Configuration配置类、将这些bean定义在里面，然后在starter包的META-INF&#x2F;spring.factories中写入该配置类，springboot会按照约定来加载该配置类.</p>
<p>开发人员只需要将相应的starter包依赖进应用，进行相应的属性配置（使用默认配置时，不需要配置），就可以直接进行代码开发，使用对应的功能了，比如mybatis-spring-boot–starter，spring-boot-starter-redis.</p>
<h3 id="36-Spring-Boot-Starter-的工作原理是什么？"><a href="#36-Spring-Boot-Starter-的工作原理是什么？" class="headerlink" title="36. Spring Boot Starter 的工作原理是什么？"></a>36. Spring Boot Starter 的工作原理是什么？</h3><p>Spring Boot 在启动的时候会干这几件事情：</p>
<ul>
<li>Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources&#x2F;META-INF&#x2F;spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</li>
<li>根据 spring.factories 配置加载 AutoConfigure 类</li>
<li>根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</li>
</ul>
<p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可.</p>
<h3 id="37-什么是嵌入式服务器？为什么要使用嵌入式服务器"><a href="#37-什么是嵌入式服务器？为什么要使用嵌入式服务器" class="headerlink" title="37. 什么是嵌入式服务器？为什么要使用嵌入式服务器?"></a>37. 什么是嵌入式服务器？为什么要使用嵌入式服务器?</h3><p>节省了下载安装tomcat，应用也不需要再打war包，然后放到webapp目录下再运行<br>只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了<br>springboot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载<br>springmvc</p>
<h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h3 id="1、spring-cloud断路器的作用是什么？"><a href="#1、spring-cloud断路器的作用是什么？" class="headerlink" title="1、spring cloud断路器的作用是什么？"></a>1、spring cloud断路器的作用是什么？</h3><p>Spring Cloud断路器（Hystrix）是一种用于构建弹性、容错和容灾机制的开源库。它提供了一种通过隔离和控制远程服务调用的方式，以防止由于服务故障或延迟而导致的级联故障。</p>
<p>断路器的作用如下：</p>
<ol>
<li>故障隔离：断路器通过将远程服务调用封装在一个独立的断路器中，可以隔离故障的影响范围。当远程服务发生故障或延迟时，断路器可以快速失败并返回预定义的默认值，而不会影响整个系统的稳定性。</li>
<li>容错处理：断路器可以在远程服务不可用时提供备用方案。通过配置降级逻辑，可以在远程服务故障时返回预先定义的备用数据，以保证系统的可用性和稳定性。</li>
<li>自动恢复：断路器具备自我修复的能力。它会定期尝试恢复远程服务的调用，以检查其可用性。当远程服务恢复正常时，断路器会逐渐恢复对该服务的调用，并重新建立正常的调用链路。</li>
<li>实时监控：断路器提供了实时监控和度量功能，可以收集和展示远程服务调用的各项指标，如调用次数、失败率、响应时间等。这些指标可以帮助开发人员和运维人员了解系统的健康状况，并进行故障排查和性能优化。</li>
</ol>
<p>通过使用Spring Cloud断路器，可以有效地处理分布式系统中的服务故障和延迟问题，提高系统的容错性和可用性。它是构建弹性和可靠微服务架构的重要组件之一。</p>
<h3 id="2、spring-cloud的核心组件有哪些以及作用"><a href="#2、spring-cloud的核心组件有哪些以及作用" class="headerlink" title="2、spring cloud的核心组件有哪些以及作用"></a>2、spring cloud的核心组件有哪些以及作用</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpringCloud%5Cimage%5C%E5%9B%BE%E7%89%87_QTt8HtVHBa.png"></p>
<p><strong>Eureka</strong>：服务注册与发现<br>注册：每个服务都向Eureka登记自己提供服务的元数据，包括服务的ip地址、端口号、版本号、通信协议等。eureka将各个服务维护在了一个服务清单中（双层Map，第一层key是服务名，第二层key是实例名，value是服务地址加端口）。同时对服务维持心跳，剔除不可用的服务，eureka集群各节点相互注册每个实例中都有一样的服务清单。</p>
<p>发现：eureka注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单(缓存到本地)，然后实现服务的请求访问。</p>
<p><strong>Ribbon</strong>：服务间发起请求的时候，基于Ribbon做负载均衡，从⼀个服务的多台机器中选择⼀台 （被调用方的服务地址有多个），Ribbon也是通过发起http请求，来进行的调用，只不过是通过调用服务名的地址来实现的。虽然说Ribbon不用去具体请求服务实例的ip地址或域名了，但是每调用一个接口都还要手动去发起Http请求。</p>
<p><strong>Hystrix</strong>：发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级。</p>
<p><strong>Zuul</strong>：如果前端、移动端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务，通过与Eureka进行整合，将自身注册为Eureka下的应用，从Eureka下获取所有服务的实例，来进行服务的路由。Zuul还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。</p>
<p><strong>SpringCloud Config:</strong> 提供服务器端和客户端。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。这个还是静态的，需要得配合Spring Cloud Bus实现动态的配置更新。</p>
<h3 id="3、spring-如何注册cloud服务？"><a href="#3、spring-如何注册cloud服务？" class="headerlink" title="3、spring 如何注册cloud服务？"></a>3、spring 如何注册cloud服务？</h3><p>在Spring框架中使用Spring Cloud服务，需要进行以下步骤来注册和启用Spring Cloud组件：</p>
<ol>
<li>添加依赖：在项目的构建配置文件（如pom.xml）中添加所需的Spring Cloud依赖。例如，可以添加<code>spring-cloud-starter-netflix-eureka-client</code>依赖来使用Eureka服务注册与发现组件。</li>
<li>配置文件：在应用程序的配置文件（如application.properties或application.yml）中配置Spring Cloud服务的相关属性。具体的配置内容取决于所使用的Spring Cloud组件。例如，使用Eureka服务注册与发现时，需要指定Eureka服务器的地址和端口等信息。</li>
<li>注解标记：在Spring Boot应用程序的主类上添加相应的注解来启用Spring Cloud服务。具体的注解取决于所使用的Spring Cloud组件。例如，使用Eureka服务注册与发现时，可以在主类上添加<code>@EnableEurekaClient</code>注解。</li>
<li>运行环境：确保应用程序运行的环境中包含了所需的Spring Cloud组件的运行实例。例如，如果使用Eureka服务注册与发现，需要确保Eureka服务器正常运行。</li>
</ol>
<p>下面是一个使用Eureka服务注册与发现的示例：</p>
<p>1 . 添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2 . 配置文件（application.yml）：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>3 . 主类上添加注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，你就可以在Spring应用程序中注册和启用Spring Cloud服务了。具体的步骤和配置内容可能会根据所使用的Spring Cloud组件而有所不同，你可以根据具体的需求和文档进行相应的配置和操作。</p>
<h3 id="4、微服务优点是什么？"><a href="#4、微服务优点是什么？" class="headerlink" title="4、微服务优点是什么？"></a>4、微服务优点是什么？</h3><p>（1)每个服务都足够内聚，代码易于理解；</p>
<p>(2)提高开发效率，一项服务只做一件事；</p>
<p>(3)微服务可以由小团队单独开发；</p>
<p>(4)微服务是松耦合的，是有功能意义的服务；</p>
<p>(5)可以用不同的语言开发，面向接口编程；</p>
<p>(6)易于与第三方集成；</p>
<p>(7)微服务只是业务逻辑的代码，不会和HTML一起使用。CSS或其它界面组合；</p>
<p>(8)可灵活搭配，连接公共库和独立库。</p>
<h3 id="5、微服务的缺点是什么？"><a href="#5、微服务的缺点是什么？" class="headerlink" title="5、微服务的缺点是什么？"></a>5、微服务的缺点是什么？</h3><p>（1)分布式系统的责任；</p>
<p>(2)多服务运维难度，随着服务的增加，运维压力也在增加；</p>
<p>(3)系统部署依赖；</p>
<p>(4)服务间通信成本；</p>
<p>(5)数据一致性；</p>
<p>(6)系统集成测试；(7)性能监控。</p>
<h3 id="6、Spring-Cloud-Bus是什么"><a href="#6、Spring-Cloud-Bus是什么" class="headerlink" title="6、Spring Cloud Bus是什么?"></a>6、Spring Cloud Bus是什么?</h3><p>Spring Cloud Bus是Spring Cloud框架中的一个组件，用于在分布式系统中实现消息总线功能。它建立在Spring Boot和Spring Cloud Stream之上，提供了一种方便的方式来在微服务架构中进行消息传递和事件广播。</p>
<p>Spring Cloud Bus的主要功能是通过消息代理将分布式系统中的各个微服务实例连接起来，使它们能够方便地进行消息的发送和接收。它使用轻量级的消息代理（如RabbitMQ或Kafka）作为中间件，实现了消息的广播和订阅机制。</p>
<p>使用Spring Cloud Bus，可以实现以下功能：</p>
<ol>
<li>配置中心的刷新：通过发送特定的消息，可以触发所有微服务实例重新加载配置信息，从而实现配置的动态更新。</li>
<li>事件广播：可以将事件消息广播给所有微服务实例，用于实现系统内的事件驱动机制。</li>
<li>监控和管理：可以通过消息传递的方式，实现对微服务实例的监控和管理，例如获取实例的健康状态、查看日志等。</li>
</ol>
<p>Spring Cloud Bus使用了发布-订阅模式，其中一个微服务实例作为消息的生产者，将消息发送到消息代理，而其他微服务实例作为消息的消费者，订阅感兴趣的消息并进行相应的处理。通过这种方式，可以实现微服务之间的解耦和灵活的消息传递。</p>
<p>需要注意的是，Spring Cloud Bus并不是用于高频率的数据传输或大规模的消息通信，而是用于在分布式系统中进行配置更新、事件广播和管理操作。对于更复杂的消息通信需求，可以结合使用Spring Cloud Stream等组件来实现。</p>
<p>总之，Spring Cloud Bus提供了一种简单而强大的方式来实现分布式系统中的消息总线功能，实现了微服务之间的解耦和灵活的消息传递。它是构建基于Spring Cloud的分布式系统的重要工具之一。</p>
<h3 id="7、什么是服务熔断？什么是服务降级？"><a href="#7、什么是服务熔断？什么是服务降级？" class="headerlink" title="7、什么是服务熔断？什么是服务降级？"></a>7、什么是服务熔断？什么是服务降级？</h3><p><strong>1、概念不同：</strong></p>
<p>服务熔断：其实很好理解，就是一个断开的过程。</p>
<p>下游的服务因为某种原因突然变得不可用或响应过慢，上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。</p>
<p>服务降级：降低级别的意思，它是指程序在出现问题时，仍能保证有限功能可用的一种机制。</p>
<p>因此：对于降级是一种退而求其次的选择，而熔断却是整体不可用。</p>
<p><strong>2、触发原因不太一样</strong>：</p>
<p>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑。</p>
<p><strong>3、管理层次不太一样：</strong></p>
<p>服务熔断是一个框架层次的处理（每个服务都要考虑，无业务层级之分），服务降级是业务层次的处理。（比如降级一般是从最非核心服务开始）</p>
<p>服务熔断是服务降级的一种特殊情况，他是防止服务雪崩而采取的措施。系统发生异常或者延迟或者流量太大，都会触发该服务的服务熔断措施，链路熔断，返回兜底方法。这是对局部的一种保险措施。</p>
<p>服务降级是对系统整体资源的合理分配。区分核心服务和非核心服务。对某个服务的访问延迟时间、异常等情况做出预估并给出兜底方法。这是一种全局性的考量，对系统整体负荷进行管理。</p>
<p>其实一句话： 降级是一种设计思想，在Java层面就是一个接口，而熔断是降级的不同实现方式，在Java层面就是这个接口的一个实现类。</p>
<p><strong>4、熔断和降级的关系</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/Java%E6%A1%86%E6%9E%B6%5CSpringCloud%5Cimage%5C%E5%9B%BE%E7%89%87_Ra3eTutVdS.png"></p>
<h3 id="8、负载均衡的意义是什么？"><a href="#8、负载均衡的意义是什么？" class="headerlink" title="8、负载均衡的意义是什么？"></a>8、负载均衡的意义是什么？</h3><p>负载均衡（Load Balancing）是指将网络或计算资源分配给多个服务器或设备，以达到提高系统性能、可扩展性和可靠性的目的。它在分布式系统中起到重要的作用，具有以下几个重要的意义：</p>
<ol>
<li>提高系统性能：负载均衡将请求均匀地分配给多个服务器，避免了单个服务器过载的情况。通过合理地分配负载，可以充分利用系统的资源，提高系统的吞吐量和响应速度。</li>
<li>实现高可用性：通过将请求分发到多个服务器，即使其中某个服务器发生故障或不可用，仍然可以继续提供服务。负载均衡器能够检测到故障服务器，并将请求转发到其他正常工作的服务器，从而实现系统的高可用性和容错性。</li>
<li>支持系统扩展：随着用户量和业务需求的增加，单个服务器可能无法满足系统的需求。负载均衡器可以根据实际情况动态地添加或删除服务器，实现系统的水平扩展。通过增加服务器数量，可以提高系统的处理能力和并发性能。</li>
<li>优化资源利用：负载均衡器可以根据服务器的负载情况智能地分配请求，使每个服务器的负载相对均衡。这样可以避免某些服务器过载而其他服务器处于空闲状态的情况，最大限度地提高资源的利用率。</li>
<li>简化系统管理：通过使用负载均衡器，可以将多个服务器组织成一个逻辑集群，对外提供统一的入口。这样可以简化系统的管理和维护工作，减少对客户端的影响，提高系统的可维护性和可管理性。</li>
</ol>
<p>总之，负载均衡在分布式系统中具有重要的意义。它能够提高系统性能、可用性和可扩展性，优化资源利用，简化系统管理。通过合理地分配负载，负载均衡器能够实现高效、稳定和可靠的系统运行。</p>
<h3 id="9、SpringBoot和SpringCloud有什么联系和区别？"><a href="#9、SpringBoot和SpringCloud有什么联系和区别？" class="headerlink" title="9、SpringBoot和SpringCloud有什么联系和区别？"></a>9、SpringBoot和SpringCloud有什么联系和区别？</h3><p>Spring Boot和Spring Cloud是两个相互关联但又有不同重点的项目。</p>
<ol>
<li>Spring Boot（Spring框架）：Spring Boot是一个用于简化和加速Spring应用程序开发的框架。它提供了一种约定优于配置的方式，通过自动配置和默认值，可以快速搭建和部署独立的、可执行的Spring应用程序。Spring Boot使得开发者可以更专注于业务逻辑的实现，而无需手动配置复杂的Spring配置文件。</li>
<li>Spring Cloud：Spring Cloud是一个用于构建分布式系统的工具集合，它基于Spring Boot提供了一系列的开箱即用的分布式系统模块和服务。Spring Cloud包含了多个组件，如服务注册与发现（Eureka、Consul）、服务调用（Feign、Ribbon）、断路器（Hystrix）、网关（Zuul、Gateway）、配置中心（Config）等，这些组件提供了分布式系统开发中常用的功能和解决方案。</li>
</ol>
<p>联系和区别：</p>
<ul>
<li>联系：Spring Boot是Spring框架的一部分，它为Spring应用程序提供了快速开发的能力，而Spring Cloud是构建分布式系统的工具集合，基于Spring Boot提供了一系列分布式系统模块和服务。</li>
<li>区别：Spring Boot主要关注于简化和加速单个Spring应用程序的开发，提供了自动配置、快速启动等特性。而Spring Cloud主要关注于构建分布式系统，提供了服务注册与发现、服务调用、负载均衡、断路器等组件，用于处理分布式系统中的各种挑战。</li>
</ul>
<p>综上所述，Spring Boot和Spring Cloud是相互关联的，Spring Boot为Spring应用程序提供了快速开发的能力，而Spring Cloud则在此基础上提供了构建分布式系统的工具和解决方案。使用Spring Boot可以快速搭建单个Spring应用程序，而使用Spring Cloud可以在分布式系统中构建和管理多个相互协作的微服务。</p>
<h1 id="JUC–必会100"><a href="#JUC–必会100" class="headerlink" title="JUC–必会100%"></a>JUC–必会100%</h1><h2 id="什么是线程池，线程池有哪些？"><a href="#什么是线程池，线程池有哪些？" class="headerlink" title="什么是线程池，线程池有哪些？"></a>什么是线程池，线程池有哪些？</h2><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率</p>
<p>在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。</p>
<p>ExecutorService newCachedThreadPool &#x3D; Executors.newCachedThreadPool();</p>
<p>ExecutorService newFixedThreadPool &#x3D; Executors.newFixedThreadPool(4);</p>
<p>ScheduledExecutorService newScheduledThreadPool &#x3D; Executors.newScheduledThreadPool(4);</p>
<p>ExecutorService newSingleThreadExecutor &#x3D; Executors.newSingleThreadExecutor();</p>
<p>然后调用他们的 execute 方法即可。</p>
<h3 id="（1）newCachedThreadPool"><a href="#（1）newCachedThreadPool" class="headerlink" title="（1）newCachedThreadPool"></a>（<strong>1</strong>）<strong>newCachedThreadPool</strong></h3><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：</p>
<p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p>
<p>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</p>
<p>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p>
<h3 id="（2）newFixedThreadPool"><a href="#（2）newFixedThreadPool" class="headerlink" title="（2）newFixedThreadPool"></a>（<strong>2</strong>）newFixedThreadPool</h3><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<h3 id="（3）newSingleThreadExecutor"><a href="#（3）newSingleThreadExecutor" class="headerlink" title="（3）newSingleThreadExecutor"></a>（<strong>3</strong>）<strong>newSingleThreadExecutor</strong></h3><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>
<h3 id="（4）newScheduleThreadPool"><a href="#（4）newScheduleThreadPool" class="headerlink" title="（4）newScheduleThreadPool"></a>（<strong>4</strong>）<strong>newScheduleThreadPool</strong></h3><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3秒执行。</p>
<p>这4种线程池底层 全部是ThreadPoolExecutor对象的实现，阿里规范手册中规定线程池采用ThreadPoolExecutor自定义的，实际开发也是。</p>
<h2 id="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？-重点"><a href="#ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？-重点" class="headerlink" title="ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点]"></a>ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点]</h2><h3 id="参数与作用：共7个参数"><a href="#参数与作用：共7个参数" class="headerlink" title="参数与作用：共7个参数"></a>参数与作用：共7个参数</h3><p><strong>corePoolSize</strong></p>
<p>核心线程数，在ThreadPoolExecutor中有一个与它相关的配置：allowCoreThreadTimeOut（默认为false），当allowCoreThreadTimeOut为false时，核心线程会一直存活，哪怕是一直空闲着。而当allowCoreThreadTimeOut为true时核心线程空闲时间超过keepAliveTime时会被回收。</p>
<p><strong>maximumPoolSize</strong></p>
<p>最大线程数，线程池能容纳的最大线程数，当线程池中的线程达到最大时，此时添加任务将会采用拒绝策略，默认的拒绝策略是抛出一个运行时错误（RejectedExecutionException）。值得一提的是，当初始化时用的工作队列为LinkedBlockingDeque时，这个值将无效。</p>
<p><strong>keepAliveTime</strong></p>
<p>存活时间，当非核心空闲超过这个时间将被回收，同时空闲核心线程是否回收受allowCoreThreadTimeOut影响。</p>
<p><strong>unit</strong></p>
<p>keepAliveTime的单位。</p>
<p><strong>workQueue</strong></p>
<p>任务队列，常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。</p>
<p><strong>threadFactory</strong></p>
<p>线程工厂，ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。</p>
<p><strong>RejectedExecutionHandler</strong></p>
<p>也是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。</p>
<p>默认是抛出一个运行时异常。</p>
<h3 id="线程池大小设置："><a href="#线程池大小设置：" class="headerlink" title="线程池大小设置："></a><strong>线程池大小设置：</strong></h3><ol>
<li>需要分析线程池执行的任务的特性： CPU 密集型还是 IO 密集型</li>
<li>每个任务执行的平均时长大概是多少，这个任务的执行时长可能还跟任务处理逻辑是否涉及到网络传输以及底层系统资源依赖有关系</li>
</ol>
<p>如果是 CPU 密集型，主要是执行计算任务，响应时间很快，cpu 一直在运行，这种任务 cpu的利用率很高，那么线程数的配置应该根据 CPU 核心数来决定，CPU 核心数&#x3D;最大同时执行线程数，加入 CPU 核心数为 4，那么服务器最多能同时执行 4 个线程。过多的线程会导致上下文切换反而使得效率降低。那线程池的最大线程数可以配置为 cpu 核心数+1 如果是 IO 密集型，主要是进行 IO 操作，执行 IO 操作的时间较长，这是 cpu 出于空闲状态，导致 cpu 的利用率不高，这种情况下可以增加线程池的大小。这种情况下可以结合线程的等待时长来做判断，等待时间越高，那么线程数也相对越多。一般可以配置 cpu 核心数的 2 倍。</p>
<p>一个公式：线程池设定最佳线程数目 &#x3D; （（线程池设定的线程等待时间+线程 CPU 时间）&#x2F; &#x20;<br>线程 CPU 时间 ）* CPU 数目</p>
<p>这个公式的线程 cpu 时间是预估的程序单个线程在 cpu 上运行的时间（通常使用 loadrunner测试大量运行次数求出平均值）</p>
<h3 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a><strong>拒绝策略：</strong></h3><p>1、<strong>AbortPolicy</strong></p>
<p>直接抛出异常，默认策略；</p>
<p>2、<strong>CallerRunsPolicy</strong></p>
<p>用调用者所在的线程来执行任务；</p>
<p>3、<strong>DiscardOldestPolicy</strong></p>
<p>丢弃阻塞队列中靠最前的任务，并执行当前任务；</p>
<p>4、<strong>DiscardPolicy</strong></p>
<p>直接丢弃任务； &#x20;<br>当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p>
<h2 id="常见线程安全的并发容器有哪些？"><a href="#常见线程安全的并发容器有哪些？" class="headerlink" title="常见线程安全的并发容器有哪些？"></a>常见线程安全的并发容器有哪些？</h2><p>CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap。</p>
<p>CopyOnWriteArrayList、CopyOnWriteArraySet采用写时复制实现线程安全</p>
<p>ConcurrentHashMap采用分段锁的方式实现线程安全</p>
<h2 id="Atomic原子类了解多少？原理是什么？"><a href="#Atomic原子类了解多少？原理是什么？" class="headerlink" title="Atomic原子类了解多少？原理是什么？"></a>Atomic原子类了解多少？原理是什么？</h2><p>ava中的java.util.concurrent.atomic包提供了一组原子类，用于在多线程环境中执行原子操作，而无需使用显式的锁。这些原子类使用特殊的CPU指令来确保操作的原子性，从而避免了使用锁带来的性能开销。</p>
<p>这些原子类的实现依赖于底层硬件架构提供的原子操作指令。通常，这些指令在现代处理器上是硬件级别的支持，确保对内存的读写是原子的。这使得在不使用锁的情况下，可以在多线程环境中执行某些操作，而不会导致竞态条件（race conditions）。</p>
<p><strong>以下是一些常见的java.util.concurrent.atomic包中的原子类以及它们的一些实现原理：</strong></p>
<p>AtomicInteger, AtomicLong, AtomicReference:</p>
<p>这些类使用compareAndSet（CAS）操作实现原子性。CAS是一种乐观锁定机制，它尝试原子地将一个值更新为新值，但只有在当前值等于预期值时才成功。否则，它会重新尝试。<br>CAS操作是由处理器提供的原子性操作指令支持的。<br>AtomicBoolean:</p>
<p>AtomicBoolean类使用compareAndSet实现。<br>compareAndSet的实现通常依赖于底层处理器的CAS指令。<br>AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray:</p>
<p>这些类提供了对数组元素的原子性访问。<br>它们也使用CAS操作，但应用于数组的特定位置。<br>AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater:</p>
<p>这些类提供了对对象字段的原子性更新。<br>它们使用了反射和CAS操作来实现。<br>总体来说，原子类的实现依赖于底层硬件提供的原子性操作指令，这通常是现代处理器架构的一部分。这使得原子类能够在无锁的情况下执行一些基本的原子操作，提高了多线程环境中的性能。在高并发的情况下，原子类是一种有用的工具，能够提供线程安全的操作，而无需显式地使用锁。</p>
<h2 id="synchronized底层实现是什么？lock底层是什么？有什么区别？"><a href="#synchronized底层实现是什么？lock底层是什么？有什么区别？" class="headerlink" title="synchronized底层实现是什么？lock底层是什么？有什么区别？"></a>synchronized底层实现是什么？lock底层是什么？有什么区别？</h2><h3 id="Synchronized原理："><a href="#Synchronized原理：" class="headerlink" title="Synchronized原理："></a><strong>Synchronized原理：</strong></h3><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p>
<p>代码块的同步是利用monitorenter和monitorexit这两个字节码指令。它们分别位于同步代码块的开始和结束位置。当jvm执行到monitorenter指令时，当前线程试图获取monitor对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器+1；当执行monitorexit指令时，锁计数器-1；当锁计数器为0时，该锁就被释放了。如果获取monitor对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p>
<h3 id="Lock原理："><a href="#Lock原理：" class="headerlink" title="Lock原理："></a><strong>Lock原理：</strong></h3><p>· Lock的存储结构：一个int类型状态值（用于锁的状态变更），一个双向链表（用于存储等待中的线程）</p>
<p>· Lock获取锁的过程：本质上是通过CAS来获取状态值修改，如果当场没获取到，会将该线程放在线程等待链表中。</p>
<p>· Lock释放锁的过程：修改状态值，调整等待链表。</p>
<p>· Lock大量使用CAS+自旋。因此根据CAS特性，lock建议使用在低锁冲突的情况下。</p>
<h3 id="Lock与synchronized的区别"><a href="#Lock与synchronized的区别" class="headerlink" title="Lock与synchronized的区别"></a><strong>Lock与synchronized的区别</strong></h3><ol>
<li>Lock的加锁和解锁都是由java代码配合native方法（调用操作系统的相关方法）实现的，而synchronize的加锁和解锁的过程是由JVM管理的</li>
<li>当一个线程使用synchronize获取锁时，若锁被其他线程占用着，那么当前只能被阻塞，直到成功获取锁。而Lock则提供超时锁和可中断等更加灵活的方式，在未能获取锁的 条件下提供一种退出的机制。</li>
<li>一个锁内部可以有多个Condition实例，即有多路条件队列，而synchronize只有一路条件队列；同样Condition也提供灵活的阻塞方式，在未获得通知之前可以通过中断线程以 及设置等待时限等方式退出条件队列。</li>
<li>synchronize对线程的同步仅提供独占模式，而Lock即可以提供独占模式，也可以提供共享模式</li>
</ol>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>关键字</td>
<td>接口&#x2F;类</td>
</tr>
<tr>
<td>自动加锁和释放锁</td>
<td>需要手动调用unlock() 方法释放锁</td>
</tr>
<tr>
<td>JVM层面的锁</td>
<td>API层面的锁</td>
</tr>
<tr>
<td>非公平锁</td>
<td>可以选择公平或者非公平锁</td>
</tr>
<tr>
<td>锁是一个对象，并且锁的信息保存在了对象中</td>
<td>代码中通过int类型的state标识</td>
</tr>
<tr>
<td>有一个锁升级的过程</td>
<td>无</td>
</tr>
</tbody></table>
<h1 id="数据库-–100"><a href="#数据库-–100" class="headerlink" title="数据库 –100%"></a>数据库 –100%</h1><h2 id="MySQL–100"><a href="#MySQL–100" class="headerlink" title="MySQL–100%"></a>MySQL–100%</h2><h3 id="1、对MySQL数据库去重的关键字是什么？"><a href="#1、对MySQL数据库去重的关键字是什么？" class="headerlink" title="1、对MySQL数据库去重的关键字是什么？"></a>1、对MySQL数据库去重的关键字是什么？</h3><p>在MySQL数据库中，可以使用<code>DISTINCT</code>关键字来进行去重操作。<code>DISTINCT</code>关键字用于查询语句的<code>SELECT</code>子句中，用于返回唯一的结果集，去除重复的行。</p>
<p>例如，以下是使用<code>DISTINCT</code>关键字进行去重的示例：</p>
<p><code>SELECT DISTINCT column1, column2 FROM table_name;</code>&#x20;</p>
<p>上述示例中，<code>column1</code>和<code>column2</code>是要查询的列名，<code>table_name</code>是要查询的表名。查询结果将返回去重后的唯一行。</p>
<p>需要注意的是，<code>DISTINCT</code>关键字会对查询结果的所有列进行去重。如果只想对部分列进行去重，可以指定相应的列名。</p>
<h3 id="2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？"><a href="#2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？" class="headerlink" title="2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？"></a>2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？</h3><p>连接方式：左连接、右连接、内连接</p>
<p>使用方法：</p>
<p>左连接：select * from A LEFT JOIN B on <a target="_blank" rel="noopener" href="http://a.id=b.id/" title="A.id&#x3D;B.id">A.id&#x3D;B.id</a>;</p>
<p>右连接：select * from A RIGHT JOIN B on <a target="_blank" rel="noopener" href="http://a.id=b.id/" title="A.id&#x3D;B.id">A.id&#x3D;B.id</a>;</p>
<p>内连接：select * from A inner join B on a.xx&#x3D;b.xx;（其中inner可以省略）</p>
<p>区别：</p>
<p>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</p>
<p>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</p>
<p>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</p>
<h3 id="3、索引的基本原理"><a href="#3、索引的基本原理" class="headerlink" title="3、索引的基本原理"></a>3、索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理：就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序。</li>
<li>对排序结果生成倒排表。</li>
<li>在倒排表内容上拼上数据地址链。</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h3 id="4、说一下索引的优势和劣势？"><a href="#4、说一下索引的优势和劣势？" class="headerlink" title="4、说一下索引的优势和劣势？"></a>4、说一下索引的优势和劣势？</h3><p>优势：</p>
<p>唯一索引可以保证数据库表中每一行数据的唯一性，索引可以加快数据查询速度，减少查询时间</p>
<p>劣势：</p>
<p>创建索引和维护索引要耗费时间，索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，给表中的数据进行增、删、改的时候，索引也要动态的维护。</p>
<h3 id="5、MySQL聚簇和非聚簇索引的区别"><a href="#5、MySQL聚簇和非聚簇索引的区别" class="headerlink" title="5、MySQL聚簇和非聚簇索引的区别"></a>5、MySQL聚簇和非聚簇索引的区别</h3><p>都是B+树的数据结构</p>
<p>聚簇索引：将数据存储与索引放到了一块、并且是按照一定的顺序组织的，找到索引也就找到了数<br>据，数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是<br>相邻地存放在磁盘上的。<br>非聚簇索引：叶子节点不存储数据、存储的是数据行地址，也就是说根据索引查找到数据行的位置<br>再去磁盘查找数据，这个就有点类似一本书的目录，比如我们要找第三章第一节，那我们先在这个<br>目录里面找，找到对应的页码后再去对应的页码看文章。</p>
<p>优势：<br>1、查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要第二次查询（非覆盖索引的情况下）效率要高<br>2、聚簇索引对于范围查询的效率很高，因为其数据是按照大小排列的。<br>3、聚簇索引适合用在排序的场合，非聚簇索引不适合。</p>
<p>劣势：<br>1、维护索引很昂贵，特别是插入新行或者主键被更新导致要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片。<br>2、表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，所以建议使用int的auto_increment作为主键<br>3、如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间。</p>
<p>InnoDB中一定有主键，主键一定是聚簇索引，不手动设置、则会使用unique索引，没有unique索引，则会使用数据库内部的一个行的隐藏id来当作主键索引。在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值.</p>
<p>MyISM使用的是非聚簇索引，没有聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p>如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p>
<h3 id="6、MySQL索引的数据结构，各自优劣"><a href="#6、MySQL索引的数据结构，各自优劣" class="headerlink" title="6、MySQL索引的数据结构，各自优劣"></a>6、MySQL索引的数据结构，各自优劣</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有Hash索引，B+树索引等，InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>B+树：<br>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。因此，B+树索引被广泛应用于数据库、文件系统等场景。</p>
<p>哈希索引：<br>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5C%E5%9B%BE%E7%89%87_JS3nXXcHhV.png"></p>
<p>如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p>
<p>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</p>
<p>哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p>
<p>哈希索引也不支持多列联合索引的最左匹配规则；</p>
<p>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在哈希碰撞问题。</p>
<h3 id="7、MySQL索引的设计原则"><a href="#7、MySQL索引的设计原则" class="headerlink" title="7、MySQL索引的设计原则"></a>7、MySQL索引的设计原则</h3><p>查询更快、占用空间更小</p>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列。</li>
<li>基数较小的表，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>更新频繁字段不适合创建索引。</li>
<li>若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ol>
<h3 id="8、MySQL中B-树和B树的区别"><a href="#8、MySQL中B-树和B树的区别" class="headerlink" title="8、MySQL中B+树和B树的区别"></a>8、MySQL中B+树和B树的区别</h3><p>1、<strong>非叶子节点数据不同</strong>：</p>
<ul>
<li>B+树的非叶子节点的数据都在叶子节点中出现过，也就是叶子节点中的数据都在非叶子节点冗余一份。B树中非叶子节点中元素不会冗余。</li>
<li>B+树非叶子节点只存放指针，不存放数据，B树所有节点（叶子节点）都存放数据。</li>
</ul>
<p>2、<strong>叶子节点数据不同</strong>：B+树叶子节点存放数据，B树所有节点（非叶子节）点存放数据。数据遍布整个树结构。</p>
<p>3、<strong>时间复杂度不同</strong>：由于B+树的数据都存在叶子节点，因此B+树的时间复杂度固定为o(log n)，而B树的数据分布在每个节点中，因此时间复杂度不固定，最好为o(1).</p>
<p>4、<strong>叶子节点连接不同</strong>：B+树的叶子节点通过有序的双向链表相连，B树叶子节点不相连。</p>
<p>5、<strong>区间查询效率不同</strong>：因为第4点的原因，所以B+树去范围查询效率更快，而B树范围查询比较慢。</p>
<p>因此，存在大量范围查询的场景，适合使用B+树</p>
<p>而对大量单个key查询的场景，可以考虑B树</p>
<h3 id="9、MySQL中的锁类型有哪些？"><a href="#9、MySQL中的锁类型有哪些？" class="headerlink" title="9、MySQL中的锁类型有哪些？"></a>9、MySQL中的锁类型有哪些？</h3><p>基于锁的属性分类：共享锁、排他锁。</p>
<p>基于锁的粒度分类：行级锁(INNODB)、表级锁(INNODB、MYISAM)、页级锁(BDB引擎 )、记录锁、间隙锁、临键锁。</p>
<p><strong>共享锁(Share Lock)</strong>：</p>
<p>共享锁又称读锁，简称S锁；当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。</p>
<p><strong>排他锁（Exclusive Lock）</strong>:</p>
<p>排他锁又称写锁，简称X锁；当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避免了出现脏数据和脏读的问题.</p>
<p><strong>表锁</strong>：</p>
<p>表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；<br>特点： 粒度大，加锁简单，容易冲突</p>
<p><strong>行锁：</strong></p>
<p>行锁是指上锁的时候锁住的是表的某一行或多行记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；<br>特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高。</p>
<p><strong>记录锁(Record Lock)</strong></p>
<p>记录锁也属于行锁中的一种，只不过记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。<br>精准条件命中，并且命中的条件字段是唯一索引<br>加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</p>
<p><strong>页锁</strong>：</p>
<p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。<br>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p>
<p><strong>间隙锁(Gap Lock</strong>）</p>
<p>属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。<br>间隙锁只会出现在REPEATABLE_READ（可重复读)的事务级别中。<br>触发条件：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。<br>比如表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，5-7区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）。</p>
<p><strong>临建锁(Next-Key Lock)：</strong></p>
<p>也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住。<br>触发条件：范围查询并命中，查询命中了索引。<br>结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</p>
<h3 id="10、MySQL什么是死锁？怎么解决？"><a href="#10、MySQL什么是死锁？怎么解决？" class="headerlink" title="10、MySQL什么是死锁？怎么解决？"></a>10、MySQL什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_7bRSowfRxq.png"></p>
<p>有四个必要条件：互斥条件，请求和保持条件，环路等待条件，不剥夺条件。</p>
<p>解决死锁思路，一般就是切断环路，尽量避免并发形成环路。如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会；在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；如果业务处理不好可以用分布式事务锁或者使用乐观锁；死锁与索引密不可分，解决索引问题，需要合理优化索引。</p>
<h3 id="11、MySQL的约束有哪些？"><a href="#11、MySQL的约束有哪些？" class="headerlink" title="11、MySQL的约束有哪些？"></a>11、MySQL的约束有哪些？</h3><p>NOT NULL: 约束字段的内容一定不能为NULL。</p>
<p>UNIQUE: 约束字段唯一性，一个表允许有多个Unique约束。</p>
<p>PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。</p>
<p>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p>
<p>CHECK: 用于控制字段的值范围。保证字段值满足某一个条件。</p>
<p>DEFAULT：保存数据时，如果未指定该字段的值，则采用默认值</p>
<h3 id="12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"><a href="#12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="headerlink" title="12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？"></a>12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么？</p>
<p><strong>1、是查询条件没有命中索引？</strong></p>
<p><strong>2、是load了不需要的数据列？</strong></p>
<p><strong>3、还是数据量太大？</strong></p>
<p>所以优化也是针对这三个方向来的，<br>1、首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</p>
<p>2、分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</p>
<p>3、如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</p>
<h3 id="13、MySQL事务的基本特性和隔离级别"><a href="#13、MySQL事务的基本特性和隔离级别" class="headerlink" title="13、MySQL事务的基本特性和隔离级别"></a>13、MySQL事务的基本特性和隔离级别</h3><p>事务基本特性ACID分别是：</p>
<p><strong>原子性</strong>:指的是一个事务中的操作要么全部成功，要么全部失败。</p>
<p><strong>一致性:</strong> 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证。</p>
<p><strong>隔离性</strong>:指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p>
<p><strong>持久性</strong>：指的是一旦事务提交，所做的修改就会永久保存到数据库中。</p>
<p>隔离性有4个隔离级别，分别是：</p>
<p><strong>read uncommit</strong> 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。<br>用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。</p>
<p>**read commit **读已提交，两次读取结果不一致，叫做不可重复读。<br>不可重复读解决了脏读的问题，他只会读取已经提交的事务。<br>用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</p>
<p>**repeatable read **可重复复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p>
<p>**serializable **串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争<br>的问题。</p>
<p><strong>脏读</strong>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。<br><strong>不可重复读</strong>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<br><strong>幻读</strong>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<h3 id="14、MySQL中ACID靠什么保证的？"><a href="#14、MySQL中ACID靠什么保证的？" class="headerlink" title="14、MySQL中ACID靠什么保证的？"></a>14、MySQL中ACID靠什么保证的？</h3><p><strong>A（原子性</strong>）由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql。<br><strong>C（一致性</strong>）由其他三大特性保证、程序代码要保证业务上的一致性。<br><strong>I（隔离性</strong>）由MVCC来	保证。<br><strong>D（持久性）</strong> 由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作。宕机的时候可以从redo log恢复redolog的刷盘会在系统空闲时进行。</p>
<h3 id="15、MySQL中的MVCC是什么？"><a href="#15、MySQL中的MVCC是什么？" class="headerlink" title="15、MySQL中的MVCC是什么？"></a>15、MySQL中的MVCC是什么？</h3><p>多版本并发控制：读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务会看到自己特定版本的数据，版本链.</p>
<p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。</p>
<p>聚簇索引记录中有两个必要的隐藏列：<br>trx_id：用来存储每次对某条聚簇索引记录进行修改的时候的事务id。</p>
<p>roll_pointer：每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个<br>roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p>
<p>已提交读和可重复读的区别就在于它们生成ReadView的策略不同。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5C%E5%9B%BE%E7%89%87_DRf1QHYkSQ.png"></p>
<p>开始事务时创建ReadView，ReadView维护当前活动的事务id，即未提交的事务id，排序生成一个数组.</p>
<p>访问数据，获取数据中的事务id，对比ReadView：</p>
<p>如果在ReadView的左边（比ReadView都小），可以访问（在左边意味着该事务已经提交）</p>
<p>如果在ReadView的右边（比ReadView都大）或者就在ReadView中，不可以访问，获取roll_pointer，取上一版本重新对比（在右边意味着，该事务在ReadView生成之后出现，在ReadView中意味着该事务还未提交）</p>
<p>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。</p>
<p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别</p>
<h3 id="16、UNION和UNION-ALL的区别？"><a href="#16、UNION和UNION-ALL的区别？" class="headerlink" title="16、UNION和UNION ALL的区别？"></a>16、UNION和UNION ALL的区别？</h3><p>先说结论，因为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=UNION&spm=1001.2101.3001.7020" title="UNION">UNION</a> 操作会对结果去重且排序，所以从速度来说， UNION ALL会更胜一筹。建两张表，分别插入几条数据：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_Ud8auPETKZ.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_u4NPwgqBZh.png"></p>
<p>这两张表唯一的不同就是数据中，一个是“王五”，一个是“老六”。</p>
<p><strong>1.使用union all</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_OqMQYGx06D.png"></p>
<p>可以看出，union all 没有去重，查出了两个“张三”和“李四”；</p>
<p><strong>2.使用union</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_7zJdRv1HUX.png"></p>
<p>由此可见，“张三”和“李四”被去重了。 &#x20;<br>然后，我们再来看下两个SQL（也就是union和union all）的性能分析：</p>
<p><strong>3. 使用union all 性能分析</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_CLLJbdwA4F.png"></p>
<p><strong>4. 使用union性能分析</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%95%B0%E6%8D%AE%E5%BA%93%5CMySQL%5Cimage%5Cimage_6z9QPEo2Dq.png"></p>
<p><strong>通过性能分析可得出，union比union all 多做了操作。由此得结论：</strong></p>
<p>1.union去重并排序，union all直接返回合并的结果，不去重也不排序； &#x20;<br>2.union all比union性能好；</p>
<h3 id="17、主键使用自增ID还是UUID，为什么？"><a href="#17、主键使用自增ID还是UUID，为什么？" class="headerlink" title="17、主键使用自增ID还是UUID，为什么？"></a>17、主键使用自增ID还是UUID，为什么？</h3><p>如果是单机的话，选择自增ID；如果是分布式系统，优先考虑UUID，但还是最好公司自己有一套分布式唯一ID生产方案。自增ID：数据存储空间小，查询效率高。但是如果数据量过大,会超出自增长的值范围，多库合并，也有可能出现问题。uuid：适合大量数据的插入和更新操作，但它是无序的，插入数据效率慢，占用空间大。</p>
<h3 id="18、MySQL数据库cpu飙升的话，要怎么处理呢？"><a href="#18、MySQL数据库cpu飙升的话，要怎么处理呢？" class="headerlink" title="18、MySQL数据库cpu飙升的话，要怎么处理呢？"></a>18、MySQL数据库cpu飙升的话，要怎么处理呢？</h3><p>排查过程：</p>
<p>使用top命令观察，确定是mysqld导致还是其他原因。</p>
<p>如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。</p>
<p>找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。</p>
<p>处理：</p>
<p>kill掉这些线程(同时观察cpu使用率是否下降)，</p>
<p>进行相应的调整(比如说加索引、改sql、改内存参数)</p>
<p>重新跑SQL。</p>
<p>其他情况：</p>
<p>也有可能是每个sql消耗资源并不多，但是突然之间，有大量的session 连进来导致cpu飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。</p>
<h3 id="19、什么是存储过程？有哪些优缺点？"><a href="#19、什么是存储过程？有哪些优缺点？" class="headerlink" title="19、什么是存储过程？有哪些优缺点？"></a>19、什么是存储过程？有哪些优缺点？</h3><p>存储过程，就是一些编译好了的SQL语句，这些SQL语句代码像一个方法实现一些功能（对单表或多表的增删改查），然后给这些代码块取一个名字，在用到这个功能的时候调用即可。</p>
<p>优点：</p>
<p>存储过程是一个预编译的代码块，执行效率比较高，存储过程在服务器端运行，减少客户端的压力，允许模块化程序设计，只需要创建一次过程，以后在程序中就可以调用该过程任意次，类似方法的复用，一个存储过程替代大量SQL语句 ，可以降低网络通信量，提高通信速率，可以一定程度上确保数据安全。</p>
<p>缺点：</p>
<p>调试麻烦，可移植性不灵活，存在重新编译问题</p>
<h3 id="20、了解什么是表分区吗？表分区的好处有哪些？"><a href="#20、了解什么是表分区吗？表分区的好处有哪些？" class="headerlink" title="20、了解什么是表分区吗？表分区的好处有哪些？"></a>20、了解什么是表分区吗？表分区的好处有哪些？</h3><p>表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。</p>
<p>存储更多数据。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。和单个磁盘或者文件系统相比，可以存储更多数据。</p>
<p>优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处理，最后汇总结果。</p>
<p>分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。</p>
<p>避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问。</p>
<h3 id="21、MySQL主从同步原理"><a href="#21、MySQL主从同步原理" class="headerlink" title="21、MySQL主从同步原理"></a>21、MySQL主从同步原理</h3><p>MySQL主从同步的过程：</p>
<p>MySQL的主从复制中主要有三个线程： master（binlog dump thread）、slave（I&#x2F;O thread 、SQLthread） ，Master一条线程和Slave中的两条线程。</p>
<p>主节点 binlog，主从复制的基础是主库记录数据库的所有变更记录到 binlog。binlog 是数据库服<br>务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。</p>
<p>主节点 log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。</p>
<p>从节点 I&#x2F;O线程接收 binlog 内容，并将其写入到 relay log 文件中。</p>
<p>从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。</p>
<p>注：主从节点使用 binglog 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。</p>
<p>由于MySQL默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，日志就丢失了。由此产生两个概念。</p>
<p><strong>全同步复制</strong><br>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong><br>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p>
<h3 id="22、简述MyISAM和InnoDB的区别"><a href="#22、简述MyISAM和InnoDB的区别" class="headerlink" title="22、简述MyISAM和InnoDB的区别"></a>22、简述MyISAM和InnoDB的区别</h3><p><strong>MyISAM：</strong><br>1、不支持事务，但是每次查询都是原子的；<br>2、支持表级锁，即每次操作是对整个表加锁；<br>3、存储表的总行数；<br>4、一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；<br>5、采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。</p>
<p><strong>InnoDB</strong>：<br>1、支持ACID的事务，支持事务的四种隔离级别；<br>2、支持行级锁及外键约束：因此可以支持写并发；<br>3、不存储总行数；<br>4、一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；<br>5、主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问主键索引树；索引最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。</p>
<h3 id="23、简述MySQL中索引类型及对数据库的性能的影响"><a href="#23、简述MySQL中索引类型及对数据库的性能的影响" class="headerlink" title="23、简述MySQL中索引类型及对数据库的性能的影响"></a>23、简述MySQL中索引类型及对数据库的性能的影响</h3><p><strong>普通索引</strong>：允许被索引的数据列包含重复的值。<br><strong>唯一索引</strong>：可以保证数据记录的唯一性。<br><strong>主键</strong>：是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。<br><strong>联合索引</strong>：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引。<br><strong>全文索引</strong>：通过建立 倒排索引 ,可以极大的提升检索效率,解决判断字段是否包含的问题，是目前搜索引擎使用的一种关键技术。可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引索引可以极大的提高数据的查询速度。</p>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。<br>但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件<br>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大，如果非聚集索引很多，一旦聚集索引改变，那么所有非聚集索引都会跟着变。</p>
<h3 id="24、MySQL执行计划怎么看"><a href="#24、MySQL执行计划怎么看" class="headerlink" title="24、MySQL执行计划怎么看"></a>24、MySQL执行计划怎么看</h3><p>执行计划就是sql的执行查询的顺序，以及如何使用索引查询，返回的结果集的行数<br>EXPLAIN SELECT * from A where X&#x3D;? and Y&#x3D;?</p>
<p>1 <strong>.id</strong> ：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id的顺序是按 select 出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。</p>
<p><strong>2.selectType</strong> 表示查询中每个select子句的类型<br>SIMPLE： 表示此查询不包含 UNION 查询或子查询<br>PRIMARY： 表示此查询是最外层的查询（包含子查询）<br>SUBQUERY： 子查询中的第一个 SELECT<br>UNION： 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查<br>询的结果.<br>DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）<br><strong>3.table</strong>：表示该语句查询的表</p>
<p><strong>4.type：</strong> 优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：<br>const：通过索引一次命中，匹配一行数据<br>system: 表中只有一行记录，相当于系统表；<br>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配<br>ref: 非唯一性索引扫描,返回匹配某个值的所有<br>range: 只检索给定范围的行，使用一个索引来选择行，一般用于between、&lt;、&gt;；<br>index: 只遍历索引树；<br>ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，<br>执行效率越慢。<br>执行效率：<br>**ALL &lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system。**最好是避免ALL和index</p>
<p><strong>5.possible_keys</strong>：它表示Mysql在执行该sql语句的时候，可能用到的索引信息，仅仅是可能，实际不一定会用到。</p>
<p><strong>6.key：</strong> 此字段是 mysql 在当前查询时所真正使用到的索引。 他是possible_keys的子集</p>
<p><strong>7.key_len</strong>：表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，这也是我们优化sql时，评估索引的重要指标</p>
<p><strong>9.rows</strong>：mysql 查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大。</p>
<p><strong>10.filtered：</strong> 返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少</p>
<p><strong>11.extra</strong><br>using filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有<br>using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。<br>using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往<br>往说明性能不错。<br>using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不<br>高，建议优化。<br>using where ：sql使用了where过滤,效率较高。</p>
<h3 id="25、MySQL常见优化手段"><a href="#25、MySQL常见优化手段" class="headerlink" title="25、MySQL常见优化手段"></a>25、MySQL常见优化手段</h3><p>（1）尽量选择较小的列</p>
<p>（2）将where中用的比较频繁的字段建立索引</p>
<p>（3）select子句中避免使用‘ *’</p>
<p>（4）避免在索引列上使用计算、not in 和&lt;&gt;等操作</p>
<p>（5）当只需要一行数据的时候使用limit 1</p>
<p>（6）保证单表数据不超过200W，适时分割表。针对查询较慢的语句，可以使用explain 来分析该语句具体的执行情况。</p>
<p>（7）避免改变索引列的类型。</p>
<p>（8）选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。</p>
<p>（9）避免在索引列上面进行计算。</p>
<p>（10）能用关联查询的不要用子查询</p>
<p>（11）尽量缩小子查询的结果</p>
<h1 id="网络–60"><a href="#网络–60" class="headerlink" title="网络–60%"></a>网络–60%</h1><h2 id="Netty–不看（快速学）"><a href="#Netty–不看（快速学）" class="headerlink" title="Netty–不看（快速学）"></a>Netty–不看（快速学）</h2><h3 id="1-为什么Netty适合做网络编程？"><a href="#1-为什么Netty适合做网络编程？" class="headerlink" title="1 为什么Netty适合做网络编程？"></a>1 为什么Netty适合做网络编程？</h3><p>Netty是一个基于Java的高性能网络编程框架，它被广泛用于构建可扩展的、高性能的网络应用程序。以下是一些原因说明为什么Netty适合做网络编程：</p>
<ol>
<li>强大的抽象和组件：Netty提供了一组强大的抽象和可重用的组件，如事件模型、处理器链、编解码器等。这些组件使得网络编程变得更加简单和灵活，开发者可以根据需求自由组合和定制。</li>
<li>高性能：Netty采用了基于事件驱动的异步非阻塞IO模型，利用了Java NIO（New IO）的特性，能够处理大量的并发连接。它的线程模型和内存管理机制也经过优化，能够最大限度地提高网络应用程序的性能和吞吐量。</li>
<li>完善的协议支持：Netty提供了丰富的协议支持，包括TCP、UDP、HTTP、WebSocket等。它内置了许多常用的协议编解码器，可以轻松地进行协议的解析和编码，简化了网络应用程序的开发过程。</li>
<li>可扩展性：Netty的设计非常灵活，支持自定义的协议、编解码器和处理器。它提供了丰富的扩展点和钩子函数，可以方便地进行功能扩展和定制，满足各种复杂的业务需求。</li>
<li>成熟稳定：Netty是一个成熟稳定的开源项目，经过了广泛的实际应用和验证。它拥有活跃的社区和强大的生态系统，提供了大量的文档、示例和工具，使得开发者能够快速上手并解决问题。</li>
</ol>
<p>综上所述，Netty具有强大的抽象和组件、高性能、完善的协议支持、可扩展性和成熟稳定等特点，使其成为一种优秀的选择用于网络编程。</p>
<h3 id="2-Netty性能好的原因是什么？"><a href="#2-Netty性能好的原因是什么？" class="headerlink" title="2 Netty性能好的原因是什么？"></a>2 Netty性能好的原因是什么？</h3><p>Netty 是一个高性能的网络应用框架，其性能好的原因主要有以下几点：</p>
<ol>
<li>异步非阻塞：Netty 使用异步非阻塞的 I&#x2F;O 模型，可以处理大量的并发连接而不需要为每个连接分配一个线程。这种模型减少了线程切换的开销，提高了系统的吞吐量和响应速度。</li>
<li>高度可定制化：Netty 提供了丰富的可定制化选项，可以根据应用的需求进行灵活的配置。开发者可以自定义编解码器、处理器链、线程模型等，以适应不同的网络应用场景。</li>
<li>零拷贝：Netty 支持零拷贝技术，可以避免数据在内存之间的多次拷贝，减少了内存的使用和数据传输的开销，提高了性能。</li>
<li>内存管理优化：Netty 使用了内存池技术，可以重用内存，减少了频繁的内存分配和回收操作，提高了内存的利用率和性能。</li>
<li>模块化设计：Netty 的设计模块化，各个功能模块之间解耦，可以根据需要选择性地使用特定的模块，避免了不必要的性能损耗。</li>
</ol>
<p>总的来说，Netty 的高性能得益于其异步非阻塞的 I&#x2F;O 模型、可定制化的设计、零拷贝技术、内存管理优化和模块化架构等多个方面的优势。这些特性使得 Netty 成为开发高性能网络应用的理想选择。</p>
<h3 id="3-Netty的零拷贝是怎么实现的？"><a href="#3-Netty的零拷贝是怎么实现的？" class="headerlink" title="3 Netty的零拷贝是怎么实现的？"></a>3 Netty的零拷贝是怎么实现的？</h3><p>Netty 实现零拷贝主要依赖于以下两个技术：</p>
<ol>
<li>零拷贝文件传输：Netty 使用了操作系统提供的零拷贝机制，例如 Linux 下的 sendfile 和 splice 系统调用。这些系统调用可以直接将文件数据从磁盘读取到网络套接字，或者从一个套接字传输到另一个套接字，而无需经过用户空间和内核空间之间的数据拷贝。</li>
<li>零拷贝内存传输：Netty 使用了 Direct Memory Buffer（直接内存缓冲区）来实现零拷贝内存传输。直接内存缓冲区是一种直接分配在堆外内存的缓冲区，可以通过操作系统的文件描述符直接读写数据，避免了数据在用户空间和内核空间之间的拷贝。</li>
</ol>
<p>通过使用这些零拷贝技术，Netty 在进行数据传输时可以避免将数据从一个缓冲区拷贝到另一个缓冲区，从而减少了数据拷贝的次数和数据在内存之间的传输开销。这样可以提高数据传输的效率和性能。</p>
<p>需要注意的是，零拷贝并不是在所有情况下都能完全避免数据拷贝。在某些情况下，仍然需要进行少量的数据拷贝操作，例如数据的解码和编码过程。但是相比传统的拷贝方式，Netty 的零拷贝机制可以最大程度地减少数据拷贝的次数，提高了性能。</p>
<h3 id="4-能不能说一说Netty的无锁化设计？"><a href="#4-能不能说一说Netty的无锁化设计？" class="headerlink" title="4 能不能说一说Netty的无锁化设计？"></a>4 能不能说一说Netty的无锁化设计？</h3><p>Netty 的无锁化设计是指在多线程环境下，尽量减少对共享数据的锁使用，以避免锁竞争和线程阻塞，从而提高系统的并发性能。Netty 在实现无锁化设计时主要采用了以下几种技术：</p>
<ol>
<li>并发容器：Netty 使用了并发容器来替代传统的线程安全集合类。例如，使用 ConcurrentMap 替代 HashMap，使用 ConcurrentLinkedQueue 替代 LinkedList，这些并发容器底层使用了 CAS（Compare and Swap）等无锁算法来实现线程安全。</li>
<li>原子操作：Netty 使用了原子操作来实现对共享数据的无锁访问。原子操作是一种不可中断的操作，可以保证在多线程环境下对共享数据的操作是原子性的。Netty 使用了 Java 提供的原子类，如 AtomicBoolean、AtomicInteger 等，来实现无锁访问。</li>
<li>事件驱动模型：Netty 的核心思想是基于事件驱动的模型，通过事件的发布和订阅来实现线程间的解耦和通信。这种模型避免了线程间的锁竞争，每个线程只需要处理自己感兴趣的事件，大大提高了系统的并发性能。</li>
<li>非阻塞 I&#x2F;O：Netty 使用了非阻塞的 I&#x2F;O 模型，通过异步的方式处理网络 I&#x2F;O 操作，避免了线程在等待 I&#x2F;O 完成时的阻塞，提高了系统的并发性能。</li>
</ol>
<p>通过这些无锁化设计的技术手段，Netty 在多线程环境下能够更好地利用计算资源，提高系统的并发性能和可伸缩性。同时，无锁化设计也减少了线程间的竞争和线程阻塞，避免了潜在的死锁和性能瓶颈问题。</p>
<h3 id="5-Netty的线程模型是怎么样的？"><a href="#5-Netty的线程模型是怎么样的？" class="headerlink" title="5 Netty的线程模型是怎么样的？"></a>5 Netty的线程模型是怎么样的？</h3><p>Netty的线程模型是基于事件驱动的，它采用了多线程池的架构来处理网络请求和事件。以下是Netty的线程模型的主要特点：</p>
<ol>
<li><strong>Boss线程池（Acceptors）</strong>：这个线程池用于处理新的连接请求，通常会绑定到一个端口，并且负责接受客户端的连接。每个Boss线程都会监听一个独立的套接字，用于接受客户端的连接请求。</li>
<li><strong>Worker线程池（EventLoopGroup）</strong>：一旦连接建立，客户端的请求会被传递给Worker线程池中的一个EventLoop进行处理。Worker线程池负责处理I&#x2F;O事件，如读取和写入数据，以及执行用户定义的业务逻辑。Netty通常会有多个Worker线程，每个线程都会处理多个连接，通过事件循环（EventLoop）来处理这些连接上的事件。</li>
<li><strong>EventLoop（事件循环）</strong>：每个Worker线程都包含一个EventLoop，它负责处理一个或多个连接上的事件。EventLoop会持续地从事件队列中获取事件，然后执行相应的操作，比如读取数据、处理请求、写入数据等。每个连接都会被分配到一个特定的EventLoop，确保了事件的顺序性和线程的安全性。</li>
<li><strong>任务队列</strong>：Netty使用任务队列来存储需要处理的事件，这些事件可以是读写操作、用户自定义的任务或其他事件。这些事件会被EventLoop从队列中取出并执行。</li>
</ol>
<p>总体来说，Netty的线程模型允许多个连接共享同一个线程，避免了线程创建和销毁的开销，提高了系统的性能和效率。通过事件驱动的方式，Netty能够高效地处理大量的并发连接，适用于构建高性能、可扩展的网络应用程序。需要注意的是，具体的线程数目和配置可以根据应用程序的需求进行调整。</p>
<h3 id="6-Netty如何解决TCP粘包、拆包的问题的？"><a href="#6-Netty如何解决TCP粘包、拆包的问题的？" class="headerlink" title="6 Netty如何解决TCP粘包、拆包的问题的？"></a>6 Netty如何解决TCP粘包、拆包的问题的？</h3><p>Netty提供了多种解决TCP粘包和拆包问题的机制，帮助开发者处理在网络传输过程中可能出现的数据分片问题。这些机制可以确保数据在发送和接收时能够正确地分割和组装，从而避免粘包和拆包的困扰。</p>
<p>以下是Netty解决TCP粘包和拆包问题的一些常见方法：</p>
<ol>
<li><strong>固定长度解码器（FixedLengthFrameDecoder）</strong>：这个解码器会根据指定的固定长度对接收到的数据进行切割。无论数据内容如何，都会按照固定长度进行拆分，从而确保每个数据包的长度是一致的。</li>
<li><strong>行尾分隔符解码器（LineBasedFrameDecoder）</strong>：适用于基于文本协议的场景，该解码器会根据行尾分隔符（如换行符）将数据切分为不同的数据包。这样，每个数据包都会包含一行完整的文本。</li>
<li><strong>分隔符解码器（DelimiterBasedFrameDecoder）</strong>：类似于行尾分隔符解码器，但可以自定义分隔符。开发者可以指定特定的字节序列作为分隔符，用于切分数据。</li>
<li><strong>自定义解码器</strong>：Netty还允许开发者根据具体的协议和业务需求创建自定义的解码器。这样可以更灵活地处理数据的分割和组装。</li>
</ol>
<p>这些解码器通常作为ChannelPipeline中的一部分，用于解决数据在网络传输过程中可能引发的粘包和拆包问题。开发者可以根据自己的需求选择合适的解码器，或者结合多种解码器来处理不同类型的数据。</p>
<p>需要注意的是，虽然这些解码器可以很好地处理大部分粘包和拆包问题，但在一些复杂的情况下可能仍需要开发者进行额外的处理和调优。</p>
<h3 id="7-Netty的Buffer为什么好用"><a href="#7-Netty的Buffer为什么好用" class="headerlink" title="7 Netty的Buffer为什么好用"></a>7 Netty的Buffer为什么好用</h3><p>Netty的Buffer在网络编程中被认为非常好用，有以下几个方面的优势：</p>
<ol>
<li><strong>内存管理优化</strong>：Netty的Buffer实现了内存池技术，能够有效地管理内存的分配和释放。这可以减少频繁的内存分配和垃圾回收，从而提高性能和减少延迟。</li>
<li><strong>零拷贝技术</strong>：Netty的Buffer支持零拷贝（Zero-Copy）技术，这意味着在数据传输过程中可以避免不必要的数据拷贝，减少了CPU和内存的负担，提高了数据传输的效率。</li>
<li><strong>支持多种数据类型</strong>：Netty的Buffer提供了多种类型的Buffer，如堆内存缓冲区（Heap Buffer）和直接内存缓冲区（Direct Buffer），可以根据需要选择合适的Buffer类型来优化性能。</li>
<li><strong>灵活的API</strong>：Netty的Buffer提供了丰富的操作方法，可以轻松地进行数据读写、切片、复制等操作，使得处理数据变得更加方便和灵活。</li>
<li><strong>与ChannelPipeline集成</strong>：Netty的Buffer与ChannelPipeline紧密集成，可以方便地在不同的处理器（如编码器、解码器、处理器等）之间传递数据，简化了数据处理的流程。</li>
<li><strong>可扩展性和定制性</strong>：Netty允许开发者基于自己的需求扩展和定制Buffer的行为，从而实现更高级别的功能和优化。</li>
</ol>
<p>综上所述，Netty的Buffer在性能、内存管理、数据传输效率以及灵活性方面的优势，使得它成为了网络编程中一个非常实用和强大的工具。无论是处理小规模数据还是大规模数据，Netty的Buffer都能够有效地提升网络应用的性能和可靠性。</p>
<h3 id="8-说说-Netty-的对象池技术？"><a href="#8-说说-Netty-的对象池技术？" class="headerlink" title="8 说说 Netty 的对象池技术？"></a>8 说说 Netty 的对象池技术？</h3><p>Netty的对象池技术是一种用于管理和重用对象的机制，旨在提高内存使用效率和性能。在网络编程中，频繁地创建和销毁对象可能会导致内存碎片化和额外的垃圾回收开销，从而影响应用程序的性能。Netty引入了对象池技术来缓解这些问题。</p>
<p>在Netty中，对象池主要用于管理两种类型的对象：ByteBuf（字节缓冲区）和ChannelHandlerContext（通道处理上下文）。以下是关于Netty对象池技术的一些关键点：</p>
<ol>
<li><strong>ByteBuf对象池</strong>：Netty的ByteBuf是用于处理网络数据的字节缓冲区。通过使用ByteBuf对象池，Netty可以重用已经分配的字节缓冲区，避免频繁地创建和销毁这些对象。这有助于减少内存分配和垃圾回收的开销，提高数据传输效率和应用程序性能。</li>
<li><strong>ChannelHandlerContext对象池</strong>：Netty中的ChannelHandlerContext代表了处理器（如编码器、解码器、处理器等）与Channel之间的关联关系。通过使用ChannelHandlerContext对象池，Netty可以在数据处理过程中重用上下文对象，减少上下文对象的创建和销毁开销，从而提高数据处理的效率。</li>
<li><strong>资源回收和管理</strong>：Netty的对象池技术能够自动地管理对象的生命周期和资源回收。当对象不再需要时，它们会被返回到对象池，以便稍后重用。这有助于避免内存泄漏和资源浪费。</li>
<li><strong>配置和定制</strong>：Netty允许开发者根据应用程序的需求进行对象池的配置和定制。开发者可以设置池的大小、对象的生存时间等参数，以适应不同的场景和负载。</li>
</ol>
<p>综上所述，Netty的对象池技术是一项重要的功能，能够有效地提高网络应用程序的内存使用效率和性能，特别是在处理大规模数据和高并发情况下。通过重用对象，Netty能够降低资源开销，提高数据传输效率，并且在一定程度上减少内存碎片化问题。</p>
<h3 id="9-Netty有哪些序列化协议？"><a href="#9-Netty有哪些序列化协议？" class="headerlink" title="9 Netty有哪些序列化协议？"></a>9 Netty有哪些序列化协议？</h3><p>Netty并不直接提供序列化协议，但它可以与各种序列化协议进行集成。序列化是将对象转换为可在网络上传输或持久化存储的格式的过程。Netty可以与多种序列化协议一起使用，以根据应用程序的需要进行数据的编码和解码。以下是一些常见的序列化协议，可以与Netty一起使用：</p>
<ol>
<li><strong>Java自带的序列化（Java Serialization）</strong>：Java自带了一套对象序列化机制，可以将Java对象转换为字节流进行传输。但是，这种序列化方式在性能和灵活性方面可能存在问题，因此在高性能网络应用中可能不是首选。</li>
<li><strong>JSON（JavaScript Object Notation）</strong>：JSON是一种轻量级的数据交换格式，易于阅读和编写，适用于各种编程语言。Netty可以与JSON库（如Jackson、Gson等）一起使用，将对象转换为JSON格式进行传输。</li>
<li><strong>Protobuf（Protocol Buffers）</strong>：Protobuf是一种由Google开发的高效的二进制序列化协议，具有很高的性能和紧凑的数据表示。Netty可以与Protobuf集成，使用Protobuf生成的类来进行对象的编码和解码。</li>
<li><strong>MessagePack</strong>：MessagePack是一种基于二进制的轻量级序列化格式，具有高性能和紧凑的数据表示。它可以与Netty一起使用，实现数据的传输和解析。</li>
<li><strong>Thrift</strong>：Thrift是由Apache开发的一种跨语言的序列化协议，支持多种编程语言，并具有高性能和可扩展性。Netty可以与Thrift一起使用，实现对象的序列化和反序列化。</li>
<li><strong>Avro</strong>：Avro是另一种由Apache开发的序列化框架，旨在提供紧凑的二进制格式和动态数据模型。Netty可以与Avro一起使用，实现数据的编码和解码。</li>
</ol>
<p>这些序列化协议可以根据应用程序的需求进行选择，根据性能、数据大小、跨语言支持等因素来决定使用哪种协议。Netty的灵活性使得它能够与各种序列化协议集成，以实现高效的网络通信。</p>
<h3 id="10-Netty-中用了哪些设计模式？"><a href="#10-Netty-中用了哪些设计模式？" class="headerlink" title="10 Netty 中用了哪些设计模式？"></a>10 Netty 中用了哪些设计模式？</h3><p>在Netty中使用了许多设计模式来实现高效的网络通信和处理。以下是一些Netty中使用的设计模式：</p>
<ol>
<li><strong>工厂模式（Factory Pattern）</strong>：Netty使用工厂模式来创建不同类型的通道、处理器和其他组件，隐藏了对象创建的细节，使代码更具可维护性和扩展性。</li>
<li><strong>装饰器模式（Decorator Pattern）</strong>：Netty的处理器链（Pipeline）机制使用了装饰器模式。每个处理器都可以在收到数据、处理数据和传递数据时添加额外的逻辑，这使得用户可以轻松地定制数据的处理流程。</li>
<li><strong>观察者模式（Observer Pattern）</strong>：Netty中的事件和事件监听器机制使用了观察者模式。通道状态变化、数据读写等事件可以被观察，而用户可以注册相应的监听器来处理这些事件。</li>
<li><strong>责任链模式（Chain of Responsibility Pattern）</strong>：Netty的处理器链（Pipeline）本质上就是一个责任链，每个处理器负责特定的任务，可以在链中按顺序处理数据，将复杂的处理逻辑拆分成独立的模块。</li>
<li><strong>单例模式（Singleton Pattern）</strong>：Netty中的一些关键组件，如线程池、事件循环，都使用了单例模式确保只有一个实例存在，从而节省资源并确保一致性。</li>
<li><strong>模板方法模式（Template Method Pattern）</strong>：Netty的一些类提供了模板方法，定义了通用的处理流程和步骤，而将具体的实现细节留给子类来实现。</li>
<li><strong>策略模式（Strategy Pattern）</strong>：Netty中的一些组件，如编码器和解码器，可以根据不同的业务需求进行替换，这种灵活性符合策略模式的思想。</li>
<li><strong>适配器模式（Adapter Pattern）</strong>：Netty中的适配器可以帮助用户将不同的数据格式、协议等转换成统一的格式，以适应不同的通信需求。</li>
</ol>
<p>这些设计模式的使用使得Netty能够提供高度灵活、高性能和可扩展的网络通信框架，满足各种不同应用场景的需求。</p>
<h2 id="Tomcat-100"><a href="#Tomcat-100" class="headerlink" title="Tomcat 100%"></a>Tomcat 100%</h2><h3 id="1、Tomcat的缺省端口是多少，怎么修改？"><a href="#1、Tomcat的缺省端口是多少，怎么修改？" class="headerlink" title="1、Tomcat的缺省端口是多少，怎么修改？"></a>1、Tomcat的缺省端口是多少，怎么修改？</h3><p>默认端口为8080，可以通过在tomcat安装包conf目录下，service.xml中的Connector元素的port属性来修改端口。</p>
<h3 id="2、tomcat-有哪几种Connector-运行模式-优化-？"><a href="#2、tomcat-有哪几种Connector-运行模式-优化-？" class="headerlink" title="2、tomcat 有哪几种Connector 运行模式(优化)？"></a>2、tomcat 有哪几种Connector 运行模式(优化)？</h3><p>这三种模式的不同之处如下：</p>
<p>BIO：一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7版本或更低版本中，在Linux系统中默认使用这种方式。</p>
<p>NIO：利用Java的异步IO处理，可以通过少量的线程处理大量的请求。tomcat8.0.x中默认使用的是NIO。Tomcat7必须修改Connector配置来启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>APR：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。</p>
<h3 id="3、Tomcat有几种部署方式？"><a href="#3、Tomcat有几种部署方式？" class="headerlink" title="3、Tomcat有几种部署方式？"></a>3、Tomcat有几种部署方式？</h3><p>利用Tomcat的自动部署：把web应用拷贝到webapps目录（生产环境不建议放在该目录中）。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</p>
<p>使用Manager App控制台部署：在tomcat主页点击“Manager App” 进入应用管理控制台，可以指定一个web应用的路径或war文件。修改conf&#x2F;server.xml文件部署：在server.xml文件中，增加Context节点可以部署应用。</p>
<p>增加自定义的Web部署文件：在conf&#x2F;Catalina&#x2F;localhost&#x2F;路径下增加 xyz.xml文件，内容是Context节点，可以部署应用。</p>
<h3 id="4、tomcat容器是如何创建servlet类实例？用到了什么原理？"><a href="#4、tomcat容器是如何创建servlet类实例？用到了什么原理？" class="headerlink" title="4、tomcat容器是如何创建servlet类实例？用到了什么原理？"></a>4、tomcat容器是如何创建servlet类实例？用到了什么原理？</h3><p>当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求实例化。</p>
<h3 id="5、tomcat-如何优化？"><a href="#5、tomcat-如何优化？" class="headerlink" title="5、tomcat 如何优化？"></a>5、tomcat 如何优化？</h3><p>tomcat作为Web服务器，它的处理性能直接关系到用户体验，下面是几种常见的优化措施：</p>
<p>掉对web.xml的监视，把jsp提前编辑成Servlet。有富余物理内存的情况，加大tomcat使用的jvm的内存</p>
<p>服务器所能提供CPU、内存、硬盘的性能对处理能力有决定性影响。</p>
<p>对于高并发情况下会有大量的运算，那么CPU的速度会直接影响到处理速度。内存在大量数据处理的情况下，将会有较大的内存容量需求，可以用-Xmx -Xms -XX:MaxPermSize等参数对内存不同功能块进行划分。我们之前就遇到过内存分配不足，导致虚拟机一直处于full GC，从而导致处理能力严重下降。硬盘主要问题就是读写性能，当大量文件进行读写时，磁盘极容易成为性能瓶颈。最好的办法还是利用下面提到的缓存。利用缓存和压缩</p>
<p>对于静态页面最好是能够缓存起来，这样就不必每次从磁盘上读。这里我们采用了Nginx作为缓存服务器，将图片、css、js文件都进行了缓存，有效地减少了后端tomcat的访问。另外，为了能加快网络传输速度，开启gzip压缩也是必不可少的。但考虑到tomcat已经需要处理很多东西了，所以把这个压缩的工作就交给前端的Nginx来完成。除了文本可以用gzip压缩，其实很多图片也可以用图像处理工具预先进行压缩，找到一个平衡点可以让画质损失很小而文件可以减小很多。曾经我就见过一个图片从300多kb压缩到几十kb，自己几乎看不出来区别。采用集群</p>
<p>单个服务器性能总是有限的，最好的办法自然是实现横向扩展，那么组建tomcat集群是有效提升性能的手段。我们还是采用了Nginx来作为请求分流的服务器，后端多个tomcat共享session来协同工作。</p>
<p>优化线程数优化</p>
<p>找到Connector port&#x3D;”8080” protocol&#x3D;”HTTP&#x2F;1.1”，增加maxThreads和acceptCount属性（使acceptCount大于等于maxThreads），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot;acceptCount=&quot;500&quot; maxThreads=&quot;400&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>maxThreads：tomcat可用于请求处理的最大线程数，默认是200 minSpareThreads：tomcat初始线程数，即最小空闲线程数 maxSpareThreads：tomcat最大空闲线程数，超过的会被关闭 acceptCount：当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理.默认100</p>
<p>使用线程池优化</p>
<p>在server.xml中增加executor节点，然后配置connector的executor属性，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;req-exec-&quot;maxThreads=&quot;1000&quot; minSpareThreads=&quot;50&quot;maxIdleTime=&quot;60000&quot;/&gt;&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;executor=&quot;tomcatThreadPool&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>namePrefix：线程池中线程的命名前缀 maxThreads：线程池的最大线程数 minSpareThreads：线程池的最小空闲线程数 maxIdleTime：超过最小空闲线程数时，多的线程会等待这个时间长度，然后关闭 threadPriority：线程优先级</p>
<p>注：当tomcat并发用户量大的时候，单个jvm进程确实可能打开过多的文件句柄，这时会报java.net.SocketException:Too many open files错误。可使用下面步骤检查：</p>
<p>ps -ef |grep tomcat 查看tomcat的进程ID，记录ID号，假设进程ID为10001 lsof -p 10001|wc -l 查看当前进程id为10001的 文件操作数 使用命令：ulimit -a 查看每个用户允许打开的最大文件数</p>
<p>启动速度优化</p>
<p>删除没用的web应用：因为tomcat启动每次都会部署这些应用。关闭WebSocket：websocket-api.jar和tomcat-websocket.jar。随机数优化：设置JVM参数：-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom。内存优化</p>
<p>因为tomcat启动起来后就是一个java进程，所以这块可以参照JVM部分的优化思路。堆内存相关参数，比如说：</p>
<p>-Xms：虚拟机初始化时的最小堆内存。</p>
<p>-Xmx：虚拟机可使用的最大堆内存。-Xms与-Xmx设成一样的值，避免JVM因为频繁的GC导致性能大起大落</p>
<p>-XX:MaxNewSize：新生代占整个堆内存的最大值。</p>
<p>另外还有方法区参数调整（注意：JDK版本）、垃圾收集器等优化。JVM相关参数请看：手把手教你设置JVM调优参数</p>
<h3 id="6、熟悉tomcat的哪些配置？"><a href="#6、熟悉tomcat的哪些配置？" class="headerlink" title="6、熟悉tomcat的哪些配置？"></a>6、熟悉tomcat的哪些配置？</h3><p>Context(表示一个web应用程序，通常为WAR文件，关于WAR的具体信息见servlet规范)标签。</p>
<p>docBase：该web应用的文档基准目录（Document Base，也称为Context Root），或者是WAR文件的路径。可以使绝对路径，也可以使用相对于context所属的Host的appBase路径。</p>
<p>path：表示此web应用程序的url的前缀，这样请求的url为<a target="_blank" rel="noopener" href="http://localhost:8080/path/%E3%80%82">http://localhost:8080/path/。</a></p>
<p>reloadable：这个属性非常重要，如果为true，则tomcat会自动检测应用程序的&#x2F;WEB-INF&#x2F;lib和&#x2F;WEB-INF&#x2F;classes目录的变化，自动装载新的应用程序，我们可以在不重启tomcat的情况下改变应用程序。</p>
<p>useNaming：如果希望Catalina为该web应用使用一个JNDI InitialContext对象，设为true。该InitialialContext符合J2EE平台的约定，缺省值为true。</p>
<p>workDir：Context提供的临时目录的路径，用于servlet的临时读&#x2F;写。利用javax.servlet.context.tempdir属性，servlet可以访问该目录。如果没有指定，使用$CATALINA_HOME&#x2F;work下一个合适的目录。</p>
<p>swallowOutput：如果该值为true，System.out和System.err的输出被重定向到web应用的logger。如果没有指定，缺省值为false</p>
<p>debug：与这个Engine关联的Logger记录的调试信息的详细程度。数字越大，输出越详细。如果没有指定，缺省为0。</p>
<p>host(表示一个虚拟主机)标签。</p>
<p>name：指定主机名。</p>
<p>appBase：应用程序基本目录，即存放应用程序的目录。</p>
<p>unpackWARs：如果为true，则tomcat会自动将WAR文件解压，否则不解压，直接从WAR文件中运行应用程序。</p>
<p>Logger(表示日志，调试和错误信息)标签。</p>
<p>className：指定logger使用的类名，此类必须实现org.apache.catalina.Logger接口。</p>
<p>prefix：指定log文件的前缀。</p>
<p>suffix：指定log文件的后缀。</p>
<p>timestamp：如果为true，则log文件名中要加入时间，如下例：localhost_log.2001-10-04.txt。</p>
<h2 id="计算机网络-选择（原理必须搞清楚）选择性学习"><a href="#计算机网络-选择（原理必须搞清楚）选择性学习" class="headerlink" title="计算机网络 -选择（原理必须搞清楚）选择性学习"></a>计算机网络 -选择（原理必须搞清楚）选择性学习</h2><h3 id="1、介绍一下OSI七层模型？"><a href="#1、介绍一下OSI七层模型？" class="headerlink" title="1、介绍一下OSI七层模型？"></a>1、介绍一下OSI七层模型？</h3><p>当然，我很乐意为您介绍一下OSI七层模型。</p>
<p>OSI七层模型是一个用于描述计算机网络通信协议的框架，它由国际标准化组织（ISO）于1984年制定并发布。该模型将网络通信过程分解为七个不同的层次，每个层次都负责特定的功能，从物理连接到应用程序的交互，以实现数据在不同设备之间的传输和交换。以下是每个层次的简要介绍：</p>
<ol>
<li><strong>物理层（Physical Layer）：</strong> 这是最底层的层次，负责处理物理媒介和电信号传输。它定义了连接硬件设备的标准，例如电缆类型、电压规范等。</li>
<li><strong>数据链路层（Data Link Layer）：</strong> 此层负责在直接相连的两个设备之间传输数据帧，通过物理地址（MAC地址）进行寻址和识别。它还处理错误检测和校正，确保可靠的数据传输。</li>
<li><strong>网络层（Network Layer）：</strong> 网络层负责在不同网络之间路由数据包，通过IP地址进行寻址。它处理数据包的传输路径选择和逻辑寻址，以实现跨网络的通信。</li>
<li><strong>传输层（Transport Layer）：</strong> 传输层负责在端到端的通信中提供数据传输的可靠性和错误检测。它管理数据的分段、传输控制、流量控制等，常见的传输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）。</li>
<li><strong>会话层（Session Layer）：</strong> 会话层负责建立、管理和终止应用程序之间的会话连接。它处理会话的控制和同步，确保数据正确传输并在需要时进行恢复。</li>
<li><strong>表示层（Presentation Layer）：</strong> 表示层负责数据的格式化、加密、压缩等处理，以确保不同系统间数据的交换和解释能够无障碍地进行。</li>
<li><strong>应用层（Application Layer）：</strong> 应用层是最顶层的层次，直接为用户提供网络服务和应用程序。它包含了各种应用，如电子邮件、文件传输、远程访问等。</li>
</ol>
<p>通过这种分层的方式，OSI模型帮助网络工程师和开发者更好地理解和设计网络协议、通信和应用。然而，需要注意的是，实际网络协议不一定都严格按照这七层模型来设计，而是根据实际需求和技术进行了调整和扩展。</p>
<h3 id="2、什么是TCP的粘包、拆包"><a href="#2、什么是TCP的粘包、拆包" class="headerlink" title="2、什么是TCP的粘包、拆包"></a>2、什么是TCP的粘包、拆包</h3><p>TCP（Transmission Control Protocol）是一种常用的传输层协议，用于在计算机网络上可靠地传输数据。在TCP通信中，粘包（Packet Sticking）和拆包（Packet Splitting）是两个可能出现的问题，涉及到数据的传输和接收过程中的数据分割和组合。</p>
<p><strong>粘包（Packet Sticking）：</strong> 粘包指的是在发送端将多个小数据包连续发送，而接收端却可能一次性接收到了多个小数据包，这些数据包“粘”在一起，无法准确分辨出每个数据包的界限。这可能是因为发送端的数据写入缓冲区比较快，而接收端读取数据的速度较慢，导致多个数据包被一次性读取。粘包会导致接收端无法正确解析数据，从而影响数据的处理和解释。</p>
<p><strong>拆包（Packet Splitting）：</strong> 拆包指的是在发送端将一个大数据包分割成多个小数据包发送，而接收端却可能无法正确地将这些小数据包组合成完整的大数据包。这可能是因为发送端的数据分割不当，或者接收端没有足够的信息来确定如何正确组合这些小数据包。拆包会导致接收端无法还原原始数据，从而造成数据的错误或丢失。</p>
<p>为了解决粘包和拆包问题，通常需要在应用层设计一些协议或者采用一些技术手段，例如：</p>
<ol>
<li><strong>消息长度字段：</strong> 在消息的开头加入一个固定长度的字段，用来表示后续消息的长度，接收端可以根据这个字段来准确地分割和组合数据包。</li>
<li><strong>消息分隔符：</strong> 在消息的末尾加入一个特定的分隔符，接收端通过识别分隔符来分割数据包。</li>
<li><strong>使用固定长度消息：</strong> 将所有消息都固定到同样的长度，不足的部分用填充数据补齐。</li>
<li><strong>应用层协议设计：</strong> 在应用层定义明确的消息格式和协议，确保发送端和接收端都按照相同的规则进行数据的分割和组合。</li>
</ol>
<p>总之，处理粘包和拆包问题需要在应用层进行合适的设计和处理，以确保数据在传输过程中能够正确地分割和组合，保证通信的可靠性和准确性。</p>
<h3 id="3、ARP-与-RARP-的区别是什么？"><a href="#3、ARP-与-RARP-的区别是什么？" class="headerlink" title="3、ARP 与 RARP 的区别是什么？"></a>3、ARP 与 RARP 的区别是什么？</h3><p>ARP（Address Resolution Protocol）和RARP（Reverse Address Resolution Protocol）都是用于在网络通信中解决IP地址和物理MAC地址之间映射关系的协议，但它们的功能和应用场景有所不同。</p>
<ol>
<li><strong>ARP（Address Resolution Protocol）：</strong> ARP用于将一个已知的IP地址解析成对应的物理MAC地址。在一个局域网中，当主机需要与另一个主机通信时，它会先检查自己的ARP缓存表，看是否已经有目标IP地址对应的MAC地址。如果没有，它就会发送一个ARP请求广播，询问局域网内是否有响应该IP地址的主机。目标主机收到该请求后，会发送一个ARP响应，包含自己的MAC地址。这样，请求主机就可以得到目标主机的MAC地址，从而建立通信。</li>
<li><strong>RARP（Reverse Address Resolution Protocol）：</strong> RARP与ARP相反，它用于将已知的物理MAC地址解析成对应的IP地址。主要应用于无盘工作站等设备，在启动时需要获取自己的IP地址，但是这些设备没有预设IP地址，只有MAC地址。设备启动时会发送一个RARP请求广播，请求分配一个IP地址。RARP服务器会收到请求后，查找MAC地址对应的IP地址，然后将IP地址发送回设备，使设备能够配置自己的IP地址。</li>
</ol>
<p>总结区别：</p>
<ul>
<li>ARP解析IP地址到MAC地址，而RARP解析MAC地址到IP地址。</li>
<li>ARP主要用于常规网络通信，而RARP主要用于无盘设备等特殊情况下的地址配置。</li>
<li>ARP请求由需要通信的主机发出，而RARP请求由需要获取IP地址的设备发出。</li>
</ul>
<p>需要注意的是，随着网络技术的发展，ARP和RARP在现代网络中的使用逐渐减少，因为有更高级的技术和协议来管理IP地址和MAC地址的映射关系，如DHCP（Dynamic Host Configuration Protocol）和IPv6的邻居发现协议。</p>
<h3 id="4、路由器与交换机的区别是什么？"><a href="#4、路由器与交换机的区别是什么？" class="headerlink" title="4、路由器与交换机的区别是什么？"></a>4、路由器与交换机的区别是什么？</h3><p>路由器（Router）和交换机（Switch）是网络中常见的两种设备，它们在网络中扮演不同的角色，有以下区别：</p>
<ol>
<li><strong>功能与工作层次</strong>：<ul>
<li><strong>路由器</strong>：路由器位于网络的边缘，连接不同的网络或子网，主要负责在不同网络之间转发数据包。它能够基于目标IP地址决定数据包的最佳路径，从而实现网络之间的通信。</li>
<li><strong>交换机</strong>：交换机通常位于局域网（LAN）内部，它通过学习MAC地址来建立和维护一个MAC地址表，然后根据MAC地址表将数据包直接从源端口转发到目标端口，从而实现局域网内部设备之间的通信。</li>
</ul>
</li>
<li><strong>转发决策</strong>：<ul>
<li><strong>路由器</strong>：路由器通过查看数据包的目标IP地址来进行转发决策，选择最佳路径将数据包从一个网络传送到另一个网络。</li>
<li><strong>交换机</strong>：交换机通过查看数据包的源MAC地址来决定将数据包发送到哪个目标端口，以实现局域网内部设备之间的直接通信。</li>
</ul>
</li>
<li><strong>广播域和碰撞域</strong>：<ul>
<li><strong>路由器</strong>：路由器能够隔离不同网络之间的广播域和碰撞域，这意味着在不同网络间的广播消息不会被传播到其他网络。</li>
<li><strong>交换机</strong>：交换机也能够隔离广播域，但在同一个交换机内部，所有设备共享一个碰撞域，因此在交换机内部通信不会发生碰撞。</li>
</ul>
</li>
<li><strong>网络范围</strong>：<ul>
<li><strong>路由器</strong>：路由器通常用于连接不同的网络，可以跨越不同的物理位置和地理区域。</li>
<li><strong>交换机</strong>：交换机通常用于连接同一局域网内的设备，限制在一个相对较小的网络范围内。</li>
</ul>
</li>
</ol>
<p>总之，路由器和交换机在网络中扮演不同的角色，分别用于实现不同的通信需求。路由器负责不同网络之间的数据包转发，而交换机则负责同一网络内部设备之间的数据包交换。</p>
<h3 id="5、什么是TCP三次握手、四次挥手？"><a href="#5、什么是TCP三次握手、四次挥手？" class="headerlink" title="5、什么是TCP三次握手、四次挥手？"></a>5、什么是TCP三次握手、四次挥手？</h3><p>当然，我可以解释一下TCP三次握手和四次挥手的概念。</p>
<p><strong>TCP三次握手</strong>：</p>
<p>TCP三次握手是在建立TCP连接时使用的一种协议，用于确保客户端和服务器之间的通信能够稳定地开始。这个过程涉及三个步骤：</p>
<ol>
<li><strong>第一步（SYN）</strong>：客户端向服务器发送一个带有SYN（同步）标志的数据包，请求建立连接。客户端进入SYN_SENT状态。</li>
<li><strong>第二步（SYN-ACK）</strong>：服务器收到客户端的请求后，会发送一个带有SYN和ACK（确认）标志的数据包，表示同意建立连接。服务器进入SYN_RECEIVED状态。</li>
<li><strong>第三步（ACK）</strong>：客户端收到服务器的响应后，发送一个带有ACK标志的数据包给服务器，确认连接已建立。双方都进入已建立连接的状态，可以开始进行数据传输。</li>
</ol>
<p>这三步握手过程确保了双方都同意建立连接，并且双方都准备好了进行数据传输。</p>
<p><strong>TCP四次挥手</strong>：</p>
<p>TCP四次挥手是在关闭TCP连接时使用的一种协议，用于确保双方能够安全地终止连接。这个过程涉及四个步骤：</p>
<ol>
<li><strong>第一步（FIN）</strong>：一方（通常是客户端）向另一方（通常是服务器）发送一个带有FIN（结束）标志的数据包，表示希望关闭连接。发送方进入FIN_WAIT_1状态。</li>
<li><strong>第二步（ACK）</strong>：接收方收到关闭请求后，发送一个带有ACK标志的数据包作为确认。发送方进入FIN_WAIT_2状态，等待接收方的确认。</li>
<li><strong>第三步（FIN）</strong>：接收方准备好关闭连接时，会发送一个带有FIN标志的数据包，表示同意关闭连接。接收方进入CLOSE_WAIT状态。</li>
<li><strong>第四步（ACK）</strong>：发送方收到接收方的关闭确认后，发送一个带有ACK标志的数据包作为确认。双方都进入连接已关闭的状态。</li>
</ol>
<p>这四步挥手过程确保双方都完成了数据传输，并且同意关闭连接，避免了数据丢失或不完整的情况。</p>
<p>总之，TCP三次握手和四次挥手是确保通信的可靠性和完整性的重要步骤，分别用于建立和关闭TCP连接。</p>
<h3 id="6、TCP是如何保证可靠传输的？"><a href="#6、TCP是如何保证可靠传输的？" class="headerlink" title="6、TCP是如何保证可靠传输的？"></a>6、TCP是如何保证可靠传输的？</h3><p>TCP（传输控制协议）保证可靠传输的主要方式包括以下几个方面：</p>
<ol>
<li><strong>三次握手</strong>：在建立连接时，发送方首先发送一个SYN（同步）标志的数据包给接收方。接收方收到后，确认收到这个SYN，并发送一个带有ACK（确认）和SYN标志的数据包给发送方。最后，发送方再发送一个带有ACK标志的数据包作为确认。这三步握手确保双方都同意建立连接，减少了连接错误的可能性。</li>
<li><strong>序列号和确认机制</strong>：TCP使用序列号来标识每个发送的数据包，接收方根据序列号确认收到的数据包。如果发送方未收到确认，会重新发送数据包，直到接收到确认为止。这保证了数据的可靠传输，避免了数据包丢失的情况。</li>
<li><strong>数据分段和重组</strong>：TCP将应用层传输的大块数据分割成小的数据段进行传输，接收方根据序列号将这些数据段重新组装成完整的数据。如果发现某个数据段丢失，TCP会要求重新发送该数据段，确保数据的完整性。</li>
<li><strong>流量控制</strong>：TCP利用滑动窗口机制进行流量控制，确保发送方不会发送过多的数据导致接收方无法及时处理。这防止了拥塞并保持了传输的平稳。</li>
<li><strong>超时重传</strong>：如果发送方在一定时间内没有收到确认，会认为数据包丢失，然后会重新发送这些数据包。这样即使数据包在传输过程中丢失，也能够通过超时重传来确保数据的到达。</li>
<li><strong>四次挥手</strong>：在关闭连接时，发送方和接收方都要确认关闭，防止数据的丢失或不完整。</li>
</ol>
<p>通过上述机制，TCP可以有效地保证数据的可靠传输，确保数据在传输过程中不会丢失、重复或无序。</p>
<h3 id="7、基于UDP实现一个TCP协议"><a href="#7、基于UDP实现一个TCP协议" class="headerlink" title="7、基于UDP实现一个TCP协议"></a>7、基于UDP实现一个TCP协议</h3><p>UDP（User Datagram Protocol）是一种无连接的、不可靠的传输协议，而TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输协议。基于UDP实现一个TCP协议是不可行的，因为UDP缺乏TCP提供的许多关键特性，如可靠的数据传输、流量控制、拥塞控制等。</p>
<p>然而，你可以使用UDP来实现一种类似TCP的协议，提供一些基本的可靠性和有序性。下面是一个简单的示例，展示了如何使用UDP实现一个基于可靠传输的简化TCP协议：</p>
<ol>
<li><strong>序号和确认机制：</strong> 在数据包中添加序号字段和确认字段。发送方将每个数据包分配一个唯一的序号，并等待接收方发送确认消息。接收方收到数据包后，发送确认消息，确认收到的最后一个有序数据包的序号。发送方根据接收到的确认消息确定哪些数据包已经被成功接收。</li>
<li><strong>超时重传：</strong> 发送方需要设置一个定时器，在发送数据包后启动计时器。如果在一定时间内没有收到确认消息，发送方会假设数据包丢失，并重新发送该数据包。接收方在收到重复的数据包时可以丢弃重复的数据。</li>
<li><strong>流量控制：</strong> 发送方和接收方可以使用滑动窗口机制来进行流量控制。发送方根据接收方的可接受窗口大小来确定发送的数据量，并根据接收方发送的确认消息调整发送窗口的大小。</li>
<li><strong>拥塞控制：</strong> 由于UDP本身不提供拥塞控制机制，你可以基于UDP实现一些简单的拥塞控制策略，如慢启动和拥塞避免。这可以包括动态调整发送窗口大小和控制发送速率，以避免网络拥塞。</li>
</ol>
<p>需要注意的是，尽管你可以使用UDP实现一些类似TCP的特性，但由于UDP的本质特点，它仍然无法提供与TCP完全相同的可靠性和性能。在实际应用中，如果需要可靠的数据传输和其他高级特性，建议使用TCP协议而不是基于UDP的自定义协议。</p>
<h3 id="8、为什么需要HTTP-2，他解决了什么问题？"><a href="#8、为什么需要HTTP-2，他解决了什么问题？" class="headerlink" title="8、为什么需要HTTP&#x2F;2，他解决了什么问题？"></a>8、为什么需要HTTP&#x2F;2，他解决了什么问题？</h3><p>HTTP&#x2F;2 是 HTTP 协议的下一代版本，旨在改进性能和效率。它解决了 HTTP&#x2F;1.1 存在的一些问题，并引入了一些新的特性和优化，以提供更快的网页加载速度、更高的效率和更好的用户体验。以下是 HTTP&#x2F;2 解决的一些问题：</p>
<ol>
<li><strong>多路复用（Multiplexing）：</strong> 在 HTTP&#x2F;1.1 中，每个请求都需要使用单独的连接，导致了高延迟和低效率。HTTP&#x2F;2 使用二进制分帧层，通过在单个连接上同时发送多个请求和响应，实现了多路复用。这意味着可以并发处理多个请求，减少了延迟，提高了效率。</li>
<li><strong>头部压缩（Header Compression）：</strong> 在 HTTP&#x2F;1.1 中，每个请求和响应的头部都需要重复发送，浪费了带宽和资源。HTTP&#x2F;2 引入了头部压缩机制，使用了 HPACK 压缩算法，可以显著减少头部的大小，减少了数据传输量，提高了效率。</li>
<li><strong>服务器推送（Server Push）：</strong> 在 HTTP&#x2F;1.1 中，客户端需要发送多个请求来获取网页中的所有资源，例如脚本、样式表和图片等。而 HTTP&#x2F;2 支持服务器推送，服务器可以主动将与请求的资源相关的其他资源一起推送给客户端，减少了额外的请求延迟，提高了页面加载速度。</li>
<li><strong>流量控制（Flow Control）：</strong> HTTP&#x2F;2 引入了流量控制机制，可以对数据流进行控制，防止发送方发送过多的数据导致接收方无法处理。这有助于平衡发送和接收之间的速度差异，提高了性能和稳定性。</li>
<li><strong>优先级（Priority）：</strong> HTTP&#x2F;2 支持请求的优先级设置，可以告知服务器哪些请求更重要，服务器可以相应地优先处理重要的请求，提高了用户体验。</li>
</ol>
<p>总体而言，HTTP&#x2F;2 在性能、效率和用户体验方面有了显著的改进。它通过多路复用、头部压缩、服务器推送、流量控制和优先级等特性，减少了延迟、提高了吞吐量，加快了网页加载速度，提供了更好的性能和效率。</p>
<h3 id="9、HTTP-2存在什么问题，为什么需要HTTP-3？"><a href="#9、HTTP-2存在什么问题，为什么需要HTTP-3？" class="headerlink" title="9、HTTP&#x2F;2存在什么问题，为什么需要HTTP&#x2F;3？"></a>9、HTTP&#x2F;2存在什么问题，为什么需要HTTP&#x2F;3？</h3><p>尽管 HTTP&#x2F;2 在性能和效率方面带来了显著的改进，但它仍然存在一些问题，这些问题促使了 HTTP&#x2F;3 的出现。以下是一些 HTTP&#x2F;2 存在的问题：</p>
<ol>
<li><strong>依赖于 TCP 协议：</strong> HTTP&#x2F;2 是在 TCP 协议之上构建的，而 TCP 协议在高延迟和不可靠的网络环境下存在一些问题。当出现丢包或网络拥塞时，TCP 使用的拥塞控制机制会导致连接的延迟增加，从而影响性能。</li>
<li><strong>队头阻塞（Head-of-Line Blocking）：</strong> HTTP&#x2F;2 使用多路复用技术，但在一个连接上的多个请求和响应共享同一个传输通道。如果其中一个请求或响应出现延迟或丢失，将会阻塞后续的请求和响应，这被称为队头阻塞。这可能导致其他请求受到影响，影响了整体性能。</li>
<li><strong>部署复杂性：</strong> HTTP&#x2F;2 的实施相对复杂，需要对服务器和客户端进行更新以支持新的协议。这可能导致一些兼容性和部署问题，使得采用 HTTP&#x2F;2 变得相对困难。</li>
</ol>
<p>为了解决这些问题，HTTP&#x2F;3 应运而生，它采用了全新的传输协议——QUIC（Quick UDP Internet Connections）。HTTP&#x2F;3 基于 UDP 协议，而不是 TCP，以提供更好的性能和可靠性。以下是为什么需要 HTTP&#x2F;3 的一些原因：</p>
<ol>
<li><strong>解决 TCP 的问题：</strong> QUIC 作为传输层协议，克服了 TCP 的一些问题，如连接建立的延迟、队头阻塞和拥塞控制机制。QUIC 使用自己的拥塞控制算法，可以更快地适应网络状况的变化，并提供更好的性能。</li>
<li><strong>减少延迟：</strong> HTTP&#x2F;3 使用 QUIC 协议，通过减少握手时间和降低队头阻塞的影响，可以显著减少延迟。这对于实时通信、视频流和移动应用等对低延迟要求较高的场景非常重要。</li>
<li><strong>更好的并发性：</strong> HTTP&#x2F;3 在一个连接上可以同时处理多个请求和响应，避免了队头阻塞的问题。这提供了更好的并发性和吞吐量，提高了性能。</li>
<li><strong>更好的适应性：</strong> HTTP&#x2F;3 的部署相对简单，因为它使用了现有的 UDP 协议。它可以更容易地通过 NAT 和防火墙，适应多样化的网络环境。</li>
</ol>
<p>总的来说，HTTP&#x2F;3 通过引入 QUIC 协议，解决了 HTTP&#x2F;2 存在的一些问题，如 TCP 的限制和队头阻塞。它提供了更好的性能、更低的延迟和更好的并发性，同时具有更好的适应性和部署简单性。</p>
<h3 id="10、Cookie，Session，Token的区别是什么？"><a href="#10、Cookie，Session，Token的区别是什么？" class="headerlink" title="10、Cookie，Session，Token的区别是什么？"></a>10、Cookie，Session，Token的区别是什么？</h3><p>Cookie、Session 和 Token 都是用于在 Web 应用程序中管理用户身份验证和状态的方式，但它们在实现和使用上有一些区别。以下是它们之间的主要区别：</p>
<ol>
<li><strong>Cookie：</strong><ul>
<li>Cookie 是一小段文本信息，由服务器发送到用户的浏览器，并存储在用户的本地计算机上。</li>
<li>主要用于在浏览器和服务器之间存储少量数据，通常用于身份验证、用户偏好设置、跟踪用户活动等。</li>
<li>Cookie 存储在客户端，可以在浏览器中设置过期时间，以及作用域（可以限定在特定的域名或路径下）。</li>
<li>可以被浏览器禁用或删除，且可能存在安全性问题，如跨站点脚本（XSS）攻击和跨站请求伪造（CSRF）攻击。</li>
</ul>
</li>
<li><strong>Session：</strong><ul>
<li>Session 是服务器端存储的用户信息，通过一个唯一的会话标识（Session ID）与客户端进行关联。</li>
<li>当用户访问服务器时，服务器会创建一个新的 Session，并分配一个唯一的 Session ID，将用户数据存储在服务器上，而不是在用户的浏览器中。</li>
<li>Session 数据存储在服务器上，通常在内存、数据库或缓存中，因此相对安全，但会占用服务器资源。</li>
<li>Session 常用于存储敏感信息，如用户身份验证状态、购物车内容等。</li>
</ul>
</li>
<li><strong>Token：</strong><ul>
<li>Token 是一种令牌，通常是一个加密的字符串，用于验证用户身份和授权。</li>
<li>在基于令牌的身份验证中，用户在登录后会收到一个令牌，将其保存在客户端（通常是本地存储或 Cookie）中，并在每次请求时将令牌发送给服务器。</li>
<li>服务器使用密钥验证令牌的有效性，从而确定用户身份和权限。</li>
<li>令牌可以在客户端存储，不需要在服务器上维护会话状态，因此适用于分布式系统和无状态应用。</li>
</ul>
</li>
</ol>
<p>总结起来：</p>
<ul>
<li>Cookie 是在客户端存储的小段文本数据，通常用于存储用户偏好和跟踪用户活动。</li>
<li>Session 是服务器端存储的用户数据，通过唯一的会话标识与客户端关联，常用于存储敏感信息。</li>
<li>Token 是一种令牌，用于验证用户身份和授权，适用于无状态应用和分布式系统。</li>
</ul>
<p>选择使用哪种方法取决于应用程序的需求和安全性考虑。</p>
<h3 id="11、HTTPS只是比HTTP安全吗？"><a href="#11、HTTPS只是比HTTP安全吗？" class="headerlink" title="11、HTTPS只是比HTTP安全吗？"></a>11、HTTPS只是比HTTP安全吗？</h3><p>HTTPS（Hypertext Transfer Protocol Secure）不仅仅是比 HTTP（Hypertext Transfer Protocol）更安全，而且它提供了一系列安全性和保护机制，以确保在 Web 通信中的数据保密性、完整性和身份验证。以下是 HTTPS 相对于 HTTP 的主要安全改进：</p>
<ol>
<li><strong>数据加密：</strong> HTTPS 使用 SSL（Secure Sockets Layer）或 TLS（Transport Layer Security）协议对传输的数据进行加密。这意味着在数据从客户端发送到服务器的过程中，第三方无法轻易地截取、窃听或篡改数据。加密保护了用户的敏感信息，如登录凭据、支付信息等。</li>
<li><strong>身份验证：</strong> HTTPS 通过使用数字证书对服务器进行身份验证。数字证书由受信任的证书颁发机构（Certificate Authority，CA）签发，用于证明服务器的身份。这样，用户可以确信他们正在与合法的服务器通信，而不是被冒充的恶意服务器。</li>
<li><strong>数据完整性：</strong> HTTPS 使用加密算法和消息认证码（Message Authentication Code，MAC）来确保数据在传输过程中没有被篡改或损坏。接收方可以验证数据的完整性，以确保数据的原始性和完整性。</li>
<li><strong>信任度和安全指示：</strong> 浏览器在使用 HTTPS 连接时会显示安全指示，如绿色锁图标、网站名称旁边的“安全”标签等。这些指示向用户传达了对网站的信任和数据的保护，帮助用户识别安全的网站并减少受到网络攻击的风险。</li>
<li><strong>防止窃听和篡改：</strong> HTTPS 的加密机制防止了中间人攻击（Man-in-the-Middle Attack），其中攻击者可以窃听、篡改或伪造通信内容。通过加密和身份验证，HTTPS 提供了更高的安全性，使得中间人攻击变得更加困难。</li>
</ol>
<p>总而言之，HTTPS 不仅仅是比 HTTP 更安全，它通过加密通信、身份验证、数据完整性和安全指示等机制，提供了更高级别的保护，确保用户的数据在传输过程中得到保密、完整和安全。因此，在涉及敏感信息传输的场景中，使用 HTTPS 是非常重要和推荐的。</p>
<h3 id="12、浏览器输入www-baidu-com回车之后发生了什么"><a href="#12、浏览器输入www-baidu-com回车之后发生了什么" class="headerlink" title="12、浏览器输入www.baidu.com回车之后发生了什么"></a>12、浏览器输入www.baidu.com回车之后发生了什么</h3><p>当在浏览器中输入 “<a target="_blank" rel="noopener" href="http://www.baidu.com/" title="www.baidu.com">www.baidu.com</a>“ 并按下回车之后，以下是大致的步骤和过程：</p>
<ol>
<li><strong>域名解析：</strong> 浏览器首先会将 “<a target="_blank" rel="noopener" href="http://www.baidu.com/" title="www.baidu.com">www.baidu.com</a>“ 解析为 IP 地址。它会检查本地 DNS 缓存，如果找到了对应的 IP 地址，则跳过后续步骤。如果没有找到，则浏览器会向本地计算机的 DNS 解析器发送查询请求。</li>
<li><strong>DNS 查询：</strong> 本地计算机的 DNS 解析器会收到浏览器发送的 DNS 查询请求，并尝试解析域名 “<a target="_blank" rel="noopener" href="http://www.baidu.com".如果本地解析器缓存中有对应的记录,则返回解析结果给浏览器.如果没有缓存记录,则本地解析器会向根域名服务器发送查询请求./" title="www.baidu.com&quot;。如果本地解析器缓存中有对应的记录，则返回解析结果给浏览器。如果没有缓存记录，则本地解析器会向根域名服务器发送查询请求。">www.baidu.com&quot;。如果本地解析器缓存中有对应的记录，则返回解析结果给浏览器。如果没有缓存记录，则本地解析器会向根域名服务器发送查询请求。</a></li>
<li><strong>递归查询：</strong> 根域名服务器收到查询请求后，会返回给本地解析器一个对应的顶级域名服务器的 IP 地址。本地解析器再次向顶级域名服务器发送查询请求。</li>
<li><strong>迭代查询：</strong> 顶级域名服务器收到查询请求后，会返回给本地解析器一个次级域名服务器的 IP 地址。本地解析器再次向次级域名服务器发送查询请求。</li>
<li><strong>迭代查询继续：</strong> 这个过程会一直进行下去，直到本地解析器获得了最终的目标服务器的 IP 地址。</li>
<li><strong>建立 TCP 连接：</strong> 一旦浏览器获得了目标服务器的 IP 地址，它会使用 HTTP 协议中的默认端口（80）或 HTTPS 协议中的默认端口（443）与服务器建立 TCP 连接。</li>
<li><strong>发送 HTTP 请求：</strong> 浏览器通过建立的 TCP 连接向服务器发送一个 HTTP 请求。这个请求包含了请求的方法（如 GET、POST）、请求的路径（如 “&#x2F;“）以及其他的头部信息（如用户代理、Cookie 等）。</li>
<li><strong>服务器处理请求：</strong> 服务器收到浏览器发送的请求后，会根据请求的路径和其他信息来处理请求。对于百度的首页请求，服务器会返回相应的 HTML 页面。</li>
<li><strong>服务器响应：</strong> 服务器处理完请求后，会生成一个 HTTP 响应。响应包括响应的状态码（如 200 表示成功）、响应的内容（如 HTML 页面）以及其他的头部信息（如响应的日期、内容类型等）。</li>
<li><strong>接收和渲染页面：</strong> 浏览器收到服务器的响应后，会解析响应内容并渲染页面。它会将 HTML 解析为 DOM（文档对象模型），加载和显示页面中的其他资源（如 CSS、JavaScript、图像等）。</li>
<li><strong>断开连接：</strong> 页面渲染完成后，浏览器和服务器之间的 TCP 连接会被断开。</li>
</ol>
<p>以上是一个简化的描述，实际的过程可能还涉及到其他的细节和步骤。但总体上，这些步骤描述了当在浏览器中输入 “<a target="_blank" rel="noopener" href="http://www.baidu.com/" title="www.baidu.com">www.baidu.com</a>“ 并按下回车后，浏览器如何解析域名、建立连接、发送请求、接收响应和渲染页面的过程。</p>
<h3 id="13、对称加密和非对称加密有什么区别？"><a href="#13、对称加密和非对称加密有什么区别？" class="headerlink" title="13、对称加密和非对称加密有什么区别？"></a>13、对称加密和非对称加密有什么区别？</h3><p>对称加密和非对称加密是两种常见的加密算法，它们在加密和解密数据时有一些重要的区别：</p>
<p><strong>对称加密：</strong></p>
<ul>
<li>使用相同的密钥（称为密钥）来进行加密和解密数据。</li>
<li>加密和解密的过程速度较快，因为使用的算法相对简单。</li>
<li>对称加密适用于大量数据的加密，如文件传输。</li>
<li>密钥的管理相对较为复杂，需要确保密钥的安全性，防止未授权的人获取密钥。</li>
<li>常见的对称加密算法有 DES（Data Encryption Standard）、AES（Advanced Encryption Standard）等。</li>
</ul>
<p><strong>非对称加密：</strong></p>
<ul>
<li>使用一对密钥，分别是公钥和私钥。公钥用于加密数据，私钥用于解密数据。</li>
<li>加密和解密的过程相对较慢，因为使用的算法相对复杂。</li>
<li>非对称加密适用于安全性要求较高的场景，如身份验证、数字签名等。</li>
<li>公钥可以公开分发，而私钥必须保密保存。</li>
<li>常见的非对称加密算法有 RSA（Rivest-Shamir-Adleman）、DSA（Digital Signature Algorithm）等。</li>
</ul>
<p>总结起来，对称加密使用相同的密钥进行加密和解密，速度快但密钥管理复杂；非对称加密使用不同的密钥进行加密和解密，安全性高但速度较慢。通常的做法是，对称加密用于加密大量的数据，而非对称加密用于安全性要求较高的场景，例如建立安全的通信渠道、数字签名等。在实际应用中，通常会将对称加密和非对称加密结合起来使用，以兼顾效率和安全性。</p>
<h3 id="14、简单介绍一下DNS？"><a href="#14、简单介绍一下DNS？" class="headerlink" title="14、简单介绍一下DNS？"></a>14、简单介绍一下DNS？</h3><p>DNS（Domain Name System，域名系统）是互联网中用于将人类可读的域名转换为计算机可理解的IP地址的一种系统。它充当了互联网上的“电话簿”，使用户能够通过易于记忆的域名访问网站，而不必记住复杂的IP地址。</p>
<p>以下是 DNS 的基本工作原理和组成部分：</p>
<ol>
<li><strong>域名结构：</strong> 域名按照层次结构划分，从右到左逐级具有不同的层级。例如，”<a target="_blank" rel="noopener" href="http://www.example.com/" title="www.example.com">www.example.com</a>“ 中，顶级域是 “.com”，次级域是 “example”，子域是 “www”。</li>
<li><strong>域名解析：</strong> 当用户在浏览器中输入一个域名，比如 “<a target="_blank" rel="noopener" href="http://www.example.荵ꃐ麹特账鞂co聊獩곐榣m楎"澅蘱껖,虁鴭/" title="www.example.com&quot;，操作系统或浏览器会向本地计算机的">www.example.com&quot;，操作系统或浏览器会向本地计算机的</a> DNS 解析器发送查询请求，以获取该域名对应的IP地址。</li>
<li><strong>DNS解析过程：</strong> 如果本地解析器的缓存中没有目标域名的IP地址，它会执行以下步骤：<ul>
<li><strong>递归查询：</strong> 本地解析器向根域名服务器发送查询请求，根服务器会返回顶级域名服务器的IP地址。</li>
<li><strong>迭代查询：</strong> 本地解析器继续向顶级域名服务器发送查询请求，获得次级域名服务器的IP地址。</li>
<li><strong>继续迭代：</strong> 这个过程会一直持续下去，直到本地解析器获取了目标域名的IP地址。</li>
</ul>
</li>
<li><strong>响应缓存：</strong> 本地解析器在解析域名后，会将结果缓存一段时间。这样，如果再次有相同域名的查询，就可以直接从缓存中获取结果，加快访问速度。</li>
<li><strong>记录类型：</strong> DNS查询可以返回多种类型的记录，包括：<ul>
<li>A记录：将域名映射到IPv4地址。</li>
<li>AAAA记录：将域名映射到IPv6地址。</li>
<li>CNAME记录：将域名指向另一个域名。</li>
<li>MX记录：指定邮件服务器的地址。</li>
<li>NS记录：指定管理特定区域的域名服务器。</li>
</ul>
</li>
</ol>
<p>DNS在互联网中起着至关重要的作用，它不仅使人们能够通过易于记忆的域名访问网站，还支持电子邮件、域名注册等多种互联网服务。然而，由于其核心的分布式特性，DNS也需要关注安全性和性能方面的问题。</p>
<h3 id="15、ping的原理是什么？"><a href="#15、ping的原理是什么？" class="headerlink" title="15、ping的原理是什么？"></a>15、ping的原理是什么？</h3><p>Ping是一种常用的网络工具，用于测试主机之间的连通性和测量网络延迟。它基于ICMP（Internet Control Message Protocol，互联网控制报文协议）来实现。</p>
<p>以下是Ping的基本工作原理：</p>
<ol>
<li>发送ICMP Echo请求：当用户在命令行中执行ping命令，并指定目标主机的IP地址或域名时，操作系统会创建一个ICMP Echo请求报文。</li>
<li>封装ICMP报文：ICMP Echo请求报文包含一个特定的标识符和序列号，以及一些其他的控制信息。操作系统将ICMP报文封装在IP数据包中，设置目标IP地址为目标主机的IP地址。</li>
<li>发送数据包：操作系统将封装好的IP数据包发送到本地网络接口，通过网络传输到目标主机。</li>
<li>目标主机的响应：目标主机接收到ICMP Echo请求后，会检查目标IP地址是否与自己匹配。如果匹配，则生成一个ICMP Echo响应报文。</li>
<li>返回响应数据包：目标主机将ICMP Echo响应报文封装在IP数据包中，并将数据包发送回源主机的IP地址。</li>
<li>源主机接收响应：源主机接收到ICMP Echo响应后，会检查标识符和序列号是否与发送的请求匹配。如果匹配，则认为目标主机可达，并计算往返时间（Round-Trip Time，RTT）。</li>
</ol>
<p>Ping的原理基于ICMP协议，它通过发送Echo请求并接收Echo响应来测试主机之间的连通性。Ping命令通常用于诊断网络问题、测量网络延迟和检查主机的可达性。通过比较发送请求和接收响应之间的时间差，可以估计网络的延迟情况。</p>
<h3 id="16、什么是IPV6？和IPV4有什么区别？"><a href="#16、什么是IPV6？和IPV4有什么区别？" class="headerlink" title="16、什么是IPV6？和IPV4有什么区别？"></a>16、什么是IPV6？和IPV4有什么区别？</h3><p>IPv6（Internet Protocol version 6，互联网协议第6版）是互联网上的一种网络协议，用于为设备分配唯一的IP地址以及进行数据包传输。它是IPv4（Internet Protocol version 4，互联网协议第4版）的继任者。IPv6的引入主要是为了解决IPv4地址空间不足、支持更多的设备连接以及提供更好的网络性能和安全性等问题。</p>
<p>主要的区别如下：</p>
<ol>
<li><strong>地址空间：</strong> 最显著的区别是IPv6提供了远远超过IPv4的地址空间。IPv4使用32位地址，最多支持约42亿个不同的IP地址，而IPv6采用128位地址，可支持的地址数量极其庞大，约为3.4 x 10^38个。这解决了IPv4中地址短缺的问题，使每个设备都能够拥有唯一的IP地址。</li>
<li><strong>地址表示：</strong> IPv6地址使用冒号分隔的8组16进制数表示，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了缩短表示，IPv6允许省略前导零，以及连续的零块。IPv4则使用点分十进制表示，例如：192.168.1.1。</li>
<li><strong>自动配置：</strong> IPv6支持更强大的自动地址配置机制，设备可以通过Router Advertisement（路由器通告）协议自动获取IP地址和其他网络配置信息，从而简化了网络设置。</li>
<li><strong>安全性：</strong> IPv6在设计时考虑了更多的安全性特性，包括内置的IPSec（Internet Protocol Security，互联网协议安全）支持，可以更轻松地实现网络通信的加密和认证。</li>
<li><strong>移动性支持：</strong> IPv6更好地支持移动设备，有助于实现无缝漫游和移动IP地址的更改。</li>
<li><strong>流量控制和质量服务：</strong> IPv6引入了更灵活和精细的流量控制和质量服务机制，有助于提供更稳定和高效的网络传输。</li>
<li><strong>NAT（Network Address Translation）：</strong> 在IPv4中，由于地址短缺，常常需要使用NAT来将多个设备共享单个公共IP地址。在IPv6中，地址数量充足，减少了对NAT的需求，有助于简化网络配置。</li>
</ol>
<p>尽管IPv6带来了许多优势，但由于网络基础设施的升级以及应用程序和设备的适配等问题，目前全球网络仍然广泛使用IPv4。然而，随着时间的推移，IPv6的推广和采用逐渐增加，以满足不断增长的互联网连接需求。</p>
<h3 id="17、什么是正向代理和反向代理？"><a href="#17、什么是正向代理和反向代理？" class="headerlink" title="17、什么是正向代理和反向代理？"></a>17、什么是正向代理和反向代理？</h3><p>正向代理（Forward Proxy）和反向代理（Reverse Proxy）是两种常见的代理服务器配置，用于在客户端和目标服务器之间进行中间转发和处理。</p>
<p><strong>正向代理：</strong> 正向代理是位于客户端和目标服务器之间的代理服务器。当客户端发送请求时，请求首先被发送到正向代理服务器，然后由代理服务器转发请求到目标服务器，并将响应返回给客户端。客户端通常需要配置代理服务器的地址和端口，以便与目标服务器通信。</p>
<p>正向代理的主要功能包括：</p>
<ol>
<li>隐藏客户端的真实IP地址：客户端的请求被代理服务器转发，目标服务器只能看到代理服务器的IP地址，无法直接获取客户端的真实IP地址。</li>
<li>访问控制和过滤：代理服务器可以实施访问控制策略，限制客户端对目标服务器的访问。它还可以过滤请求和响应，对流量进行审查和修改。</li>
<li>缓存：代理服务器可以缓存目标服务器的响应，以减轻目标服务器的负载并提高响应速度。</li>
<li>加速和优化：代理服务器可以对请求和响应进行优化，例如压缩、加密、负载均衡等，以提供更快的访问速度和更好的性能。</li>
</ol>
<p><strong>反向代理：</strong> 反向代理是位于目标服务器和客户端之间的代理服务器。当客户端发送请求时，请求首先被发送到反向代理服务器，然后由代理服务器将请求转发到一个或多个目标服务器，最后将目标服务器的响应返回给客户端。客户端不需要知道目标服务器的存在，只需要与反向代理服务器通信。</p>
<p>反向代理的主要功能包括：</p>
<ol>
<li>负载均衡：反向代理可以将请求分发到多个目标服务器，以平衡服务器负载，提高系统的可扩展性和容错性。</li>
<li>安全性和保护：反向代理可以充当防火墙，保护目标服务器免受恶意请求和攻击，例如DDoS攻击。</li>
<li>缓存和加速：反向代理可以缓存目标服务器的响应，以提供更快的访问速度和更好的性能。</li>
<li>SSL加密和解密：反向代理可以处理SSL&#x2F;TLS加密和解密，减轻目标服务器的负载。</li>
</ol>
<p>总结： &#x20;<br>正向代理是代理客户端的请求，代表客户端与目标服务器通信；而反向代理是代理目标服务器的响应，代表目标服务器与客户端通信。两者在网络架构中扮演不同的角色，提供不同的功能和优势。</p>
<h3 id="18、什么是跨域访问问题，如何解决？"><a href="#18、什么是跨域访问问题，如何解决？" class="headerlink" title="18、什么是跨域访问问题，如何解决？"></a>18、什么是跨域访问问题，如何解决？</h3><p>跨域访问问题（Cross-Origin Resource Sharing，CORS）是由浏览器的同源策略引起的。同源策略是一种安全机制，它限制了一个网页中的脚本只能访问同源（相同协议、域名和端口）的资源，防止恶意网站通过脚本访问其他网站的数据。</p>
<p>当网页中的 JavaScript 代码尝试从一个源（域）请求另一个源的资源时，浏览器会发出跨域请求，如果目标资源的服务器没有正确配置跨域访问策略，浏览器会阻止该请求，从而导致跨域访问问题。</p>
<p>为了解决跨域访问问题，可以采取以下方法：</p>
<ol>
<li>**服务器端设置响应头：**目标服务器可以在响应中设置特定的响应头来允许跨域访问。常见的响应头是”Access-Control-Allow-Origin”，它指定允许访问资源的域。服务器可以设置该头为特定的域名，或使用通配符” <em>“表示允许任意域名进行访问。例如，设置响应头：”Access-Control-Allow-Origin:</em> “</li>
<li><strong>请求时添加额外的头信息：</strong> 发起跨域请求时，可以在请求中添加一些额外的头信息，例如”Origin”头，用于告知服务器请求的来源。服务器可以根据该头信息来判断是否允许跨域访问，并设置相应的响应头。</li>
<li><strong>使用代理：</strong> 可以在自己的服务器上设置代理，将跨域请求转发到目标服务器。客户端与自己的服务器进行通信，而自己的服务器与目标服务器进行通信，从而避免了浏览器的跨域限制。</li>
<li><strong>JSONP（JSON with Padding）：</strong> JSONP是一种跨域访问的解决方案，它通过在页面中动态创建<code>&lt;script&gt;</code>标签，将跨域请求转换为对一个包含回调函数的URL的请求。服务器返回的响应会被包裹在回调函数中，从而实现跨域数据的获取。</li>
<li><strong>CORS代理：</strong> 可以使用CORS代理服务器，将跨域请求发送到代理服务器，代理服务器再将请求发送到目标服务器，并将响应返回给客户端。这样客户端与代理服务器之间是同源的，避免了跨域问题。</li>
</ol>
<p>需要注意的是，解决跨域访问问题需要在目标服务器上进行配置或采取相应的措施，因为同源策略是由浏览器实施的安全机制。另外，一些高级的跨域访问场景可能需要更复杂的解决方案，如使用WebSocket、跨域资源嵌入（Cross-Origin Resource Embedding，CORE）等。</p>
<h3 id="19、什么是CDN，为什么他可以做缓存？"><a href="#19、什么是CDN，为什么他可以做缓存？" class="headerlink" title="19、什么是CDN，为什么他可以做缓存？"></a>19、什么是CDN，为什么他可以做缓存？</h3><p>CDN，全称为内容分发网络（Content Delivery Network），是一种分布式网络架构，旨在加速网站和应用程序的内容传输，提高用户访问体验和性能。CDN通过将内容部署到全球各地的服务器节点上，使用户可以从距离更近的服务器获取所需的资源，从而减少延迟和网络拥塞。</p>
<p>CDN的工作原理如下：</p>
<ol>
<li><strong>缓存：</strong> CDN服务器会缓存网站的静态资源，如图片、CSS、JavaScript文件等，将这些资源复制到分布在全球各地的服务器节点上。</li>
<li><strong>就近访问：</strong> 当用户访问网站时，请求会被路由到距离用户最近的CDN节点，该节点会检查是否有所需的缓存内容。如果有缓存，就直接返回缓存的资源，减少了从源服务器请求资源的时间和延迟。</li>
<li><strong>动态负载均衡：</strong> 如果CDN节点没有所需的缓存内容，它会根据一定的负载均衡算法将请求转发到源服务器，从中获取内容。这样可以分担源服务器的负载，提高整体性能。</li>
<li><strong>内容更新：</strong> 当源服务器的内容发生变化时，CDN会根据设置的策略进行内容更新。新的内容会被传送到CDN节点，从而保持内容的最新状态。</li>
</ol>
<p>CDN之所以能够做缓存，主要是因为它能够将静态资源复制到分布在各地的服务器节点上，并将这些资源保存在节点的缓存中。这样做带来了以下优势：</p>
<ol>
<li><strong>降低延迟：</strong> 用户从距离更近的CDN节点获取资源，减少了数据传输的时间，从而降低了延迟，提高了网站的响应速度。</li>
<li><strong>减轻源服务器负载：</strong> 缓存静态资源的CDN节点可以减轻源服务器的负载，使其能够更专注地处理动态请求，提高了整体的性能和稳定性。</li>
<li><strong>抵御突发流量：</strong> CDN节点可以分散突发的用户请求，使源服务器不容易被突发的大量访问所压垮。</li>
<li><strong>提高可用性：</strong> CDN的分布式架构提高了内容的可用性，即使某个节点发生故障，仍然可以从其他节点获取内容。</li>
</ol>
<p>总的来说，CDN通过缓存静态资源、就近访问、负载均衡等方式，显著地改善了网站和应用程序的性能，提高了用户体验，同时降低了源服务器的负载。</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="RabbitMQ-–Kafaka"><a href="#RabbitMQ-–Kafaka" class="headerlink" title="RabbitMQ –Kafaka"></a>RabbitMQ –Kafaka</h2><h3 id="1、简述RabbitMQ的架构设计"><a href="#1、简述RabbitMQ的架构设计" class="headerlink" title="1、简述RabbitMQ的架构设计"></a>1、简述RabbitMQ的架构设计</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_paZFSkkOAR.png"></p>
<p><strong>Broker</strong>：rabbitmq的服务节点&#x20;</p>
<p><strong>Queue</strong>：队列，是RabbitMQ的内部对象，用于存储消息。RabbitMQ中消息只能存储在队列中。生产者投递消息到队列，消费者从队列中获取消息并消费。多个消费者可以订阅同一个队列，这时队列中的消息会被平均分摊(轮询)给多个消费者进行消费，而不是每个消费者都收到所有的消息进行消费。(注意：RabbitMQ不支持队列层面的广播消费，如果需要广播消费，可以采用一个交换器通过路由Key绑定多个队列，由多个消费者来订阅这些队列的方式。</p>
<p><strong>Exchange</strong>：交换器。生产者将消息发送到Exchange，由交换器将消息路由到一个或多个队列中。如果路由不到，或返回给生产者，或直接丢弃，或做其它处理。</p>
<p><strong>RoutingKey</strong>：路由Key。生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则。这个路由Key需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。在交换器类型和绑定键固定的情况下，生产者可以在发送消息给交换器时通过指定。RoutingKey来决定消息流向哪里。</p>
<p><strong>Binding</strong>：通过绑定将交换器和队列关联起来，在绑定的时候一般会指定一个绑定键，这样RabbitMQ就可以指定如何正确的路由到队列了。</p>
<p>交换器和队列实际上是多对多关系。就像关系数据库中的两张表。他们通过BindingKey做关联(多对多关系表)。在投递消息时，可以通过Exchange和RoutingKey(对应BindingKey)就可以找到相对应的队列。</p>
<p><strong>信道</strong>：信道是建立在Connection 之上的虚拟连接。当应用程序与Rabbit Broker建立TCP连接的时候，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的ID。RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。信道就像电缆里的光纤束。一条电缆内含有许多光纤束，允许所有的连接通过多条光线束进行传输和接收。</p>
<h3 id="2、介绍一下RabbitMQ有几种工作模式？"><a href="#2、介绍一下RabbitMQ有几种工作模式？" class="headerlink" title="2、介绍一下RabbitMQ有几种工作模式？"></a>2、介绍一下RabbitMQ有几种工作模式？</h3><p>RabbitMQ是一种流行的消息中间件，它支持多种工作模式，以满足不同的消息传递需求。以下是RabbitMQ中常见的几种工作模式：</p>
<ol>
<li><strong>简单模式（Simple Queue）</strong>：<ul>
<li>也被称为点对点模式。</li>
<li>在这种模式下，有一个生产者（Producer）将消息发送到队列（Queue），然后有一个消费者（Consumer）从队列中接收和处理消息。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_zneOp4sqSb.png"></li>
</ul>
</li>
</ol>
<p>应用场景： 将发送的电子邮件放到消息队列，然后邮件服务在队列中获取邮件并发送给收件人</p>
<p>2.<strong>工作队列模式（Work queues</strong>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_gfHwsbYi6n.png"></p>
<p>在多个消费者之间分配任务（竞争的消费者模式），一个生产者对应多个消费者，一般适用于执行资源密集型任务，单个消费者处理不过来，需要多个消费者进行处理。</p>
<p>应用场景： 一个订单的处理需要10s，有多个订单可以同时放到消息队列，然后让多个消费者同时处理，这样就是并行了，而不是单个消费者的串行情况。</p>
<p><strong>3.发布订阅模式（Publish&#x2F;Subscribe）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_Es-BcjtkSM.png"></p>
<p>一次向许多消费者发送消息，一个生产者发送的消息会被多个消费者获取，也就是将消息将广播到所有的消费者中。</p>
<p>应用场景： 更新商品库存后需要通知多个缓存和多个数据库，这里的结构应该是：</p>
<ul>
<li>一个fanout类型交换机扇出两个个消息队列，分别为缓存消息队列、数据库消息队列</li>
<li>一个缓存消息队列对应着多个缓存消费者</li>
<li>一个数据库消息队列对应着多个数据库消费者</li>
</ul>
<p>4、<strong>路由模式（Routing</strong>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_L05umrKY3_.png"></p>
<p>有选择地（Routing key）接收消息，发送消息到交换机并且要指定路由key ，消费者将队列绑定到交换机时需要指定路由key，仅消费指定路由key的消息</p>
<p>应用场景： 如在商品库存中增加了1台iphone12，iphone12促销活动消费者指定routing key为iphone12，只有此促销活动会接收到消息，其它促销活动不关心也不会消费此routing key的消息。</p>
<p>5、<strong>主题模式（Topics</strong>）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87__BbV1yX1l7.png"></p>
<p>根据主题（Topics）来接收消息，将路由key和某模式进行匹配，此时队列需要绑定在一个模式上，#匹配一个词或多个词，*只匹配一个词。</p>
<p>应用场景： 同上，iphone促销活动可以接收主题为iphone的消息，如iphone12、iphone13等。</p>
<p>6、<strong>发布者确认（Publisher Confirms）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_CUVH0UmPq8.png"></p>
<p>与发布者进行可靠的发布确认，发布者确认是RabbitMQ扩展，可以实现可靠的发布。在通道上启用发布者确认后，RabbitMQ将异步确认发送者发布的消息。</p>
<p>应用场景： 对于消息可靠性要求较高，比如钱包扣款。而一旦我们使用了消息队列，我们基本都要保证消息的百分百投递，因此建议使用的时候尽量选择该模式。</p>
<p><strong>7、RPC(这种模式用的很少)</strong></p>
<h3 id="3-、RabbitMQ如何确保消息发送-？-消息接收？"><a href="#3-、RabbitMQ如何确保消息发送-？-消息接收？" class="headerlink" title="3 、RabbitMQ如何确保消息发送 ？ 消息接收？"></a>3 <strong>、RabbitMQ如何确保消息发送 ？ 消息接收？</strong></h3><p><strong>即消息百分百投递问题。</strong></p>
<p><strong>发送方确认机制</strong>：</p>
<p>信道需要设置为 confirm 模式，则所有在信道上发布的消息都会分配一个唯一 ID。</p>
<p>一旦消息被投递到queue（可持久化的消息需要写入磁盘），信道会发送一个确认给生产者（包含消息唯一ID）。如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出。</p>
<p>如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（未确认）消息给生产者。</p>
<p>所有被发送的消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack。</p>
<p>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者，生产者的回调方法会被触发来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。</p>
<p>ConfirmCallback接口：只确认是否正确到达 Exchange 中，成功到达则回调。</p>
<p>ReturnCallback接口：消息失败返回时回调</p>
<p><strong>接收方确认机制：</strong></p>
<p>消费者在声明队列时，可以指定noAck参数，当noAck&#x3D;false时，RabbitMQ会等待消费者显式发回ack信号后才从内存(或者磁盘，持久化消息)中移去消息。否则，消息被消费后会被立即删除。<br>消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p>
<p>RabbitMQ不会为未ack的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很长。保证数据的最终一致性；</p>
<p>如果消费者返回ack之前断开了链接，RabbitMQ 会重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）；</p>
<p>&#x20;<strong>消息队列本身</strong></p>
<p>可以进行消息持久化, 即使rabbitMQ挂了，重启后也能恢复数据</p>
<p>如果要进行消息持久化，那么需要对以下3种实体均配置持久化</p>
<p>a) Exchange</p>
<p>声明exchange时设置持久化（durable &#x3D; true）并且不自动删除(autoDelete &#x3D; false)</p>
<p>b) Queue</p>
<p>声明queue时设置持久化（durable &#x3D; true）并且不自动删除(autoDelete &#x3D; false)</p>
<p>c) message</p>
<p>发送消息时通过设置deliveryMode&#x3D;2持久化消息</p>
<h3 id="4、RabbitMQ事务消息"><a href="#4、RabbitMQ事务消息" class="headerlink" title="4、RabbitMQ事务消息"></a>4、RabbitMQ事务消息</h3><p><strong>通过对信道的设置实现</strong></p>
<ol>
<li>channel.txSelect()；通知服务器开启事务模式；服务端会返回Tx.Select-Ok</li>
<li>channel.basicPublish；发送消息，可以是多条，可以是消费消息提交ack</li>
<li>channel.txCommit()提交事务；</li>
<li>channel.txRollback()回滚事务；</li>
</ol>
<p><strong>消费者使用事务：</strong></p>
<ol>
<li>autoAck&#x3D;false，手动提交ack，以事务提交或回滚为准；</li>
<li>autoAck&#x3D;true，不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了</li>
</ol>
<p>如果其中任意一个环节出现问题，就会抛出IoException异常，用户可以拦截异常进行事务回滚，或决定要不要重复消息。事务消息会降低rabbitmq的性能。</p>
<h3 id="5、RabbitMQ如何实现延迟消息？"><a href="#5、RabbitMQ如何实现延迟消息？" class="headerlink" title="5、RabbitMQ如何实现延迟消息？"></a>5、RabbitMQ如何实现延迟消息？</h3><p>RabbitMQ本身并不直接支持延迟消息的功能，但可以通过结合使用RabbitMQ的一些特性来实现延迟消息的效果。下面介绍两种常见的实现方式：</p>
<ol>
<li>利用消息的过期时间和死信队列（DLX）：这种方式可以通过设置消息的过期时间来实现延迟消息的效果。具体步骤如下：<ul>
<li>创建一个普通的交换机和队列用于接收延迟消息。</li>
<li>设置队列的消息过期时间，可以通过设置队列的<code>x-message-ttl</code>参数或通过单独设置消息的<code>expiration</code>属性。</li>
<li>设置队列的死信交换机和死信路键，将过期的消息发送到指定的死信交换机和路由键。</li>
<li>创建一个死信交换机和队列，用于处理过期的消息。</li>
<li>将队列绑定到死信交换机上，指定合适的路由键。</li>
<li>发送延迟消息时，将消息发送到普通的交换机和队列。<br>消息会在指定的过期时间后发送到死信交换机和队列，从而实现延迟消息的效果。</li>
</ul>
</li>
<li>使用RabbitMQ的延迟插件（rabbitmq_delayed_message_exchange）：RabbitMQ社区提供了一个延迟插件，可以直接实现延迟消息的功能。具体步骤如下：<ul>
<li>下载并安装rabbitmq_delayed_message_exchange插件。</li>
<li>启用延迟插件，通过RabbitMQ的管理界面或命令行工具进行配置。</li>
<li>创建一个延迟交换机和队列，将延迟插件应用到交换机上。</li>
<li>发送延迟消息时，将消息发送到延迟交换机和队列，同时设置消息的延迟时间。<br>延迟交换机会根据消息的延迟时间将消息发送到指定的目标队列，从而实现延迟消息的效果。</li>
</ul>
</li>
</ol>
<p>需要注意的是，以上两种方式都是通过消息的过期时间来实现延迟消息的，因此在使用时需要根据实际需求和性能考虑合适的延迟时间设置。另外，延迟消息的实现可能会增加系统的复杂性和消息的处理延迟，需要根据具体业务场景进行评估和选择。</p>
<h3 id="6、RabbitMQ如何保证消息的顺序性？"><a href="#6、RabbitMQ如何保证消息的顺序性？" class="headerlink" title="6、RabbitMQ如何保证消息的顺序性？"></a>6、RabbitMQ如何保证消息的顺序性？</h3><p>消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常。举例： &#x20;<br>比如通过mysql binlog进行两个数据库的数据同步，由于对数据库的数据操作是具有顺序性的，如果操作顺序搞反，就会造成不可估量的错误。比如数据库对一条数据依次进行了 插入-&gt;更新-&gt;删除操作，这个顺序必须是这样，如果在同步过程中，消息的顺序变成了 删除-&gt;插入-&gt;更新，那么原本应该被删除的数据，就没有被删除，造成数据的不一致问题。</p>
<p>举例场景：</p>
<p>RabbitMQ：</p>
<p>①一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_hH1nSGMkZo.png"></p>
<p>②一个queue对应一个consumer，但是consumer里面进行了多线程消费，这样也会造成消息消费顺序错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_ZZvD1vs-W3.png"></p>
<p>解决方案：</p>
<p>①拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_BGSPAyxTpl.png"></p>
<p>一个queue对应一个consumer</p>
<p>②或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%5CRabbitMQ%5Cimage%5C%E5%9B%BE%E7%89%87_wUfasKGG18.png"></p>
<p>一个queue对应一个consumer，采用多线程</p>
<h3 id="7、如何使用RabbitMQ解决分布式事务？"><a href="#7、如何使用RabbitMQ解决分布式事务？" class="headerlink" title="7、如何使用RabbitMQ解决分布式事务？"></a>7、如何使用RabbitMQ解决分布式事务？</h3><p><strong>分布式事务：</strong> 不同的服务操作不同的数据源（库或表），保证数据一致性的问题。</p>
<p><strong>解决：</strong> 采用RabbitMQ消息最终一致性的解决方案，解决分布式事务问题。</p>
<p>分布式事务场景：</p>
<p>1、电商项目中的商品库和ES库数据同步问题。</p>
<p>2、电商项目中：支付—-订单—库存，一系列操作，进行状态更改等。</p>
<p>在互联网应用中，基本都会有用户注册的功能。在注册的同时，我们会做出如下操作：</p>
<p>收集用户录入信息，保存到数据库向用户的手机或邮箱发送验证码等等…</p>
<p>如果是传统的集中式架构，实现这个功能非常简单：开启一个本地事务，往本地数据库中插入一条用户数据，发送验证码，提交事物。</p>
<p>但是在分布式架构中，用户和发送验证码是两个独立的服务，它们都有各自的数据库，那么就不能通过本地事物保证操作的原子性。这时我们就需要用到 RabbitMQ（消息队列）来为我们实现这个需求。</p>
<p>在用户进行注册操作的时候，我们为该操作创建一条消息，当用户信息保存成功时，把这条消息发送到消息队列。验证码系统会监听消息，一旦接受到消息，就会给该用户发送验证码。</p>
<h3 id="8、如何防止RabbitMQ消息重复消费？"><a href="#8、如何防止RabbitMQ消息重复消费？" class="headerlink" title="8、如何防止RabbitMQ消息重复消费？"></a><strong>8、如何防止RabbitMQ消息重复消费？</strong></h3><p>保证消息幂等性。和保证接口幂等性一样。</p>
<p>RabbitMQ、RocketMQ、Kafka等任何队列不保证消息不重复，如果业务需要消息不重复消费，则需要消费端处理业务消息要保持幂等性</p>
<p>方式一：Redis的setNX() , 做消息id去重 java版本目前不支持设置过期时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Redis中操作，判断是否已经操作过 TODO</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> jedis.setNX(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略，重复消费</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>方式二：redis的 Incr 原子操作：key自增，大于0 返回值大于0则说明消费过，(key可以是消息的md5取值, 或者如果消息id设计合理直接用id做key)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> jedis.incr(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略，重复消费</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式三：数据库去重表</p>
<p>设计一个去重表，某个字段使用Message的key做唯一索引，因为存在唯一索引，所以重复消费会失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `message_record` ( `id` <span class="type">int</span>(<span class="number">11</span>) unsigned NOT NULL AUTO_INCREMENT, `key` varchar(<span class="number">128</span>) DEFAULT NULL, `create_time` datetime DEFAULT NULL, PRIMARY <span class="title function_">KEY</span> <span class="params">(`id`)</span>, UNIQUE KEY `key` (`key`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>

<p>方式四：数据库主键id唯一约束。（但是注意不能把主键id设置为了自增，因此需要生成一个唯一的全局id.作为主键）。</p>
<p><strong>方式五：利用消息队列自带的判断消息唯一性（在消费端）机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果判断该消息已经处理过一次 <span class="comment">// getRedelivered() 判断是否已经处理过一次消息！ </span></span><br><span class="line"><span class="keyword">if</span> (!message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;消息已重复处理,拒绝再次接收&quot;</span>); </span><br><span class="line"> <span class="comment">// 拒绝消息 channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); &#125;</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;该消息不是重复的&quot;</span>);</span><br><span class="line"></span><br><span class="line">channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>方式六：利用</strong>Redis机制</p>
<p><strong>生产者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    jsonObject.put(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> MessageBuilder.withBody(json.getBytes()).setContentType(MessageProperties.CONTENT_TYPE_JSON).setContentEncoding(<span class="string">&quot;UTF-8&quot;</span>).setMessageId(UUID.randomUUID()+<span class="string">&quot;&quot;</span>).build();</span><br><span class="line">    amqpTemplate.convertAndSend(<span class="string">&quot;javatrip&quot;</span>,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageId</span> <span class="operator">=</span> message.getMessageProperties().getMessageId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的消息为：&quot;</span>+msg+<span class="string">&quot;==消息id为：&quot;</span>+messageId);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">messageIdRedis</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;messageId&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(messageId == messageIdRedis)&#123;</span><br><span class="line">            <span class="comment">// 代表是重复的</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(msg);</span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;messageId&quot;</span>,messageId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、如何解决消息队列的延时以及过期失效问题-消息队列满了之后该如何处理-有几百万的消息持续积压几小时-说说如何解决"><a href="#9、如何解决消息队列的延时以及过期失效问题-消息队列满了之后该如何处理-有几百万的消息持续积压几小时-说说如何解决" class="headerlink" title="9、如何解决消息队列的延时以及过期失效问题?消息队列满了之后该如何处理?有几百万的消息持续积压几小时,说说如何解决?"></a>9、如何解决消息队列的延时以及过期失效问题?消息队列满了之后该如何处理?有几百万的消息持续积压几小时,说说如何解决?</h3><p>方案分析</p>
<p>该问题,其本质针对的场景，都是说，可能你的消费端出了问题，不消费了，或者消费的极其极其慢。另外还有可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是整个这就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如rabbitmq设置了消息过期时间后就没了怎么办？</p>
<p>所以这种问题线上常见的，一般不出，一出就是大问题，一般常见于，举个例子，消费端每次消费之后要写mysql，结果mysql挂了，消费端挂掉了。导致消费速度极其慢。</p>
<p>分析1+话术</p>
<p>这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复consumer的问题，让他恢复消费速度，然后傻傻的等待几个小时消费完毕。(可行,但是不建议 在面试的时候说)</p>
<p>一个消费者一秒是1000条，一秒3个消费者是3000条，一分钟是18万条，1000多万条</p>
<p>所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概1小时的时间才能恢复过来</p>
<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下：</p>
<p>1）先修复consumer的问题，确保其恢复消费速度，然后将现有cnosumer都停掉</p>
<p>2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</p>
<p>3）然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</p>
<p>4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</p>
<p>5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</p>
<p>6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p>
<p>分析2+话术</p>
<p>rabbitmq是可以设置过期时间的，就是TTL，如果消息在queue中积压超过一定的时间就会被rabbitmq给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在mq里，而是大量的数据会直接搞丢。</p>
<p>这个情况下，就不是说要增加consumer消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。</p>
<p>这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入mq里面去，把白天丢的数据给他补回来。也只能是这样了。</p>
<p>假设1万个订单积压在mq里面，没有处理，其中1000个订单都丢了，你只能手动写程序把那1000个订单给查出来，手动发到mq里去再补一次</p>
<p>分析3+话术</p>
<p>如果走的方式是消息积压在mq里，那么如果你很长时间都没处理掉，此时导致mq都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="Cloud核心中间件100"><a href="#Cloud核心中间件100" class="headerlink" title="Cloud核心中间件100%"></a>Cloud核心中间件100%</h2><h3 id="一、Nacos"><a href="#一、Nacos" class="headerlink" title="一、Nacos"></a><strong>一、Nacos</strong></h3><h4 id="1、注册中心如何选型？"><a href="#1、注册中心如何选型？" class="headerlink" title="1、注册中心如何选型？"></a>1、注册中心如何选型？</h4><p>选择注册中心时，需要考虑以下几个方面的因素：&#x20;</p>
<ol>
<li>高可用性：注册中心是服务治理的核心组件，因此高可用性是非常重要的。注册中心应该能够容忍单点故障，并且能够自动进行故障转移和恢复。</li>
<li>性能和扩展性：注册中心需要能够处理大量的服务实例注册和查询请求，并保持较低的延迟。此外，注册中心还应该支持水平扩展，以应对日益增长的服务规模。</li>
<li>数据一致性：注册中心应该保证数据的一致性，即使在面对网络分区或节点故障的情况下也能保持数据的可靠性和准确性。</li>
<li>安全性：注册中心应该提供合适的安全机制，包括身份认证、访问控制和数据加密等，以保护服务实例的注册信息和通信数据的安全。</li>
<li>功能和灵活性：注册中心应该提供丰富的功能，如服务发现、负载均衡、服务路由、健康检查等，还应该具备灵活的配置和扩展能力，以满足不同的业务需求。</li>
<li>社区支持和生态系统：选择一个有活跃的社区和丰富的生态系统的注册中心，可以获得更好的技术支持和资源，以及更多的集成和扩展选项。</li>
</ol>
<p>常见的注册中心选型包括：ZooKeeper、Consul、Etcd、Eureka等。每个注册中心都有其特点和优势，需要根据具体的业务需求和技术栈来选择适合的注册中心。同时，也可以考虑多个注册中心组合使用，以实现高可用性和灵活性的要求。</p>
<h4 id="2、什么是Nacos，主要用来作什么？"><a href="#2、什么是Nacos，主要用来作什么？" class="headerlink" title="2、什么是Nacos，主要用来作什么？"></a>2、什么是Nacos，主要用来作什么？</h4><p>Nacos是一个开源的分布式服务注册和配置中心。它提供了服务注册、发现、配置和管理的能力，可以帮助开发者构建和管理微服务架构。</p>
<p>主要功能包括：</p>
<ol>
<li>服务注册与发现：Nacos充当了服务注册中心的角色，服务提供者通过向Nacos注册自己的服务，使得服务消费者能够方便地发现和调用服务。</li>
<li>动态配置管理：Nacos提供了统一的配置管理功能，可以集中管理应用程序的配置信息。它支持动态刷新配置，可以在运行时动态修改应用程序的配置，而无需重启应用。</li>
<li>服务路由与负载均衡：Nacos可以根据服务的健康状况和负载情况，动态地进行服务路由和负载均衡，以提供更好的服务质量和可用性。</li>
<li>服务共享与版本管理：Nacos支持多租户的服务共享，不同的租户可以共享同一个服务。同时，Nacos还提供了版本管理功能，可以管理不同版本的服务。</li>
<li>服务监控与治理：Nacos提供了服务的健康检查和监控功能，可以实时监控服务的状态和性能指标。此外，Nacos还提供了服务熔断、限流等治理能力，以提高系统的稳定性和可靠性。</li>
</ol>
<p>总之，Nacos是一个功能强大的分布式服务注册和配置中心，它可以帮助开发者简化微服务架构的开发和管理工作，提高系统的弹性和可伸缩性。</p>
<h4 id="3、Nacos是AP的还是CP的？"><a href="#3、Nacos是AP的还是CP的？" class="headerlink" title="3、Nacos是AP的还是CP的？"></a>3、Nacos是AP的还是CP的？</h4><p>Nacos是一个AP（可用性和分区容忍性）的系统。在分布式系统中，CAP定理指出，一个系统无法同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三个特性。Nacos选择了AP模型，即在面对网络分区时，为了保证系统的可用性和分区容忍性，它牺牲了一致性。这意味着在网络分区的情况下，Nacos可能会出现数据的不一致性，但它能够保证服务的可用性和高效性。对于服务注册发现、配置管理等功能，Nacos提供了强大的可用性和灵活性，使得开发者能够便捷地构建和管理分布式系统。然而，在某些特定情况下，如果一致性是系统中最重要的特性，那么可能需要考虑选择其他CP模型的系统。</p>
<h4 id="4、Nacos如何实现的配置变化客户端可以感知到？"><a href="#4、Nacos如何实现的配置变化客户端可以感知到？" class="headerlink" title="4、Nacos如何实现的配置变化客户端可以感知到？"></a>4、Nacos如何实现的配置变化客户端可以感知到？</h4><p>Nacos通过以下机制实现配置变化客户端可以感知到：</p>
<ol>
<li>长轮询（Long Polling）：客户端可以向Nacos发送一个长轮询请求，如果配置发生变化，Nacos会立即返回配置变化的通知给客户端。客户端在收到通知后可以及时更新本地配置。</li>
<li>客户端缓存：Nacos客户端会在本地缓存配置信息，定期从Nacos服务器拉取最新的配置。当Nacos服务器上的配置发生变化时，客户端会通过定时任务或者其他方式从Nacos服务器获取最新的配置。</li>
<li>事件通知机制：Nacos会将配置变更事件发布给订阅了该配置的客户端。客户端可以订阅特定的配置，当该配置发生变化时，Nacos会发送事件通知给客户端，客户端收到通知后可以进行相应的处理。</li>
</ol>
<p>通过以上机制，Nacos实现了配置变化的实时感知。客户端可以根据自身的需求选择适合的方式来获取配置变化的通知，并进行相应的处理。这样，当配置发生变化时，客户端可以及时更新配置，实现配置的动态管理。</p>
<h4 id="5、Nacos能同时实现AP和CP的原理是什么？"><a href="#5、Nacos能同时实现AP和CP的原理是什么？" class="headerlink" title="5、Nacos能同时实现AP和CP的原理是什么？"></a>5、Nacos能同时实现AP和CP的原理是什么？</h4><p>Nacos能够同时实现AP（可用性和分区容忍性）和CP（一致性和分区容忍性）的原理是通过引入不同的组件和机制来实现的。</p>
<p>在Nacos中，服务注册和发现模块采用了AP模型，通过将服务实例的注册信息存储在多个节点上，实现了服务的高可用性和分区容忍性。当某个节点发生故障或网络分区时，其他节点仍然可以提供服务注册和发现的功能。</p>
<p>而配置管理模块则采用了CP模型，通过使用Raft协议来实现一致性。当客户端更新配置时，Nacos会将配置写入多个节点的Raft日志中，经过多数节点的确认后才会认为配置写入成功。这保证了配置的一致性。在配置变更时，通过Raft协议的复制机制，确保配置变更在集群中的所有节点上同步，保证了配置的一致性和可靠性。</p>
<p>通过这种方式，Nacos在不同的模块中根据需求选择了合适的一致性和可用性模型，从而同时实现了AP和CP的特性。这使得Nacos能够满足分布式系统在服务注册、发现和配置管理等方面的需求，提供高可用性、弹性和可靠性的服务。</p>
<h4 id="6、Nacos服务发现的原理"><a href="#6、Nacos服务发现的原理" class="headerlink" title="6、Nacos服务发现的原理"></a>6、Nacos服务发现的原理</h4><p>服务发现：</p>
<p>调用方在第一去发起远程调用的时候，会把远程的服务以及该服务的实例都缓存到本地Map中，当后面在去发起远程调用的时候，就会优先查询本地Map,如果本地Map有，那么直接根据本地Map的数据，去发起远程调用，如若没有，才像远程（Nacos）发送一个请求:&#x2F;nacos&#x2F;v1&#x2F;ns&#x2F;list.获取到远程数据在同步到缓存。</p>
<p>有了本地缓存机制，就可以保证我未来发起远程调用的时候，更快。但是会带来数据一致性问题。</p>
<p>如何解决本地缓存和远程数据一致性问题：</p>
<p><strong>1、被动定时拉取</strong>，每隔10s钟会发起一个查询（远程Nacos）最新数据，来同步本地Map这样做虽然能够解决最终这两份数据是一致的，但是在这一次定时任务和下一次定时任务开始之间，远程注册表发生了变化，那么就获取不到远程（Nacos）最新。而对于定时任务发请求去要远程数据这个环节走的是tcp协议，而用了</p>
<p>tcp协议之后就可以保证数据包不丢失。但是tcp协议会有三次握手和四次挥手，因此从效率来说，会慢一些。</p>
<p>初始化1s执行这个定时任务，如果在某一次找远程要的时候没有出现异常，那么这个任务每隔10s会继续执行，但是如果在找远程要数据的时候，出现了异常，那么这个时间就会从2s开始,最多到1min钟结束。</p>
<p><strong>2、主动推送更新</strong>，一旦远程注册表发生了改变，那么Nacos服务端会主动发送一个事件，并且使用的是udp协议来发送的，接着我客户端只要订阅了这个udp的端口，那么就会让客户端主动去找远程Nacos获取最新的注册表。</p>
<p>upd协议：快，（因为没有三次握手和四种挥手的过程）但是可能会丢失数据包。</p>
<p>最终Ncaos来解决服务发现数据不一致问题是通过TCP协议的定时任务发请求，和UDP协议的主动发送事件请求，来解决一致性的。</p>
<h4 id="7、Nacos注册中心原理"><a href="#7、Nacos注册中心原理" class="headerlink" title="7、Nacos注册中心原理"></a>7、<strong>Nacos注册中心原理</strong></h4><p><a href="file/0301-Nacos_IDYXct_ol2.pdf" title=" 0301-Nacos.pdf">0301-Nacos.pdf</a></p>
<p><a href="file/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83AP%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90%E6%B5%81%E7%A8%8B%E5%9B%BE%20(1)_JWHQ4WlJvO.pdf" title=" Nacos注册中心AP架构剖析流程图 (1).pdf">Nacos注册中心AP架构剖析流程图 (1).pdf</a></p>
<p><strong>具体细节请结合课上分析。</strong></p>
<h3 id="二、Feign"><a href="#二、Feign" class="headerlink" title="二、Feign"></a>二、Feign</h3><h4 id="Feign的调用原理："><a href="#Feign的调用原理：" class="headerlink" title="Feign的调用原理："></a><strong>Feign的调用原理：</strong></h4><p>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理 &#x20;<br>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址  最后针对这个地址，发起请求、解析响应。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5CCloud%E6%A0%B8%E5%BF%83%E4%B8%AD%E9%97%B4%E4%BB%B6%5Cimage%5C%E5%9B%BE%E7%89%87_2BGbpmra-b.png"></p>
<h4 id="Feign-Nacos注册中心原理："><a href="#Feign-Nacos注册中心原理：" class="headerlink" title="Feign+Nacos注册中心原理："></a><strong>Feign+Nacos注册中心原理</strong>：</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5CCloud%E6%A0%B8%E5%BF%83%E4%B8%AD%E9%97%B4%E4%BB%B6%5Cimage%5C%E5%9B%BE%E7%89%87_F6hRLanAOa.png"></p>
<h4 id="Feign的底层调用源码大致流程"><a href="#Feign的底层调用源码大致流程" class="headerlink" title="Feign的底层调用源码大致流程:"></a><strong>Feign的底层调用源码大致流程:</strong></h4><p>1.1、判断当前代理的方式是不是equals()、hashCode()、toString().如果是 直接结束，因为本地服务有这些方法，压根不需要从远程来要。 &#x20;</p>
<p>1.2、dispatch.get(method).invoke(args)  <strong>：核心代理逻辑</strong></p>
<p>从一个派发器中获取解析当前方法的处理器  —派发器的结构是一个Map— Map&lt;Method, MethodHandler&gt;来获取解析这个方法的处理器  。</p>
<p>默认从这个Map中找到的方法处理器是SynchronousMethodHandler—同步方法处理器 &#x20;</p>
<p>1.3、SynchronousMethodHandler.invoke（args） &#x20;</p>
<p>1.3.1 构建一个RequestTemplate。作用是为了发请求的是时候用这个模版造一个请求 &#x20;</p>
<p>细节：根据老的请求模版构建一个新的请求模版，接着会将老的请求模版中的一些参数放到新的请求模版中，但是请求头中参数如果没有在Feign中去指定的话，  那么这个老模版中就没有头，而新模板中也就没有请求头数据。因此后面在用这个新模版创建请求的时候，该请求就没有请求头数据，所以Feign在远程调用时出现了请求头丢失问题。 &#x20;</p>
<p>1.3.2 支持Options—可以独立对自己的业务远程接口去指定一些连接超时时间和读取的超时时间。 &#x20;</p>
<p>1.3.3 得到一个重试器Retryer &#x20;</p>
<p>如果在发送远程调用的时候，出现异常，那么feign在底层会用catch捕捉到， &#x20;</p>
<p>然后进行重试—  retryer.continueOrPropagate(e); &#x20;</p>
<p>但是对于重试feign自己也有规则： &#x20;</p>
<p>如果一旦在重试期间出现了异常，直接将异常抛出，结束这一次远程调用。 &#x20;</p>
<p>如果在重试期间没有出现异常，但是feign通过最大次数（5次调用）如果到了最大次数5 那么feign仍然是会抛出异常，结束这一次远程调用。 &#x20;</p>
<p>1.3.4 executeAndDecode—执行并解码（执行：指的是要去给远程发请求 解码：远程给我的数据都是字节流 我要将自字节流转成我业务能用的对象【反序列化】 ） &#x20;</p>
<p>1.3.4.1 发送请求 &#x20;</p>
<p>response &#x3D; client.execute(); &#x20;</p>
<p>-–根据服务名从Nacos找到该服务下的所有客户端，然后负载均衡的掉用某一个。并且在第一次找该客户端的时候， &#x20;</p>
<p>会将第一次找到的这个客户端放到缓存中去，下一次再来发起远程调用的时候，直接从缓存中获取该客户端。&#x20;</p>
<p>1.3.4.2 对响应的数据进行反序列化 &#x20;</p>
<p>handleResponse();</p>
<h4 id="远程调用的本质："><a href="#远程调用的本质：" class="headerlink" title="远程调用的本质："></a><strong>远程调用的本质</strong>：</h4><p>1、建立连接 &#x20;<br>2、给远程发送请求 &#x20;<br>3、远程处理数据 &#x20;<br>4、远程响应数据 &#x20;<br>5、将数据进行渲染</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h3 id="1-、为什么要使用ElasticSearch？"><a href="#1-、为什么要使用ElasticSearch？" class="headerlink" title="1 、为什么要使用ElasticSearch？"></a>1 、为什么要使用ElasticSearch？</h3><p>使用Elasticsearch有以下几个主要原因：</p>
<ol>
<li>强大的全文搜索功能：Elasticsearch是一个基于Lucene的分布式搜索引擎，具有强大的全文搜索和检索功能。它支持复杂的查询语法和多种搜索方式，能够高效地处理大量的文本数据。这使得它非常适合用于构建搜索引擎、日志分析、内容推荐等应用。</li>
<li>分布式和高可用性：Elasticsearch是一个分布式系统，它能够将数据分布在多个节点上进行存储和计算。这使得它具有高可用性和横向扩展能力，能够处理大规模数据和高并发访问。它还支持故障转移和自动数据恢复，即使某个节点发生故障，系统仍然可以继续运行。</li>
<li>实时数据分析和聚合：Elasticsearch提供了强大的聚合功能，能够对大规模数据进行实时的数据分析和统计。它支持各种聚合操作，如求和、平均值、最大最小值、分组计数等，能够快速生成各种报表和可视化图表，帮助用户更好地理解和利用数据。</li>
<li>构建实时应用：Elasticsearch具有低延迟的写入和查询能力，能够快速响应实时数据的变化。这使得它非常适合用于构建实时监控、实时推荐、实时搜索等实时应用场景。</li>
<li>生态系统和易用性：Elasticsearch拥有丰富的生态系统，包括Kibana用于数据可视化、Logstash用于日志收集和处理、Beats用于数据采集等。它还提供了RESTful API和丰富的客户端库，使得开发和集成变得非常简单和灵活。</li>
</ol>
<p>综上所述，Elasticsearch因其强大的全文搜索能力、分布式和高可用性特性、实时数据分析能力以及丰富的生态系统而成为一种流行的选择，适用于各种大规模数据处理和实时应用场景。</p>
<h3 id="2-、ElasticSearch为什么快？"><a href="#2-、ElasticSearch为什么快？" class="headerlink" title="2 、ElasticSearch为什么快？"></a>2 、ElasticSearch为什么快？</h3><p>Elasticsearch之所以快速，主要有以下几个原因：</p>
<ol>
<li>倒排索引（Inverted Index）：Elasticsearch使用倒排索引来加速搜索过程。倒排索引是一种将词条与其出现位置的映射关系存储在索引中的数据构。通过倒排索引，Elasticsearch可以快速定位包含特定词条的文档，从而加搜索效率。</li>
<li>分布式架构：Elasticsearch是一个分布式系统，它可以将数据分布在多个节点上进行存储和计算。这使得它具有横向扩展能力，能够处理大规模数据和高并发访问。通过将数据分片和分布式查询，Elasticsearch可以并行处理搜索请求，从而提高搜索效率。</li>
<li>倒排索引的内存缓存：Elasticsearch使用内存缓存来提高搜索性能。它会将热门的词条和搜索结果存储在内存中，以便快速响应查询请求。通过利用内存缓存，Elasticsearch可以避免频繁的磁盘访问而加速搜索速度。</li>
<li>集群化部署和负载均衡：Elasticsearch支持集群化部署，可以将索引和查询请求分布在多个节点上。它还提供了负载均衡机制，能够均衡地将请求分发给不同的节点，从而提高整体的处理能力和响应速度。</li>
<li>后台实时刷新机制：Elasticsearch采用了近实时（Near Real-time）的刷新机制。当数据写入到Elasticsearch时，它会先写入内存缓冲区，然后异步地刷新到磁盘。这样可以避免频繁地磁盘写入，同时保证数据的可靠性和一致性。</li>
</ol>
<p>综上所述，Elasticsearch通过倒排索引、分布式架构、内存缓存、负载均衡和实时刷新机制等技术手段，实现了高效的搜索和查询功能，从而使其具备快速响应和处理大规模数据的能力。</p>
<h3 id="3-、倒排索引是什么？"><a href="#3-、倒排索引是什么？" class="headerlink" title="3 、倒排索引是什么？"></a>3 、倒排索引是什么？</h3><p>倒排索引（Inverted Index）是一种将词条与其出现位置的映射关系存储在索引中的数据结构。它是一种反转（倒排）了文档-词条关系的索引方式。通常，一个正向索引（Forward Index）是通过文档ID来查找对应的词条，而倒排索引则是通过词条来查找对应的文档ID。</p>
<p>在倒排索引中，每个词条都会关联一个或多个文档。对于每个词条，倒排索引会记录下它在哪些文档中出现过以及出现的位置。这样，当需要搜索某个词条时，可以快速地找到包含该词条的文档。</p>
<p>倒排索引通常由两个主要部分组成：词典（Dictionary）和倒排列表（Inverted List）。词典以词条为键，记录了每个词条对应的倒排列表的位置。而倒排列表则包含了所有包含该词条的文档ID以及出现位置的信息。</p>
<p>倒排索引的结构使得搜索引擎能够快速定位包含特定词条的文档，从而加快搜索的速度。它是搜索引擎中常用的索引结构，被广泛应用于全文搜索、文本分析和信息检索等领域。</p>
<h3 id="4-、如何保证ES和数据库的数据一致性？"><a href="#4-、如何保证ES和数据库的数据一致性？" class="headerlink" title="4 、如何保证ES和数据库的数据一致性？"></a>4 、如何保证ES和数据库的数据一致性？</h3><p>为了保证Elasticsearch（ES）和数据库的数据一致性，可以采取以下几种方式：</p>
<ol>
<li>实时同步：在数据更新到数据库之后，立即将相应的数据同步到ES中。可以通过在应用程序的业务逻辑中，同时更新数据库和ES来实现实时同步。这样可以保证数据库和ES中的数据始终保持一致。</li>
<li>延迟同步：在数据更新到数据库之后，通过定时任务或消息队列等机制，定期批量将更新的数据同步到ES中。这种方式可以降低对数据库写入操作的性能影响，并在一定程度上保证数据的同步性。</li>
<li>双写模式：在数据更新时，同时向数据库和ES进行写入操作。这种方式可以确保数据同时写入到两个存储系统，从而保证数据的一致性。但是需要注意双写模式可能增加系统的复杂度和写入延迟。</li>
<li>使用数据库的日志或触发器：数据库的日志或触发器可以捕获数据的变更操作，然后通过监听这些变更操作，将数据同步到ES中。这种方式可以避免对应用程序进行大量修改，但需要考虑数据库和ES之间的网络延迟和数据同步的顺序。</li>
</ol>
<p>无论采取哪种方式，都需要确保数据库和ES的数据操作是原子的、可靠的，并且在故障恢复时能够保持数据的一致性。此外，还可以通过监控和日志记录来及时发现和解决数据同步的问题，确保数据的一致性和可靠性。</p>
<h2 id="微服务、分布式100"><a href="#微服务、分布式100" class="headerlink" title="微服务、分布式100%"></a>微服务、分布式100%</h2><h3 id="1、分布式和微服务的区别是什么？"><a href="#1、分布式和微服务的区别是什么？" class="headerlink" title="1、分布式和微服务的区别是什么？"></a>1、分布式和微服务的区别是什么？</h3><p>分布式系统和微服务是两个相关但不同的概念，它们都涉及到软件架构中的组织和设计原则。以下是它们的区别：</p>
<ol>
<li><strong>定义和范围</strong>：<ul>
<li>分布式系统：分布式系统是由多台计算机或服务器协同工作，通过网络通信来完成共同的任务。这些计算机可以分布在不同的地理位置，但它们通过网络连接进行协作。</li>
<li>微服务：微服务是一种软件架构风格，将一个大型应用程序拆分成一组小型、独立的服务。每个微服务都专注于执行一个特定的业务功能，可以独立开发、部署和扩展。</li>
</ul>
</li>
<li><strong>关注点</strong>：<ul>
<li>分布式系统：关注于如何将不同的计算机或服务器连接起来，以实现高性能、高可用性和负载均衡等目标。</li>
<li>微服务：关注于如何将大型应用程序拆分成更小、更可管理的部分，并通过松耦合的方式来实现更灵活的开发、部署和维护。</li>
</ul>
</li>
<li><strong>通信方式</strong>：<ul>
<li>分布式系统：分布式系统中的组件之间需要进行网络通信，常见的通信方式包括远程过程调用（RPC）、消息队列等。</li>
<li>微服务：微服务之间通常使用HTTP等协议进行通信，可以通过RESTful API或其他通信方式来实现。</li>
</ul>
</li>
<li><strong>数据一致性</strong>：<ul>
<li>分布式系统：在分布式系统中，确保数据一致性是一个挑战，需要考虑分布式事务、数据复制等问题。</li>
<li>微服务：每个微服务可以拥有自己的数据存储，因此可以根据需求选择适当的数据库类型，并更容易管理数据一致性。</li>
</ul>
</li>
<li><strong>部署和扩展</strong>：<ul>
<li>分布式系统：需要关注整体系统的部署和扩展，可能需要考虑多台服务器的管理和配置。</li>
<li>微服务：每个微服务都可以独立部署和扩展，使得开发团队更容易管理和调整特定功能。</li>
</ul>
</li>
</ol>
<p>总的来说，分布式系统是一种基础架构模式，而微服务是一种架构风格。微服务通常可以在分布式系统中实现，但并不是所有分布式系统都采用微服务架构。微服务架构的主要目标是使开发、部署和维护更加灵活，适用于复杂的应用场景。</p>
<h3 id="2、什么是微服务架构？优势？特点？"><a href="#2、什么是微服务架构？优势？特点？" class="headerlink" title="2、什么是微服务架构？优势？特点？"></a>2、什么是微服务架构？优势？特点？</h3><p>微服务架构是一种软件架构风格，将一个大型的应用程序拆分成多个小型、自治的服务单元，每个服务单元都专注于执行特定的业务功能。每个微服务可以独立开发、部署、扩展和维护，通过轻量级通信机制协同工作。微服务架构的优势和特点包括：</p>
<ol>
<li><strong>模块化与自治性</strong>：微服务架构通过拆分应用为多个服务单元，使得开发团队可以更加专注于各自的业务领域。每个微服务都是独立的，有自己的代码、数据库、API等，可以在不影响其他服务的情况下进行修改和更新。</li>
<li><strong>灵活性与快速交付</strong>：微服务的自治性使得团队可以独立地开发、测试、部署和发布服务。这种独立性加速了开发周期，使团队能够更快地交付新功能和更新。</li>
<li><strong>可扩展性</strong>：微服务架构允许单独扩展每个服务，根据需求动态分配资源。这使得系统更具弹性，能够应对高负载和流量峰值。</li>
<li><strong>技术多样性</strong>：不同的微服务可以使用不同的技术栈，因为它们之间通过API通信。这允许团队选择最适合其任务的技术，而不受整个应用的技术限制。</li>
<li><strong>容错性与隔离性</strong>：由于微服务是自治的，一个服务的故障不会影响整个系统。故障在较小的范围内隔离，从而提高了整体系统的容错性。</li>
<li><strong>持续集成与持续交付</strong>：微服务架构有助于实现持续集成和持续交付，因为每个服务可以独立地构建、测试和发布。这有助于减少部署的风险，并快速响应用户需求。</li>
<li><strong>灵活的团队组织</strong>：微服务架构鼓励小团队负责特定的微服务，使得团队更加灵活，能够快速做出决策和调整。</li>
</ol>
<p>然而，微服务架构也带来了一些挑战，如分布式系统的复杂性、服务间通信的管理、数据一致性等问题。对于不同的应用场景，需仔细权衡微服务的优势与挑战，以确定是否采用这种架构。</p>
<h3 id="3、负载均衡算法、类型"><a href="#3、负载均衡算法、类型" class="headerlink" title="3、负载均衡算法、类型"></a>3、负载均衡算法、类型</h3><p><strong>1、轮询法</strong><br>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p>
<p><strong>2、随机法</strong><br>通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p>
<p><strong>3、源地址哈希法</strong><br>源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p>
<p><strong>4、加权轮询法</strong><br>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p>
<p><strong>5、加权随机法</strong><br>与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p>
<p><strong>6、最小连接数法</strong><br>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p>
<p><strong>类型：</strong><br>1、DNS 方式实现负载均衡<br>2、硬件负载均衡：F5 和 A10<br>3、软件负载均衡：Nginx 、 HAproxy 、 LVS&#x20;</p>
<p>其中的区别：<br>Nginx ：七层负载均衡，支持 HTTP、E-mail 协议，同时也支持 4 层负载均衡；<br>HAproxy ：支持七层规则的，性能也很不错。OpenStack 默认使用的负载均衡软件就是<br>HAproxy；<br>LVS ：运行在内核态，性能是软件负载均衡中最高的，严格来说工作在三层，所以更通用一些，<br>适用各种应用服务。</p>
<h3 id="4、分布式架构下，Session-共享有什么方案"><a href="#4、分布式架构下，Session-共享有什么方案" class="headerlink" title="4、分布式架构下，Session 共享有什么方案"></a>4、分布式架构下，Session 共享有什么方案</h3><ul>
<li>采用无状态服务，抛弃Session，使用中间件存储，比如MySQL&#x2F;Redis等。</li>
</ul>
<p>&#x20;    把 Session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的。</p>
<ul>
<li>存入cookie（要考虑跨域问题，且有安全风险）</li>
<li>Tomcat集群Session同步</li>
<li>使用Spring-Session</li>
<li>IP 绑定策略</li>
</ul>
<p>&#x20;     使用 Nginx （或其他复杂均衡软硬件）中的 IP 绑定策略，同一个 IP 只能在指定的同一个机器访问，但是这样做失去了负载均衡的意义，当挂掉一台服务器的时候，会影响一批用户的使用，风险很大；</p>
<p><strong>实现了 Session 共享好处；</strong><br>1、可以水平扩展（增加 Redis 服务器）；<br>2、服务器重启 Session 不丢失（不过也要注意 数据在 Redis 中的刷新&#x2F;失效机制）；<br>3、不仅可以跨服务器 Session 共享，甚至可以跨平台（例如网页端和 APP 端）；</p>
<h3 id="5、CAP理论，BASE理论"><a href="#5、CAP理论，BASE理论" class="headerlink" title="5、CAP理论，BASE理论"></a>5、CAP理论，BASE理论</h3><p><strong>Consistency (一致性)：</strong><br>即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致。<br>对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。<br>从服务端来看，则是更新后如何复制分布到整个系统，以保证数据最终一致。</p>
<p><strong>Availability (可用性):</strong><br>即服务一直可用，而且是正常响应时间。系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</p>
<p><strong>Partition Tolerance (分区容错性):</strong><br>即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</p>
<p>CP和AP：分区容错是必须保证的，当发生网络分区的时候，如果要继续服务，那么强一致性和可用性只能 2 选 1。</p>
<p><strong>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</strong></p>
<p>BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<p><strong>基本可用</strong>：</p>
<ul>
<li>响应时间上的损失: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。<br>系统功能上的损失：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<p><strong>软状态：</strong> 数据同步允许一定的延迟</p>
<p><strong>最终一致性：</strong> 系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态，不要求实时。</p>
<h3 id="6、分布式Id生成方案"><a href="#6、分布式Id生成方案" class="headerlink" title="6、分布式Id生成方案"></a>6、分布式Id生成方案</h3><ul>
<li>uuid</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1：当前日期和时间 时间戳</span><br><span class="line">2：时钟序列。 计数器</span><br><span class="line">3：全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</span><br><span class="line"></span><br><span class="line">优点：代码简单，性能好（本地生成，没有网络消耗），保证唯一（相对而言，重复概率极低可以忽</span><br><span class="line">略）</span><br><span class="line">缺点：</span><br><span class="line">1)每次生成的ID都是无序的，而且不是全数字，且无法保证趋势递增。</span><br><span class="line">2)UUID生成的是字符串，字符串存储性能差，查询效率慢，写的时候由于不能产生顺序的append</span><br><span class="line">操作，在进行insert操作，可能会导致频繁的页分裂，这种操作在记录占用空间比较大的情况下，性</span><br><span class="line">能下降比较大，还会增加读取磁盘次数。</span><br><span class="line">3)UUID长度过长，不适用于存储，耗费数据库性能。</span><br><span class="line">4)ID无一定业务含义，可读性差。</span><br></pre></td></tr></table></figure>

<ul>
<li>数据库自增序列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">单机模式： </span><br><span class="line"> 优点： </span><br><span class="line">实现简单，依靠数据库即可，成本小。</span><br><span class="line">ID数字化，单调自增，满足数据库存储和查询性能。</span><br><span class="line">具有一定的业务可读性。（结合业务code）</span><br><span class="line"></span><br><span class="line"> 缺点： </span><br><span class="line">强依赖DB，存在单点问题，如果数据库宕机，则业务不可用。</span><br><span class="line">DB生成ID性能有限，单点数据库压力大，无法扛高并发场景。</span><br><span class="line">信息安全问题，比如暴露订单量，url查询改一下id查到别人的订单</span><br><span class="line">分布式下生成的id会重复</span><br><span class="line"></span><br><span class="line"> 数据库高可用： 多主模式做负载，基于序列的起始值和步长设置，不同的初始值，相同的步长，步长大</span><br><span class="line">于等于节点数。</span><br><span class="line"> 优点： </span><br><span class="line">解决了ID生成的单点问题，同时平衡了负载。</span><br><span class="line">解决了分布式环境下id重复问题。</span><br><span class="line"> 缺点： </span><br><span class="line">系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。</span><br><span class="line">主从同步的时候：电商下单-&gt;支付insert master db select数据 ，因为数据同步延迟导致</span><br><span class="line">查不到这个数据。加cache(不是最好的解决方式)数据要求比较严谨的话查master主库。</span><br></pre></td></tr></table></figure>

<ul>
<li>基于redis、mongodb、zk等中间件生成</li>
<li>雪花算法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">生成一个64bit的整性数字</span><br><span class="line">第一位符号位固定为0，41位时间戳，10位workId，12位序列号</span><br><span class="line">位数可以有不同实现。</span><br><span class="line"></span><br><span class="line"> 优点： </span><br><span class="line">每个毫秒值包含的ID值很多，不够可以变动位数来增加，性能佳（依赖workId的实现）。</span><br><span class="line">时间戳值在高位，中间是固定的机器码，自增的序列在低位，整个ID是趋势递增的。</span><br><span class="line">能够根据业务场景数据库节点布置灵活挑战bit位划分，灵活度高。</span><br><span class="line"></span><br><span class="line"> 缺点： </span><br><span class="line">强依赖于机器时钟，如果时钟回拨，会导致重复的ID生成，所以一般基于此的算法发现时钟回拨，</span><br><span class="line">都会抛异常处 理，阻止ID生成，这可能导致服务不可用</span><br></pre></td></tr></table></figure>

<h3 id="7、分布式锁的解决方案"><a href="#7、分布式锁的解决方案" class="headerlink" title="7、分布式锁的解决方案"></a>7、分布式锁的解决方案</h3><p>需要这个锁独立于每一个服务之外，而不是在服务里面。</p>
<p><strong>数据库</strong>：利用主键冲突控制一次只有一个线程能获取锁，非阻塞、不可重入、单点、失效时间。<br><strong>Zookeeper分布式锁</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zk通过临时节点，解决了死锁的问题，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临</span><br><span class="line">时节点就会自动删除掉，其他客户端自动获取锁。临时顺序节点解决惊群效应</span><br></pre></td></tr></table></figure>

<p><strong>Redis分布式锁</strong>：setNX，单线程处理网络请求，不需要考虑并发安全性。<br>所有服务节点设置相同的key，返回为0、则锁获取失败</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setnx</span><br><span class="line">问题：</span><br><span class="line">1、早期版本没有超时参数，需要单独设置，存在死锁问题（中途宕机）。</span><br><span class="line">2、后期版本提供加锁与设置时间原子操作，但是存在任务超时，锁自动释放，导致并发问题，加锁与释</span><br><span class="line">放锁不是同一线程问题。</span><br></pre></td></tr></table></figure>

<p>删除锁：判断线程唯一标志，再删除。<br>可重入性及锁续期没有实现，通过redisson解决（类似AQS的实现，看门狗监听机制）<br>redlock：意思的机制都只操作单节点、即使Redis通过sentinel保证高可用，如果这个master节点由于<br>某些原因发生了主从切换，那么就会出现锁丢失的情况（redis同步设置可能数据丢失）。redlock从多<br>个节点申请锁，当一半以上节点获取成功、锁才算获取成功，redission有相应的实现。</p>
<h3 id="8、实现一个分布式锁需要考虑哪些问题？"><a href="#8、实现一个分布式锁需要考虑哪些问题？" class="headerlink" title="8、实现一个分布式锁需要考虑哪些问题？"></a>8、实现一个分布式锁需要考虑哪些问题？</h3><p>实现一个分布式锁时，需要考虑以下几个问题：</p>
<ol>
<li>锁的唯一性：在分布式环境下，需要确保同一把锁在不同的节点之间是唯一的。可以使用全局唯一标识符（例如基于ZooKeeper或Redis的分布式锁）来确保锁的唯一性。</li>
<li>死锁和活锁：分布式环境下的死锁和活锁是需要避免的问题。死锁是指多个节点互相等待对方释放锁的情况，而活锁是指多个节点不断争夺锁资源，但没有一个节点能够成功获取锁。为了避免死锁和活锁，可以使用超时机制、重试机制、随机等待时间等策略来解决。</li>
<li>锁的可重入性：分布式锁是否支持可重入是需要考虑的问题。可重入意味着同一个线程可以多次获取同一把锁，而不会发生死锁。在实现分布式锁时，需要考虑是否支持可重入，并在实现时进行相应的处理。</li>
<li>锁的粒度：锁的粒度是指锁的范围，即锁定的是整个系统、模块、方法还是更细粒度的资源。在分布式环境下，锁的粒度需要根据实际需求进行选择，避免锁的范围大或过小。</li>
<li>锁的性能和可靠性：分布式锁的性能和可靠性是需要考虑的问题。锁的获取和释放需要保证高效且可靠，同时要考虑网络延迟、节点故障等因素对锁性能和可靠性的影响。</li>
<li>锁的容错和容量：在分布式环境下，需要考虑节点故障和网络分区等异常情况对锁的影响。可以使用多个节点进行容错和冗余，以确保锁的可用性和容量。</li>
</ol>
<p>综上所述，实现一个分布式锁需要考虑锁的唯一性、死锁和活锁、锁的可重入性、锁的粒度、锁的性能和可靠性，以及锁的容错和容量等问题。根据具体需求选择适合的分布式锁方案，并在实现时合理处理这些问题。</p>
<h3 id="9、什么是分布式事务"><a href="#9、什么是分布式事务" class="headerlink" title="9、什么是分布式事务"></a>9、什么是分布式事务</h3><p>分布式事务是指在分布式系统中涉及多个独立的数据库或服务的事务操作，它需要确保这些操作要么全部成功执行，要么全部回滚，以保持数据的一致性和可靠性。分布式事务的目标是在不同的系统之间维护数据的一致性，即使在出现故障或部分操作失败的情况下也能够保持数据的正确性。</p>
<p>在传统的单一数据库事务中，事务是由数据库管理系统负责管理和保障的，但在分布式环境下，涉及到多个独立的数据库或服务，各自拥有独立的事务管理机制，因此需要特殊的方法来确保分布式事务的一致性。</p>
<p>分布式事务面临的挑战和问题包括：</p>
<p>原子性（Atomicity）： 分布式事务需要确保涉及的所有操作要么都成功执行，要么都回滚，不能出现部分操作成功而部分操作失败的情况。</p>
<p>一致性（Consistency）： 分布式事务需要保证各个参与方的数据保持一致性，即在事务开始和结束时，系统的数据状态应该满足特定的约束。</p>
<p>隔离性（Isolation）： 分布式事务的操作应该与其他事务隔离，避免不同事务之间的干扰和冲突。</p>
<p>持久性（Durability）： 分布式事务需要确保在事务提交后，其结果被可靠地持久化，以防止数据丢失。</p>
<p>为了实现分布式事务，有一些常见的方法和技术，包括两阶段提交（Two-Phase Commit，2PC）、三阶段提交（Three-Phase Commit，3PC）、补偿事务（Compensating Transaction）等。这些方法在不同的场景下有不同的适用性和权衡，开发人员需要根据系统的需求和复杂性选择适合的方法来处理分布式事务。同时，分布式事务的实现也需要考虑到性能、可靠性和复杂性等方面的因素。</p>
<h3 id="10、分布式事务解决方案"><a href="#10、分布式事务解决方案" class="headerlink" title="10、分布式事务解决方案"></a>10、分布式事务解决方案</h3><p>XA规范：分布式事务规范，定义了分布式事务模型<br>四个角色：事务管理器(协调者TM)、资源管理器(参与者RM)，应用程序AP，通信资源管理器CRM。<br>全局事务：一个横跨多个数据库的事务，要么全部提交、要么全部回滚JTA事务时java对XA规范的实现，对应JDBC的单库事务</p>
<p>1、<strong>两阶段协议：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%5Cimage%5C%E5%9B%BE%E7%89%87_Q25vZTPeSK.png"></p>
<p><strong>第一阶段</strong>（ prepare ） ：每个参与者执行本地事务但不提交，进入 ready 状态，并通知协调者已经准备就绪。</p>
<p><strong>第二阶段</strong>（ commit ） 当协调者确认每个参与者都 ready 后，通知参与者进行 commit 操作；如果有参与者 fail ，则发送 rollback 命令，各参与者做回滚。</p>
<p>问题：<br><strong>单点故障：</strong> 一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）<strong>数据不一致</strong>：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么<br>只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一<br>致。<br><strong>响应时间较长</strong>：参与者和协调者资源都被锁住，提交或者回滚之后才能释放<br><strong>不确定性</strong>：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</p>
<p><strong>2、三阶段协议：</strong> 主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然没有根本解决。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%5Cimage%5C%E5%9B%BE%E7%89%87_1nBse5EWEg.png"></p>
<p>引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制。</p>
<p><strong>第一阶段</strong>：CanCommit阶段，协调者询问事务参与者，是否有能力完成此次事务。</p>
<ul>
<li>如果都返回yes，则进入第二阶段：</li>
<li>有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求。</li>
</ul>
<p><strong>第二阶段</strong>：PreCommit阶段，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</p>
<p><strong>第三阶段</strong>：DoCommit阶段， 在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送”doCommit”请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。</p>
<p><strong>3、TCC（补偿事务）</strong>：Try、Confirm、Cancel<br>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有<br>分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm&#x2F;Cancel操作若执行失败，TM会进行重试。</p>
<p>TCC模型对业务的侵入性较强，改造的难度较大，每个操作都需要有 try 、 confirm 、 cancel 三个接口实现。<br>confirm 和 cancel 接口还必须实现幂等性。</p>
<p><strong>4、消息队列的事务消息：</strong></p>
<ul>
<li>发送prepare消息到消息中间件</li>
<li>发送成功后，执行本地事务<br>如果事务执行成功，则commit，消息中间件将消息下发至消费端（commit前，消息不会被<br>消费）<br>如果事务执行失败，则回滚，消息中间件将这条prepare消息删除<br>消费端接收到消息进行消费，如果消费失败，则不断重试。</li>
</ul>
<p>需要注意的是，每种分布式事务处理方法都有其适用的场景和权衡。选择适当的方法取决于系统的要求、复杂性和可用技术栈。</p>
<h3 id="11、-什么是TCC，和2PC有什么区别？"><a href="#11、-什么是TCC，和2PC有什么区别？" class="headerlink" title="11、 什么是TCC，和2PC有什么区别？"></a>11、 什么是TCC，和2PC有什么区别？</h3><p>TCC（Try-Confirm-Cancel）和2PC（Two-Phase Commit）都是用于处理分布式事务的协议，但它们在处理方式和适用场景上存在一些区别。</p>
<p>TCC (Try-Confirm-Cancel): TCC是一种分布式事务处理方法，它将事务拆分为三个阶段：尝试（Try）、确认（Confirm）和取消（Cancel）。每个阶段都有相应的操作。在尝试阶段，参与者尝试执行事务操作，检查是否满足执行条件。如果所有参与者的尝试都成功，进入确认阶段，参与者确认执行事务。如果任何一个参与者的尝试失败或确认阶段失败，将进入取消阶段，执行事务的补偿操作来恢复系统到一致状态。TCC注重于事务的补偿机制，以确保数据的一致性。</p>
<p>2PC (Two-Phase Commit): 2PC是另一种分布式事务处理协议，它在全局协调器和多个参与者之间进行通信。它有两个阶段：准备（Prepare）和提交（Commit）。在准备阶段，全局协调器将询问所有参与者是否可以执行事务，参与者会回复“可以”或“不可以”。如果所有参与者都回复“可以”，则进入提交阶段，在此阶段全局协调器通知所有参与者提交事务。如果任何一个参与者回复“不可以”，全局协调器会通知所有参与者中止事务。2PC依赖于中心化的协调器，其缺点包括单点故障和阻塞的可能性。</p>
<p>区别:</p>
<p>处理方式： TCC采用尝试-确认-取消的模式，强调补偿机制，而2PC采用两阶段提交的方式，依赖全局协调器来决定提交或中止事务。</p>
<p>灵活性： TCC相对更加灵活，因为它允许开发人员在尝试和确认阶段之间插入补偿逻辑。2PC较为严格，需要参与者在准备阶段做出确定性的回应。</p>
<p>复杂性和性能： TCC通常比2PC更适用于高并发环境，因为它的操作相对较轻，而2PC的中心化协调可能导致性能瓶颈。</p>
<p>可用性： TCC通常在局部事务级别上具有更好的可用性，因为每个参与者可以独立决定是否尝试事务。</p>
<p>在选择TCC还是2PC时，需要根据系统的需求、复杂性和可靠性等因素进行权衡。</p>
<h3 id="12、什么是柔性事务？"><a href="#12、什么是柔性事务？" class="headerlink" title="12、什么是柔性事务？"></a>12、什么是柔性事务？</h3><p>柔性事务（Flexible Transactions）是一种用于分布式系统中的事务处理模式，旨在处理跨多个参与者的分布式事务。在分布式环境中，事务涉及到多个资源或服务，需要保证数据的一致性和可靠性。柔性事务是为了在分布式系统中实现事务处理的灵活性和可扩展性而设计的。</p>
<p>柔性事务模式通常允许开发人员在事务的各个阶段插入逻辑，以便在出现错误或异常情况时进行处理。这种模式的核心思想是，将事务处理拆分为三个阶段：尝试（Try）、确认（Confirm）和取消（Cancel）。</p>
<p>尝试（Try）： 在这个阶段，事务的参与者尝试执行操作，并在操作完成之前不对外部资源产生影响。这是一个”预提交”的阶段，用于检查所有资源是否可用，并为后续的确认阶段做准备。</p>
<p>确认（Confirm）： 如果所有参与者的尝试阶段都成功，那么系统会进入确认阶段。在这个阶段，参与者提交事务，并将操作的结果应用到资源中。如果在这个阶段发生了错误，可以触发补偿逻辑，回滚之前的操作，以确保数据的一致性。</p>
<p>取消（Cancel）： 如果在确认阶段发生错误，系统会进入取消阶段。在这个阶段，参与者会执行回滚操作，将之前尝试阶段所做的更改撤销，以保持数据的一致性。</p>
<p>柔性事务相对于传统的两阶段提交（2PC）来说，具有更高的灵活性和可用性。它允许在不同的阶段插入补偿逻辑，以应对各种异常情况，同时减少了全局协调器的依赖，从而降低了性能瓶颈的风险。这使得柔性事务在高并发和复杂的分布式系统中更具优势。</p>
<h3 id="13、如何基于本地消息表实现分布式事务？"><a href="#13、如何基于本地消息表实现分布式事务？" class="headerlink" title="13、如何基于本地消息表实现分布式事务？"></a>13、如何基于本地消息表实现分布式事务？</h3><p>当基于本地消息表实现分布式事务时，通常会采用一种称为“基于消息的最终一致性”或“最终一致性补偿”模式。这个模式可以帮助在分布式环境中处理事务性操作，同时保持数据的一致性。</p>
<p>以下是基于本地消息表实现分布式事务的一般步骤：</p>
<p>操作记录与消息发送： 当一个分布式事务发起时，主节点（或服务）将事务操作记录到本地数据库，并将一个消息发送到消息队列中。这个消息包含了执行的操作、事务标识以及其他必要的信息。</p>
<p>消息传递与处理： 其他参与者节点在收到消息后，根据消息中的操作类型执行相应的本地操作。这些本地操作可能会修改各个节点的数据状态，但在这个阶段不会立即确认事务的完成。</p>
<p>确认阶段： 在所有参与者节点执行完本地操作后，各节点会将一个确认消息发送回主节点。主节点根据收到的确认消息来判断是否可以提交事务。如果有任何错误发生，主节点可以触发补偿逻辑。</p>
<p>补偿阶段： 如果在确认阶段发生错误，主节点可以通过发送补偿消息来触发参与者节点执行相反的操作，以撤销之前的更改，从而保持数据的一致性。这就是所谓的“最终一致性补偿”。</p>
<p>完成或取消： 一旦确认阶段中的所有参与者节点都成功确认，事务被视为成功完成。如果在确认阶段有任何错误，主节点会触发取消操作，参与者节点会执行补偿操作，将数据状态还原到事务开始前的状态。</p>
<p>基于本地消息表的分布式事务实现主要依赖于消息队列的可靠性和分布式事务的补偿能力。这种模式可以提高分布式系统的可用性和容错性，但同时也需要在应用程序中实现正确的补偿逻辑来处理可能的异常情况。</p>
<h3 id="14、什么是Seata？他有哪几种模式？"><a href="#14、什么是Seata？他有哪几种模式？" class="headerlink" title="14、什么是Seata？他有哪几种模式？"></a>14、什么是Seata？他有哪几种模式？</h3><p>Seata是由阿里巴巴开源的一款分布式事务解决方案，旨在解决分布式系统中的数据一致性问题。Seata提供了一套事务管理的解决方案，支持对分布式事务进行管理和协调。</p>
<p>Seata有以下三种常见的模式：</p>
<p>1 AT模式（Automatic Transaction）：AT模式是Seata最常用的模式，它基于数据库的本地事务实现分布式事务的一致性。在AT模式下，Seata通过拦截数据访问层的SQL操作，并将这些操作封装在一个全局事务中。Seata通过将事务信息存储在全局事务上下文中，并协调各个分支事务的提交或回滚来实现式事务的一致性。</p>
<p>2 TCC模式（Try-Confirm-Cancel）：TCC模式是一种补偿型的分布式事务模式。在TCC模式下，Seata通过定义三个阶段的操作：Try阶段尝试执行业务操作、Confirm阶段确认执行操作、Cancel阶段撤销执行操作。Seata通过补偿机制来保证分布式事务的一致性，即使在异常情况下也能够进行回滚或补偿。</p>
<p>3 Saga模式：Saga模式是一种长事务的分布式事务模式，通过将业务操作分解为一系列的子事务来实现。每个子事务都有自己的回滚操作，从而实现了分布式事务的逐步提交和回滚。Saga模式通过异步消息和补偿机制来实现事务的提交和回滚。</p>
<p>这三种模式在不同的场景下可以根据实际需求进行选择和组合使用，以满足分布式系统的事务管理需求。</p>
<h3 id="15、如何实现接口的幂等性"><a href="#15、如何实现接口的幂等性" class="headerlink" title="15、如何实现接口的幂等性"></a>15、如何实现接口的幂等性</h3><h4 id="1、token-机制"><a href="#1、token-机制" class="headerlink" title="1、token 机制"></a><strong>1、token 机制</strong></h4><p>1、服务端提供了发送 token 的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，<br>就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。<br>2、然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。<br>3、服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token,继续执行业<br>务。<br>4、如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样<br>就保证了业务代码，不被重复执行。</p>
<p><strong>危险性：</strong><br>1、先删除 token 还是后删除 token；<br>(1) 先删除可能导致，业务确实没有执行，重试还带上之前 token，由于防重设计导致，<br>请求还是不能执行。<br>(2) 后删除可能导致，业务处理成功，但是服务闪断，出现超时，没有删除 token，别<br>人继续重试，导致业务被执行两边<br>(3) 我们最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。<br>2、Token 获取、比较和删除必须是原子性<br>(1) redis.get(token) 、token.equals、redis.del(token)如果这两个操作不是原子，可能导<br>致，高并发下，都 get 到同样的数据，判断都成功，继续业务并发执行<br>(2) 可以在 redis 使用 lua 脚本完成这个操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> end</span><br></pre></td></tr></table></figure>

<h4 id="2、各种锁机制"><a href="#2、各种锁机制" class="headerlink" title="2、各种锁机制"></a><strong>2、各种锁机制</strong></h4><p><strong>1、数据库悲观锁</strong></p>
<p><strong>2、数据库乐观锁</strong><br>这种方法适合在更新的场景中，<br>update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为 1，调用库存服务version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订<br>单服务传如的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为 version 已经变<br>为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。</p>
<p><strong>3、业务层分布式锁</strong><br>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数<br>据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断<br>这个数据是否被处理过。</p>
<h4 id="3、各种唯一约束"><a href="#3、各种唯一约束" class="headerlink" title="3、各种唯一约束"></a>3、各种唯一约束</h4><p><strong>1、数据库唯一约束</strong><br>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。<br>我们在数据库层面防止重复。<br>这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键<br>的要求不是自增的主键，这样就需要业务生成全局唯一的主键。<br>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要<br>不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</p>
<p><strong>2、redis set 防重</strong><br>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入 redis 的 set，<br>每次处理数据，先看这个 MD5 是否已经存在，存在就不处理。</p>
<h4 id="4、表防重"><a href="#4、表防重" class="headerlink" title="4、表防重"></a><strong>4、表防重</strong></h4><p>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且<br>他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避<br>免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个<br>事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</p>
<h3 id="16、微服务架构的服务治理有哪些实现方案？"><a href="#16、微服务架构的服务治理有哪些实现方案？" class="headerlink" title="16、微服务架构的服务治理有哪些实现方案？"></a>16、微服务架构的服务治理有哪些实现方案？</h3><p>微服务架构的服务治理有以下几种实现方案：</p>
<ol>
<li>服务注册与发现：使用服务注册表来管理所有微服务的信息，包括服务名称、地址、版本等。服务提供者将自己的信息注册到注册表中，服务消费者通过注册表来发现可用的服务。常见的服务注册与发现工具有Consul、ZooKeeper和etcd等。</li>
<li>负载均衡：通过在服务提供者与服务消费者之间引入负载均衡器，将请求平均分配到多个服务实例上，以提高系统的可伸缩性和可用性。常见的负载均衡器有Nginx、HAProxy和Envoy等。</li>
<li>健康检查与容错机制：通过定期的健康检查来监测服务的可用性和状态，并根据检查结果进行容错处理，比如自动剔除不可用的服务实例。常见的健康检查工具有Spring Cloud的Spring Boot Admin、Netflix的Hystrix和Istio等。</li>
<li>熔断器与降级：在高并发或异常情况下，通过熔断器来控制请求的流量，避免服务的雪崩效应。同时可以通过降级策略，在服务不可用时返回默认值或者静态数据，保证系统的可用性。常见的熔断器和降级工具有Netflix的Hystrix和Sentinel等。</li>
<li>配置中心：将微服务的配置集中管理，实现配置的动态更新和版本控制。通过配置中心，可以动态修改微服务的配置，而无需重启服务。常见的配置中心有Spring Cloud Config、Apollo和Consul等。</li>
<li>API 网关：通过引入 API 网关来对外暴露微服务的统一接口，实现请求的路由、转发和过滤等功能。API 网关可以对请求进行鉴权和限流，提供统一的访问控制和监控。常见的 API 网关有Spring Cloud Gateway、Netflix的Zuul和Kong等。</li>
</ol>
<p>以上是常见的微服务架构的服务治理实现方案，可以根据实际需求选择适合的方案进行使用。</p>
<h2 id="线程、并发100"><a href="#线程、并发100" class="headerlink" title="线程、并发100%"></a>线程、并发100%</h2><h3 id="1、什么是并发？"><a href="#1、什么是并发？" class="headerlink" title="1、什么是并发？"></a>1、什么是并发？</h3><p>答:是指在一定时间内交替执行多任务的任务。操作时有多个线程CPU运行时间分为几个时间段，然后将时间段分配给每个线程执行。 当线程代码在一段时间内运行时，其他线程处于悬挂状。</p>
<h3 id="2、并发和并行有什么区别？"><a href="#2、并发和并行有什么区别？" class="headerlink" title="2、并发和并行有什么区别？"></a>2、并发和并行有什么区别？</h3><p>答:并发和并行是一个很容易混淆的概念。并发是指多个任务的交替，而平行是指真正意义上的“同时进行”。事实上，如果系统中只有一个CPU，在实际系统环境中不能并行使用多线程，则只能通过切换时间片来交替执行任务。真正的平行只能出现在拥有多个CPU的系统中。</p>
<p>并发： 同时，许多任务正在执行中 (单位时间内不一定同时执行)；</p>
<p>并行： 在单位时间内，同时执行多项任务。</p>
<h3 id="3、为什么要使用并发？"><a href="#3、为什么要使用并发？" class="headerlink" title="3、为什么要使用并发？"></a>3、为什么要使用并发？</h3><p>答:并发编程在一定程度上离不开多核CPU的发展。随着单核CPU的研发，无法遵循“摩尔定律”(摩尔定律是基于硬件开发的观测定律，也是基于“摩尔定律”的“反摩尔定律”，不过“反摩尔定律”是软件领域的定律，有兴趣的可以自己理解)，为了进一步提高计算速度，硬件工程师不再追求单独的计算单元，而是将多个计算单元集成在一起，即形成多核CPU。短短十几年，Intel等家用CPU i7可以达到4个甚至8个核心。短短十几年，Intel等家用CPU i7可以达到4个甚至8个核心。专业服务器通常可以达到几个独立的CPU，每个CPU甚至有8个以上的核心。因此，“摩尔定律”它似乎继续体验CPU的核心扩展。在多核CPU的背景下，并发编程的趋势应运而生。通过并发编程，可以充分发挥多核CPU的计算能力，提高其性能。</p>
<h3 id="4、并发编程有哪些缺点？"><a href="#4、并发编程有哪些缺点？" class="headerlink" title="4、并发编程有哪些缺点？"></a>4、并发编程有哪些缺点？</h3><p>答：（1)上下文切换频繁</p>
<p>时间片是CPU分配给每个线程的时间，因为时间很短，所以CPU不断切换线程，让我们觉得多个线程是同时执行的，时间片通常是几十毫秒。每次切换时，都需要保存当前状态，以恢复以前的状态。这种切换行为非常失去性能。过于频繁的切换不能充分发挥多线程编程的优势。无锁并发编程可用于通常减少上下文切换。 CAS算法，使用最少的线程和使用协程。</p>
<p>（2)线程的安全问题</p>
<p>多线程编程中最难把握的是临界区域的线程安全。如果你不注意，就会有死锁。一旦产生死锁，系统功能将不可用。</p>
<h3 id="5、上下文切换是什么？"><a href="#5、上下文切换是什么？" class="headerlink" title="5、上下文切换是什么？"></a>5、上下文切换是什么？</h3><p>答：多线程编程中一般线程的数量大于 CPU 核心数，而一个 CPU 为了有效地执行这些线程，核心只能在任何时候使用一个线程，CPU 策略是将时间片分配到每个线程并旋转。当一个线程的时间片用完时，它将重新处于就绪状态，供其他线程使用。这个过程属于上下文切换。</p>
<p>上下文切换通常是计算密集型的。换句话说，它需要相当可观的处理器时间。在每秒几十次或数百次的切换中，每次切换都需要纳秒量级时间。因此，上下文切换意味着系统消耗了大量事实上，CPU时间可能是操作系统中时间消耗最大的操作。Linux与其他操作系统相比(包括其他类别)Unix系统有很多优点，其中之一就是上下文切换和模式切换的时间消耗很少。</p>
<h3 id="6、使用多线程可能会带来什么问题？"><a href="#6、使用多线程可能会带来什么问题？" class="headerlink" title="6、使用多线程可能会带来什么问题？"></a>6、使用多线程可能会带来什么问题？</h3><p>答：并发编程的目的是提高程序执行效率和程序运行速度，但并发编程并不总是提高程序运行速度，并发编程可能会遇到内存泄漏、上下文切换、死锁、硬件和软件资源闲置等诸多问题。</p>
<h3 id="7、简要总结线程与进程的关系？"><a href="#7、简要总结线程与进程的关系？" class="headerlink" title="7、简要总结线程与进程的关系？"></a>7、简要总结线程与进程的关系？</h3><p>答:一个进程中可以有多个线程，多个线程共享进程的堆叠和方法区 (JDK1.8 之后的元空间)资源，但每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。综上所述，线程是过程划分为较小的操作单元。线程和进程最大的区别在于，每个进程基本上都是独立的，而每个线程都不一定，因为同一进程中的线程很可能相互影响。线程执行成本小，但不利于资源管理和保护；进程恰恰相反。</p>
<h3 id="8、sleep-、wait-、join-、yield-的区别"><a href="#8、sleep-、wait-、join-、yield-的区别" class="headerlink" title="8、sleep()、wait()、join()、yield()的区别"></a>8、sleep()、wait()、join()、yield()的区别</h3><p><strong>1.锁池</strong><br>所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池进行等待，当前面的线程释放同步锁后锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配。</p>
<p><strong>2.等待池</strong><br>当我们调用wait（）方法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。只有调用了notify（）或notifyAll()后等待池的线程才会开始去竞争锁，notify（）是随机从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程放到锁池当中。</p>
<p>1、sleep 是 Thread 类的静态本地方法，wait 则是 Object 类的本地方法。<br>2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。<br>3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。<br>4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。<br>5、sleep 一般用于当前线程休眠，或者轮循暂停操作，wait 则多用于多线程之间的通信。<br>6、sleep 会让出 CPU 执行时间且强制上下文切换，而 wait 则不一定，wait 后可能还是有机会重新竞争到锁继续执行的。</p>
<p>yield（）执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行。</p>
<p>join（）执行后线程进入阻塞状态，例如在线程B中调用线程A的join（），那线程B会进入到阻塞队列，直到线程A结束或中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;22222222&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">t1.join();</span><br><span class="line"><span class="comment">// 这行代码必须要等t1全部执行完毕，才会执行</span></span><br><span class="line">System.out.println(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9、谈谈对线程安全的理解"><a href="#9、谈谈对线程安全的理解" class="headerlink" title="9、谈谈对线程安全的理解"></a>9、谈谈对线程安全的理解</h3><p>不是线程安全、应该是内存安全，堆是共享内存，可以被所有线程访问。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</span><br></pre></td></tr></table></figure>

<p><strong>堆</strong>是进程和线程共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在Java中，堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚</span><br><span class="line">拟机启动时创建。堆所存在的内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及</span><br><span class="line">数组都在这里分配内存。</span><br></pre></td></tr></table></figure>

<p><strong>栈</strong>是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是线程安全的。操作系统在切换线程的时候会自动切换栈。栈空间不需要在高级语言里面显式的分配和释放。</p>
<p>目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。</p>
<p>在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，<strong>这就是造成问题的潜在原因。</strong></p>
<h3 id="10、Thread和Runnable的区别"><a href="#10、Thread和Runnable的区别" class="headerlink" title="10、Thread和Runnable的区别"></a>10、Thread和Runnable的区别</h3><p>Thread和Runnable的实质是继承关系，没有可比性。无论使用Runnable还是Thread，都会newThread，然后执行run方法。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会卖出多一倍的票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">                <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread ticket = &quot;</span> + ticket--);</span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正常卖出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">MyThread2 mt=<span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable ticket = &quot;</span> + ticket--);</span><br><span class="line"><span class="keyword">if</span>(ticket &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因是：MyThread创建了两个实例，自然会卖出两倍，属于用法错误。</p>
<h3 id="11、谈谈对守护线程的理解"><a href="#11、谈谈对守护线程的理解" class="headerlink" title="11、谈谈对守护线程的理解"></a>11、谈谈对守护线程的理解</h3><p><strong>守护线程：</strong> 为所有非守护线程提供服务的线程；任何一个守护线程都是整个JVM中所有非守护线程的保姆；<br>守护线程类似于整个进程的一个默默无闻的小喽喽；它的生死无关重要，它却依赖整个进程而运行；哪天其他线程结束了，没有要执行的了，程序就结束了，理都没理守护线程，就把它中断了；</p>
<p>注意： 由于守护线程的终止是自身无法控制的，因此千万不要把IO、File等重要操作逻辑分配给它；因为它不靠谱；</p>
<p><strong>守护线程的作用是什么？</strong><br>举例， GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p>
<p><strong>应用场景：</strong></p>
<p>（1）来为其它线程提供服务支持的情况；</p>
<p>（2） 或者在任何情况下，程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用；反之，如果一个正在执行某个操作的线程必须要正确地关闭掉否则就会出现不好的后果的话，那么这个线程就不能是守护线程，而是用户线程。通常都是些关键的事务，比方说，数据库录入或者更新，这些操作都是不能中断的。</p>
<p>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。</p>
<p>在Daemon线程中产生的新线程也是Daemon的。<br>守护线程不能用于去访问固有资源，比如读写操作或者计算逻辑。因为它会在任何时候甚至在一个操作的中间发生中断。</p>
<p>Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果要使用后台线程就不能用Java的线程池。</p>
<h3 id="12、ThreadLocal的原理和使用场景"><a href="#12、ThreadLocal的原理和使用场景" class="headerlink" title="12、ThreadLocal的原理和使用场景"></a>12、ThreadLocal的原理和使用场景</h3><p>每一个 Thread 对象均含有一个 ThreadLocalMap 类型的成员变量 threadLocals ，它存储本线程中所有ThreadLocal对象及其对应的值ThreadLocalMap 由一个个 Entry 对象构成Entry 继承自 WeakReference&lt;ThreadLocal&lt;?&gt;&gt; ，一个 Entry 由 ThreadLocal 对象和 Object 构成。由此可见， Entry 的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该<br>key就会被垃圾收集器回收。</p>
<p>当执行set方法时，ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，将值存储进ThreadLocalMap对象中。<br>get方法执行过程类似。ThreadLocal首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key，获取对应的value。</p>
<p>由于每一条线程均含有各自私有的ThreadLocalMap容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</p>
<p>使用场景：<br>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。<br>2、Spring框架进行事务操作，用于存储线程事务信息。<br>3、Spring框架数据库连接，Session会话管理。</p>
<p>4、SpringMVC框架的处理器请求管理。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring框架在事务开始时会给当前线程绑定一个Jdbc Connection,在整个事务过程都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性。Spring框架里面就是用的ThreadLocal来实现这种隔离</span><br></pre></td></tr></table></figure>

<p><strong>例子：example:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzk.test.my;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022--04--20 21:14</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name.set(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hzk.test.my;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> huzhongkui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2022--04--20 21:16</span></span><br><span class="line"><span class="comment"> * 聪明出于勤奋,天才在于积累</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              person.setName(<span class="string">&quot;hzk&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1===&quot;</span>+person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                person.setName(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2===&quot;</span>+person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13、ThreadLocal内存泄露原因，如何避免"><a href="#13、ThreadLocal内存泄露原因，如何避免" class="headerlink" title="13、ThreadLocal内存泄露原因，如何避免"></a>13、ThreadLocal内存泄露原因，如何避免</h3><p><strong>内存泄露</strong>：为程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄露。</p>
<p><strong>强引用</strong>：使用最普遍的引用(new)，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。</p>
<p>如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。</p>
<p><strong>弱引用</strong>：JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用。</p>
<p>ThreadLocal的实现原理，每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本。</p>
<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部强引用时， Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉，但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链（红色链条）</p>
<p>key使用强引用当ThreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收。</p>
<p>key 使用弱引用当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null时，调用完set方法之后，在调用remove方法的时候会清除value值。</p>
<p><strong>因此，内存泄漏的根源是</strong>：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value,就会导致内存泄漏，而不是因为弱引用。</p>
<p>ThreadLocal正确的使用姿势：每次使用完ThreadLocal都调用它的remove()方法清除数据 .</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_dHnqcEF5-_.png"></p>
<h3 id="14、并发的三大特征"><a href="#14、并发的三大特征" class="headerlink" title="14、并发的三大特征"></a>14、并发的三大特征</h3><ul>
<li><strong>原子性：</strong></li>
</ul>
<p>原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要不全部执行完成，要不都不执行。就好比转账，从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。2个操作必须全部完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">()</span> &#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1：将 count 从主存读到工作内存中的副本中<br>2：+1的运算<br>3：将结果写入工作内存<br>4：将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)</p>
<p>那程序中原子性指的是最小的操作单元，比如自增操作，它本身其实并不是原子性操作，分了3步的，包括读取变量的原始值、进行加1操作、写入工作内存。所以在多线程中，有可能一个线程还没自增完，可能才执行到第二部，另一个线程就已经读取了值，导致结果错误。那如果我们能保证自增操作是一个原子性的操作，那么就能保证其他线程读取到的一定是自增后的数据。</p>
<p><strong>关键字：synchronize</strong>d</p>
<ul>
<li><strong>可见性</strong></li>
</ul>
<p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>如果线程2改变了stop的值，线程1一定会停止吗？不一定。当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p><strong>关键字</strong>：<strong>volatile、synchronized、fina</strong>l</p>
<ul>
<li><strong>有序性</strong></li>
</ul>
<p>虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不一定会按照我们写的代码的顺序来执行，有可能将他们重排序。实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">//1</span></span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiply</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">//3</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> a * a;<span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。<br><strong>关键字：volatile、synchronized</strong></p>
<p>volatile本身就包含了禁止指令重排序的语义，而synchronized关键字是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则明确的。</p>
<p><strong>synchronized关键字同时满足以上三种特性，但是volatile关键字不满足原子性。</strong></p>
<p>在某些情况下，volatile的同步机制的性能确实要优于锁(使用synchronized关键字或<br>java.util.concurrent包里面的锁)，因为volatile的总开销要比锁低。</p>
<p>我们判断使用volatile还是加锁的唯一依据就是volatile的语义能否满足使用的场景(原子性)</p>
<h3 id="15、JMM内存模型"><a href="#15、JMM内存模型" class="headerlink" title="15、JMM内存模型"></a>15、JMM内存模型</h3><p>Java内存模型(Java Memory Model简称JMM)是一<strong>种抽象的概念，并不真实存在</strong>，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段）的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为 其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定<strong>所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行</strong>，首先要将变量从主内存拷贝的自己的工作内存中，然后对变量进行操作，操作完成后再将变量写回主内存，<strong>不能直接操作主内存中的变量</strong>， 工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_R66erzjjFI.png"></p>
<p>JMM规定了内存主要划分为<strong>主内存</strong>和<strong>工作内存</strong>两种。</p>
<p><strong>主内存</strong>：主要存储的是<strong>Java实例对象</strong>，所有线程创建的实例对象都存放在主内存中，当然也包括了共享的<strong>类信息、常量、静态变量</strong>。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。</p>
<p><strong>共享变量</strong>：如果一个变量被多个线程使用，那么这个变量会在每个线程的工作内存中保有一个副本，这种变量就是共享变量。</p>
<p><strong>工作内存</strong>：主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每 个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线 程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当 然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。</p>
<p>模型入下图：（基于JMM规范）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_pts96onzfj.png"></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line"></span><br><span class="line">**JMM**不同于**JVM内存区域模型** </span><br><span class="line">JMM与JVM内存区域的划分是**不同的概念层次**，更恰当说JMM描述的是一组规则，</span><br><span class="line">通过 这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开。</span><br><span class="line">JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，</span><br><span class="line">从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JMM对共享内存的操作做出了如下两条规定：</span><br><span class="line">- 线程对共享内存的所有操作都必须在自己的工作内存中进行，不能直接从主内存中写；</span><br><span class="line">- 不同线程无法直接访问其他线程工作内存中的变量，因此共享变量的值传递需要通过主内存完成。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16、JVM存在的必要性"><a href="#16、JVM存在的必要性" class="headerlink" title="16、JVM存在的必要性"></a>16、JVM存在的必要性</h3><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，那么如果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。</p>
<p>假设主内存中存在一个共享变量x（初始值为1），现在有A和B两条线程分别对该变量x&#x3D;1进行操作， A&#x2F;B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定。</p>
<p>即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，这是 因为工作内存是每个线程私有的数据区域，而线程A操作变量x时（<strong>即将x&#x3D;1拷贝到自己的工作内存中</strong>），首先是将变量从主内存拷贝到A线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内存，而对于B线程的也是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后正在将数据写回主内存，而B线程此时正在读取主内存， 这样B线程读取到的值就是x&#x3D;1，但如果A线程已将x&#x3D;2写回主内存后，B线程才开始读取的话，那么此时B线程读取到的就是x&#x3D;2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_5hzzNKrzR3.png"></p>
<h3 id="17、谈谈Volatile关键字的理解"><a href="#17、谈谈Volatile关键字的理解" class="headerlink" title="17、谈谈Volatile关键字的理解"></a>17、谈谈Volatile关键字的理解</h3><h4 id="1、验证可见性"><a href="#1、验证可见性" class="headerlink" title="1、验证可见性"></a>1、验证可见性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//static  volatile Integer int flag = 1;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是子线程A工作内存flag的值：&quot;</span> + flag);</span><br><span class="line">                <span class="keyword">while</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程结束:&quot;</span>+flag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">//让线程完全启动</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是主线程工作内存flag的值：&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、验证有序性"><a href="#2、验证有序性" class="headerlink" title="2、验证有序性"></a>2、验证有序性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileOrderDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a, b;</span><br><span class="line">     <span class="comment">//static int x, y;</span></span><br><span class="line">    <span class="comment">//static volatile int a, b;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            a = b = x = y = <span class="number">0</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                a = <span class="number">1</span>;</span><br><span class="line">                x = b;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">             Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次打印：x=&quot;</span> + x + <span class="string">&quot;,y=&quot;</span> + y);</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、不具备原子性"><a href="#3、不具备原子性" class="headerlink" title="3、不具备原子性"></a>3、不具备原子性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyAtomic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileAtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAtomic</span> <span class="variable">myAtomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAtomic</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">1000</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(myAtomic.incr());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、为什么用线程池？解释下线程池参数？"><a href="#18、为什么用线程池？解释下线程池参数？" class="headerlink" title="18、为什么用线程池？解释下线程池参数？"></a>18、为什么用线程池？解释下线程池参数？</h3><p>1、降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。<br>2、提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程，再执行。<br>3、提高线程的可管理性；线程是稀缺资源，使用线程池可以统一分配调优监控。</p>
<p>**线程池参数：**<strong>corePoolSize</strong> 代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建后并不会<br>消除，而是一种常驻线程。</p>
<p><strong>maxinumPoolSize</strong> 代表的是最大线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数。<br><strong>keepAliveTime 、 unit</strong> 表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会<br>消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除,我们可以通过<br>setKeepAliveTime 来设置空闲时间。</p>
<p>**workQueue **用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来则全部放<br>入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程。</p>
<p><strong>ThreadFactory</strong> 实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建<br>工厂，产生的线程都在同一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择<br>自定义线程工厂，一般我们会根据业务来制定不同的线程工厂。</p>
<p><strong>Handler</strong> 任务拒绝策略，有两种情况，第一种是当我们调用 shutdown 等方法关闭线程池后，这<br>时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经关闭，我们再继续想线程<br>池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理新提<br>交的任务时，这是也就拒绝。</p>
<h3 id="19、JUC线程池的工作原理"><a href="#19、JUC线程池的工作原理" class="headerlink" title="19、JUC线程池的工作原理"></a>19、JUC线程池的工作原理</h3><ol>
<li><p>在创建了线程池后，线程池中的<strong>线程数为零</strong>。</p>
</li>
<li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</p>
<ol>
<li>如果正在运行的线程数量<strong>小于corePoolSize</strong>，那么马上<strong>创建线程</strong>运行这个任务；</li>
<li>如果正在运行的线程数量<strong>大于或等于corePoolSize</strong>，那么<strong>将这个任务放入队列</strong>；</li>
<li>如果这个时候队列满了且正在运行的线程数量还<strong>小于maximumPoolSize</strong>，那么还是要<strong>创建非核心线程</strong>立刻运行这个任务；</li>
<li>如果队列满了且正在运行的线程数量<strong>大于或等于maximumPoolSize</strong>，那么线程池会<strong>启动默认的拒绝策略</strong>来执行。</li>
</ol>
</li>
<li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。</p>
</li>
<li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p>
<p>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。</p>
<p>所以线程池的所有任务完成后，<strong>它最终会收缩到corePoolSize的大小</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_z_iqFdLZ0X.png"></p>
</li>
</ol>
<p><strong>注意：提交一个Runnable时，不管当前线程池中的线程是否空闲，只要数量小于核心线程数就会创建新线程。</strong></p>
<p><strong>注意：ThreadPoolExecutor相当于是非公平的，比如队列满了之后提交的Runnable可能会比正在排队的Runnable先执行。</strong></p>
<h3 id="20、线程池的五种状态是如何流转的"><a href="#20、线程池的五种状态是如何流转的" class="headerlink" title="20、线程池的五种状态是如何流转的"></a>20、线程池的五种状态是如何流转的</h3><p>线程池有五种状态：</p>
<ul>
<li>RUNNING：<strong>会</strong>接收新任务并且<strong>会</strong>处理队列中的任务</li>
<li>SHUTDOWN：<strong>不会</strong>接收新任务并且<strong>会</strong>处理队列中的任务</li>
<li>STOP：<strong>不会</strong>接收新任务并且<strong>不会</strong>处理队列中的任务，并且会中断在处理的任务。</li>
<li>TIDYING：所有任务都终止了，线程池中也没有线程了，这样线程池的状态就会转为TIDYING，一旦达到此状态，就会调用线程池的terminated()</li>
<li>TERMINATED：terminated()执行完之后就会转变为TERMINATED</li>
</ul>
<p>这五种状态并不能任意转换，只会有以下几种转换情况：</p>
<ol>
<li>RUNNING -&gt; SHUTDOWN：手动调用shutdown()触发，或者线程池对象GC时会调用finalize()从而调用shutdown()</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：调用shutdownNow()触发，如果先调shutdown()紧着调shutdownNow()，就会发生SHUTDOWN -&gt; STOP</li>
<li>SHUTDOWN -&gt; TIDYING：队列为空并且线程池中没有线程时自动转换</li>
<li>STOP -&gt; TIDYING：线程池中没有线程时自动转换（队列中可能还有任务）</li>
<li>TIDYING -&gt; TERMINATED：terminated()执行完后就会自动转换</li>
</ol>
<h3 id="21-、线程池为什么一定得是阻塞队列？"><a href="#21-、线程池为什么一定得是阻塞队列？" class="headerlink" title="21 、线程池为什么一定得是阻塞队列？"></a>21 <strong>、线程池为什么一定得是阻塞队列？</strong></h3><p>线程池中的线程在运行过程中，执行完创建线程时绑定的第一个任务后，就会不断的从队列中获取任务并执行，那么如果队列中没有任务了，线程为了不自然消亡，就会阻塞在获取队列任务时，等着队列中有任务过来就会拿到任务从而去执行任务。</p>
<p>通过这种方法能最终确保，线程池中能保留指定个数的核心线程数，关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    timedOut = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">    timedOut = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>某个线程在从队列获取任务时，会判断是否使用超时阻塞获取，我们可以认为非核心线程会poll()，核心线程会take()，非核心线程超过时间还没获取到任务后面就会自然消亡了。</p>
<h3 id="22、线程发生异常，会被移出线程池吗？"><a href="#22、线程发生异常，会被移出线程池吗？" class="headerlink" title="22、线程发生异常，会被移出线程池吗？"></a>22、<strong>线程发生异常，会被移出线程池吗？</strong></h3><p>答案是会的，那有没有可能核心线程数在执行任务时都出错了，导致所有核心线程都被移出了线程池？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_FD74SVkOhX.png"></p>
<p>在源码中，当执行任务时出现异常时，最终会执行processWorkerExit()，执行完这个方法后，当前线程也就自然消亡了，但是！processWorkerExit()方法中会额外再新增一个线程，这样就能维持住固定的核心线程数。</p>
<h3 id="23、线程池的核心线程数、最大线程数该如何设置？"><a href="#23、线程池的核心线程数、最大线程数该如何设置？" class="headerlink" title="23、线程池的核心线程数、最大线程数该如何设置？"></a>23、<strong>线程池的核心线程数、最大线程数该如何设置？</strong></h3><p>我们都知道，线程池中有两个非常重要的参数：</p>
<ol>
<li>corePoolSize：核心线程数，表示线程池中的常驻线程的个数</li>
<li>maximumPoolSize：最大线程数，表示线程池中能开辟的最大线程个数</li>
</ol>
<p>那这两个参数该如何设置呢？</p>
<p>我们对线程池负责执行的任务分为三种情况：</p>
<ol>
<li>CPU密集型任务，比如找出1-1000000中的素数</li>
<li>IO密集型任务，比如文件IO、网络IO</li>
<li>混合型任务</li>
</ol>
<p>CPU密集型任务的特点时，线程在执行任务时会一直利用CPU，所以对于这种情况，就尽可能避免发生线程上下文切换。</p>
<p>比如，现在我的电脑只有一个CPU，如果有两个线程在同时执行找素数的任务，那么这个CPU就需要额外的进行线程上下文切换，从而达到线程并发的效果，此时执行这两个任务的总时间为：</p>
<p>任务执行时间*2+线程上下文切换的时间</p>
<p>而如果只有一个线程，这个线程来执行两个任务，那么时间为：</p>
<p>任务执行时间*2</p>
<p>所以对于CPU密集型任务，线程数最好就等于CPU核心数，可以通过以下API拿到你电脑的核心数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().availableProcessors()</span><br></pre></td></tr></table></figure>

<p>只不过，为了应对线程执行过程发生异常导致线程阻塞的请求，我们可以额外在多设置一个线程，这样当某个线程暂时不需要CPU时，可以有替补线程来继续利用CPU。</p>
<p>所以，对于CPU密集型任务，我们可以设置线程数为：<strong>CPU核心数+1</strong></p>
<p>我们在来看IO型任务，线程在执行IO型任务时，可能大部分时间都阻塞在IO上，假如现在有10个CPU，如果我们只设置了10个线程来执行IO型任务，那么很有可能这10个线程都阻塞在了IO上，这样这10个CPU就都没活干了，所以，对于IO型任务，我们通常会设置线程数为：<strong>2*CPU核心数</strong></p>
<p>不过，就算是设置为了<strong>2*CPU核心数</strong>，也·不一定是最佳的，比如，有10个CPU，线程数为20，那么也有可能这20个线程同时阻塞在了IO上，所以可以再增加线程，从而去压榨CPU的利用率。</p>
<p><strong>通常，如果IO型任务执行的时间越长，那么同时阻塞在IO上的线程就可能越多，我们就可以设置更多的线程，但是，线程肯定不是越多越好</strong>，我们可以通过以下这个公式来进行计算：</p>
<p>线程数 &#x3D; CPU核心数   *（ 1 + 线程等待时间 &#x2F; 线程运行总时间 ）</p>
<ul>
<li>线程等待时间：指的就是线程没有使用CPU的时间，比如阻塞在了IO</li>
<li>线程运行总时间：指的是线程执行完某个任务的总时间</li>
</ul>
<p>我们可以利用jvisualvm抽样来估计这两个时间：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_VUefthp135.png"></p>
<p>图中表示，在刚刚这次抽样过程中，run()总共的执行时间为92567ms，利用了CPU的时间为11027ms，所以没有利用CPU的时间为92567ms-11027ms。</p>
<p>所以我们可以计算出：</p>
<p>线程等待时间 &#x3D; 92567ms-11027ms。</p>
<p>线程运行总时间 &#x3D;92567ms</p>
<p>所以：线程数 &#x3D; 20 *（ 1 + （92567ms-11027ms） &#x2F; 92567ms ）&#x3D; <a target="_blank" rel="noopener" href="http://37.xxx/" title="37.xxx">37.xxx</a></p>
<p>所以根据公式算出来的线程为37、38个线程左右。</p>
<p>按上述公式，如果我们执行的任务IO密集型任务，那么：线程等待时间 &#x3D; 线程运行总时间，所以：</p>
<p>线程数 &#x3D; CPU核心数 *（ 1 + 线程等待时间 &#x2F; 线程运行总时间 ）</p>
<p>= CPU核心数 *（ 1 + 1 ）</p>
<p>= CPU核心数 * 2</p>
<p>以上只是理论，实际工作中情况会更复杂，比如一个应用中，可能有多个线程池，除开线程池中的线程可能还有很多其他线程，或者除开这个应用还是一些其他应用也在运行，所以实际工作中如果要确定线程数，最好是压测。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HzkController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个接口会执行1s，我现在利用apipost来压：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_fMbUlb-G1y.png"></p>
<p>这是在Tomcat默认最大200个线程的请求下的压测结果。</p>
<p>当我们把线程数调整为500：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_RCdvsOQwcf.png"></p>
<p>发现执行效率提高了一倍，假如再增加线程数到1000：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%88%86%E5%B8%83%E5%BC%8F%5C%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91%5Cimage%5C%E5%9B%BE%E7%89%87_6BxT9tlpIO.png"></p>
<p>提升就不那么高了。</p>
<p>总结，我们再工作中，对于：</p>
<ol>
<li>CPU密集型任务：CPU核心数+1，这样既能充分利用CPU，也不至于有太多的上下文切换成本</li>
<li>IO型任务：建议压测，或者先用公式计算出一个理论值（理论值通常都比较小）</li>
<li>对于核心业务（访问频率高），可以把核心线程数设置为我们压测出来的结果，最大线程数可以等于核心线程数，或者大一点点，比如我们压测时可能会发现500个线程最佳，但是600个线程时也还行，此时600就可以为最大线程数</li>
<li>对于非核心业务（访问频率不高），核心线程数可以比较小，避免操作系统去维护不必要的线程，最大线程数可以设置为我们计算或压测出来的结果。</li>
</ol>
<h3 id="24、Tomcat是如何自定义线程池的？"><a href="#24、Tomcat是如何自定义线程池的？" class="headerlink" title="24、Tomcat是如何自定义线程池的？"></a>24、Tomcat是如何自定义线程池的？</h3><p>Tomcat中用的线程池为org.apache.tomcat.util.threads.ThreadPoolExecutor，注意类名和JUC下的一样，但是包名不一样。</p>
<p>Tomcat会创建这个线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    internalExecutor = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>();</span><br><span class="line">    <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">    executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), <span class="number">60</span>, TimeUnit.SECONDS,taskqueue, tf);</span><br><span class="line">    taskqueue.setParent( (ThreadPoolExecutor) executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意传入的队列为TaskQueue，它的入队逻辑为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">    <span class="comment">//we can&#x27;t do any checks</span></span><br><span class="line">    <span class="keyword">if</span> (parent==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we have less threads than maximum force creation of a new thread</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特殊在：</p>
<ul>
<li>入队时，如果线程池的线程个数等于最大线程池数入队。</li>
<li>入队时，如果线程池有闲置线程，任务依旧入队。</li>
<li>入队时，如果线程池的线程个数小于最大线程池数，会返回false，表示入队失败，则去创建线程。</li>
</ul>
<p>这样就控制了，Tomcat的这个线程池，在提交任务时：</p>
<ol>
<li>不会先判断线程个数是否小于核心线程数，而是提前创建10个核心线程。</li>
<li>如果等于最大线程数，会入队，但是线程个数小于最大线程数会入队失败，从而会去创建线程</li>
</ol>
<p>所以随着任务的提交，会优先创建线程，直到线程个数等于最大线程数才会入队。</p>
<p>当然其中有一个比较细的逻辑是：在提交任务时，如果正在处理的任务数小于线程池中的线程个数，那么也会直接入队，而不会去创建线程，也就是上面源码中getSubmittedCount的作用。</p>
<h3 id="25、volatile变量和atomic变量有什么区别？"><a href="#25、volatile变量和atomic变量有什么区别？" class="headerlink" title="25、volatile变量和atomic变量有什么区别？"></a>25、volatile变量和atomic变量有什么区别？</h3><p>答：首先，volatile变量看起来像atomic变量，但功能不同。Volatile变量可以保证先行关系，即后续读操作前会发生写操作， 但它不能保证原子性。例如，如果用volatile修改count变量，那么counttile++ 操作不是原子性的。Atomicinteger类提供的Atomic方法可以使该操作具有原子性，如getandincrement()方法可以增加原子性，并添加当前值，其他数据类型和引用变量也可以进行类似的操作。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="Redis–100"><a href="#Redis–100" class="headerlink" title="Redis–100%"></a>Redis–100%</h2><h3 id="1-、Redis是AP的还是CP的？"><a href="#1-、Redis是AP的还是CP的？" class="headerlink" title="1 、Redis是AP的还是CP的？"></a>1 、Redis是AP的还是CP的？</h3><p>Redis是一个支持多种数据结构的内存数据库，它可以根据配置和使用方式在AP和CP之间做出选择。具体来说，Redis可以在不同的场景下提供不同的一致性级别：</p>
<p>1. 在默认情况下，Redis追求最高的性能和可用性，更倾向于AP模型（即可用性优先）。它使用主从复制和哨兵机制来实现高可用性，但在出现网络分区或节点故障时，可能会导致数据的不一致性。</p>
<p>2. 但是，Redis也提供了一些支持一致性的特性，例如Redis Cluster和Redis Sentinel。通过使用这些特性，Redis可以在需要更高一致性的场景下选择CP模型（即一致性优先）。在Redis Cluster中，数据被分片存储在不同的节点上，并使用Gossip协议来保持数据的一致性。Redis Sentinel则提供了监控和自动故障转移的功能，以保证高可用性和数据的一致性。</p>
<p>因此，根据具体的配置和使用方式，Redis可以在AP和CP之间进行选择。</p>
<h3 id="2-、介绍一下Redis的集群方案？"><a href="#2-、介绍一下Redis的集群方案？" class="headerlink" title="2 、介绍一下Redis的集群方案？"></a>2 、介绍一下Redis的集群方案？</h3><p><strong>1、主从模式：</strong></p>
<p><strong>2、哨兵模式：</strong><br>sentinel，哨兵是 redis 集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<p>哨兵用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举</li>
<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li>
<li>哨兵通常需要 3 个实例，来保证自己的健壮性</li>
<li>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 Redis 集群的高可用性。<br>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li>
</ul>
<p><strong>3、Redis Cluster模式：</strong></p>
<p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。</p>
<p><strong>方案说明</strong>：</p>
<ul>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384 个槽位</li>
<li>每份数据分片会存储在多个互为主从的多节点上</li>
<li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li>
<li>同一分片多个节点间的数据不保持强一致性</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li>
<li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li>
</ul>
<p>在 Redis Cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是加1w 的端口号，比如 16379。<br>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>优点：</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明</li>
<li>具备Sentinel的监控和自动Failover(故障转移)能力</li>
<li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合等</li>
</ul>
<p>Redis Sharding是Redis Cluster出来之前，业界普遍使用的多Redis实例集群方法。其主要思想是采用<br>哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。Java<br>redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的<br>ShardedJedisPool</p>
<p><strong>优点:</strong><br>优势在于非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强<br><strong>缺点:</strong><br>由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战。<br>客户端sharding不支持动态增删节点。服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化</p>
<h3 id="3-、什么是Redis的数据分片？"><a href="#3-、什么是Redis的数据分片？" class="headerlink" title="3 、什么是Redis的数据分片？"></a>3 、什么是Redis的数据分片？</h3><p>Redis的数据分片是一种数据分布在多个节点上的技术，用于实现水平扩展和负载均衡。在Redis中，数据分片是通过哈希槽（Hash Slot）来实现的。</p>
<p>具体而言，数据分片的过程如下：</p>
<p>1. 哈希槽的定义：Redis将整个数据空间划分为固定数量的哈希槽，通常是16384个。每个哈希槽都有一个唯一的标识符，从0到16383。</p>
<p>2. 数据的映射：当客户端发送一个命令请求时，Redis Cluster通过对的哈希值进行计算，将键值对映射到一个特定的哈希槽中。这样，每个键值对就被分配到了一个特定的哈希槽中。</p>
<p>3. 哈希槽的分配：Redis Cluster将所有的哈希槽均匀地分配给各个节点，每个节点负责存储一部分哈希槽对应的数据。这样，数据就被分片存储在了多个节点上。</p>
<p>4. 数据的查找：当客户端需要访问某个键值对时，它首先计算键的哈希值，然后根据哈希值找到对应的哈希槽。客户端根据哈希槽的信息找到负责该哈希槽的节点，并将请求发送给该节点。</p>
<p>5. 数据的迁移：当需要添加或删除节点时，Redis Cluster会进行数据的迁移，以保持各个节点负载均衡。数据迁移的过程中，哈希槽会从一个节点移动到另一个节点，保证数据的分片均匀和一致。通过数据分片，Redis可以在多个节点上并行处理请求，提高了系统的吞吐量和容量。</p>
<p>同时，数据分片还实现了负载均衡和故障隔离，当某个节点故障时，其他节点仍然可以继续提供服务。总的来说，Redis的数据分片通过哈希槽的方式，将数据分布在多个节点上，实现了水平扩展、负载均衡和故障隔离。</p>
<h3 id="4-、Redis为什么这么快？"><a href="#4-、Redis为什么这么快？" class="headerlink" title="4 、Redis为什么这么快？"></a>4 、Redis为什么这么快？</h3><p>Redis之所以被认为是快速的，主要有以下几个原因：</p>
<ol>
<li>内存存储：Redis将数据存储在内存中，而不是磁盘上。相比于磁盘访问内存访问速度更快，可以实现很低的延迟和高吞吐量。</li>
<li>单线程模型：Redis采单线程模型，避免了多线程间的竞争和上下文切换的开销。线程模型简化了并发控制，减少了锁的使用，提高了处理请求的效率。</li>
<li>高效的数据结构：Redis提供了多种高效的数据结构，如字符串、哈希表、跳跃表、集合和有序集合等。这些数据结构在内部实现上都经过了优化，能够快速地进行插入、删除、查找和遍历操作。</li>
<li>异步操作：Redis支持异步操作，可以在后台执行一些耗时的操作，如持久化、复制和集群的同步等。这样可以减少客户端的等待时间，提高系统的响应速度。</li>
<li><strong>高效的网络通信</strong>（<strong>核心</strong>）：Redis自定义的RESP协议进行网络通信，协议本身简单而高效。Redis的网络通信采用非阻塞I&#x2F;O多路复用机制和事件驱动的方式，可以处理大量的并发连接，提高了系统的并发性能。</li>
<li>优化的算法和数据结构：Redis在内部实现中使用了许多优化的算法和数据结构。例如，使用跳跃表（Skip List）来实现有序集合，使用压缩列表（ziplist）来存储小规模的列表和哈希表等。这些优化可以减少内存占用和提高数据操作的效率。</li>
</ol>
<p>总的来说，Redis之所以快速，是因为它使用内存存储、采用单线程模型、提供高效的数据结构、支持异步操作、优化网络通信和使用优化的算法和数据结构等。这些特性使得能够在处理大量请求时保持低延迟和高吞吐量。</p>
<h3 id="5、-Redis-的事务机制是怎样的？"><a href="#5、-Redis-的事务机制是怎样的？" class="headerlink" title="5、 Redis 的事务机制是怎样的？"></a>5、 Redis 的事务机制是怎样的？</h3><p><strong>1、事务开始</strong><br>MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的 flags 属性中打开<br>REDIS_MULTI 标识来完成的。</p>
<p><strong>2、命令入队</strong><br>当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI、EXEC、WATCH、DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</p>
<ul>
<li>如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器<br>立即执行这个命令。</li>
<li>如果客户端发送的是四个命令以外的其他命令，那么服务器并不立即执行这个命令。<br>首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（RedisClient）的 flags 属性关闭 REDIS_MULTI 标识，并且返回错误信息给客户端。</li>
</ul>
<p>如果正确，将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复</p>
<p><strong>3、事务执行</strong></p>
<p>客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。</p>
<ul>
<li>如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者<br>REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。</li>
<li>否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；</li>
</ul>
<p>Redis 不支持事务回滚机制，但是它会检查每一个事务中的命令是否错误。<br>Redis 事务不支持检查那些程序员自己逻辑错误。例如对 String 类型的数据库键执行对HashMap 类型的操作！</p>
<p><strong>WATCH</strong> 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p>
<p><strong>MULTI</strong>命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p>
<p><strong>EXEC：</strong> 执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排<br>列。当操作被打断时，返回空值 nil 。<br>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退<br>出。</p>
<p><strong>UNWATCH</strong>命令可以取消watch对所有key的监控</p>
<h3 id="6-、Redis的持久化机制是怎样的？"><a href="#6-、Redis的持久化机制是怎样的？" class="headerlink" title="6 、Redis的持久化机制是怎样的？"></a>6 、Redis的持久化机制是怎样的？</h3><p>Redis提供了两种方式的持久化机制，分别是RDB快照和AOF日志。</p>
<p><strong>RDB：Redis DataBase</strong><br>在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><strong>优点：</strong><br>1、整个Redis数据库将只包含一个文件 dump.rdb，方便持久化。<br>2、容灾性好，方便备份。<br>3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能<br>4.相对于数据集大时，比 AOF 的启动效率更高。</p>
<p><strong>缺点：</strong><br>1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)<br>2、由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p><strong>AOF：Append Only File</strong><br>以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p>
<p><strong>优点：</strong><br>1、数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。。<br>2、通过 append 模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-<br>check-aof 工具解决数据一致性问题。<br>3、AOF 机制的 rewrite 模式。定期对AOF文件进行重写，以达到压缩的目的</p>
<p><strong>缺点：</strong><br>1、AOF 文件比 RDB 文件大，且恢复速度慢。<br>2、数据集大的时候，比 rdb 启动效率低。<br>3、运行效率没有RDB高。</p>
<p><strong>AOF和RDB对比：</strong></p>
<ul>
<li>AOF文件比RDB更新频率高，优先使用AOF还原数据。</li>
<li>AOF比RDB更安全也更大</li>
<li>RDB性能比AOF</li>
<li>如果两个都配了优先加载AOF</li>
</ul>
<table>
<thead>
<tr>
<th><strong>比较</strong></th>
<th><strong>AOF</strong></th>
<th><strong>RDB</strong></th>
</tr>
</thead>
<tbody><tr>
<td>默认选择</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>数据格式</td>
<td>RESP格式所有写命令</td>
<td>压缩的二进制文件</td>
</tr>
<tr>
<td>数据的安全性</td>
<td>三种写回策略决定</td>
<td>分钟级别数据的丢失</td>
</tr>
<tr>
<td>文件大小</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>恢复速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>重写机制</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>重写阻塞主线</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Redis的性能</td>
<td>三种写回策略决定</td>
<td>分钟级别的快照</td>
</tr>
<tr>
<td>数据恢复的选择</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody></table>
<h3 id="7、-Redis-的过期策略是怎么样的？"><a href="#7、-Redis-的过期策略是怎么样的？" class="headerlink" title="7、 Redis 的过期策略是怎么样的？"></a>7、 Redis 的过期策略是怎么样的？</h3><p>Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。</p>
<p><strong>惰性过期</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p>
<p><strong>定期过期</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</p>
<p>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</p>
<p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p>
<h3 id="8-、Redis的内存淘汰策略是怎么样的？"><a href="#8-、Redis的内存淘汰策略是怎么样的？" class="headerlink" title="8 、Redis的内存淘汰策略是怎么样的？"></a>8 、Redis的内存淘汰策略是怎么样的？</h3><p>Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略。我们可以按照是否会进行数据淘汰把它们分成两类：</p>
<ul>
<li>不进行数据淘汰的策略，只有 noeviction 这一种。</li>
<li><h2 id="会进行淘汰的-7-种其他策略。"><a href="#会进行淘汰的-7-种其他策略。" class="headerlink" title="会进行淘汰的 7 种其他策略。"></a>会进行淘汰的 7 种其他策略。</h2></li>
</ul>
<p>会进行淘汰的 7 种策略，再进一步根据淘汰候选数据集的范围把它们分成两类：</p>
<ul>
<li>在设置了过期时间的数据中进行淘汰，包括 volatile-random、volatile-ttl、volatile-lru、volatile-lfu（Redis 4.0 后新增）四种。</li>
<li>在所有数据范围内进行淘汰，包括 allkeys-lru、allkeys-random、allkeys-lfu（Redis 4.0 后新增）三种。</li>
</ul>
<p>具体解释下各个策略：</p>
<p>默认情况下，Redis 在使用的内存空间超过 maxmemory 值时，并不会淘汰数据，也就是设定的 noeviction 策略。对应到 Redis 缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。Redis 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 Redis 缓存中。</p>
<p>接着 volatile-random、volatile-ttl、volatile-lru 和 volatile-lfu 这四种淘汰策略。它们筛选的候选数据范围，被限制在已经设置了过期时间的键值对上。也正因为此，即使缓存没有写满，这些数据如果过期了，也会被删除。</p>
<p>比如我们使用 EXPIRE 命令对一批键值对设置了过期时间后，无论是这些键值对的过期时间是快到了，还是 Redis 的内存使用量达到了 maxmemory 阈值，Redis 都会进一步按照 volatile-ttl、volatile-random、volatile-lru、volatile-lfu 这四种策略的具体筛选规则进行淘汰</p>
<ul>
<li>volatile-ttl 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li>volatile-lru 会使用 LRU 算法筛选设置了过期时间的键值对。</li>
<li>volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。</li>
</ul>
<p>相对于 volatile-ttl、volatile-random、volatile-lru、volatile-lfu 这四种策略淘汰的是设置了过期时间的数据，allkeys-lru、allkeys-random、allkeys-lfu 这三种淘汰策略的备选淘汰数据范围，就扩大到了所有键值对，无论这些键值对是否设置了过期时间。它们筛选数据进行淘汰的规则是：</p>
<ul>
<li>allkeys-random 策略，从所有键值对中随机选择并删除数据</li>
<li>allkeys-lru 策略，使用 LRU 算法在所有数据中进行筛选。</li>
<li>allkeys-lfu 策略，使用 LFU 算法在所有数据中进行筛选。</li>
</ul>
<p>这也就是说，如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p>
<h3 id="9、-Redis的LRU算法"><a href="#9、-Redis的LRU算法" class="headerlink" title="9、 Redis的LRU算法"></a>9、 <strong>Redis的LRU算法</strong></h3><p>LRU 算法的全称是 Least Recently Used，从名字上就可以看出，这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</p>
<p>那具体是怎么筛选的呢？LRU 会把所有的数据组织成一个链表，链表的头和尾分别表示 MRU 端和 LRU 端，分别代表最近最常使用的数据和最近最不常用的数据。</p>
<p>我们现在有数据 6、3、9、20、5。如果数据 20 和 3 被先后访问，它们都会从现有的链表位置移到 MRU 端，而链表中在它们之前的数据则相应地往后移一位。因为，LRU 算法选择删除数据时，都是从 LRU 端开始，所以把刚刚被访问的数据移到 MRU 端，就可以让它们尽可能地留在缓存中。</p>
<p>如果有一个新数据 15 要被写入缓存，但此时已经没有缓存空间了，也就是链表没有空余位置了，那么，LRU 算法做两件事：</p>
<ul>
<li>数据 15 是刚被访问的，所以它会被放到 MRU 端；</li>
<li>算法把 LRU 端的数据 5 从缓存中删除，相应的链表中就没有数据 5 的记录了。</li>
</ul>
<p>其实，LRU 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问，所以就把它放在 MRU 端；长久不访问的数据，肯定就不会再被访问了，所以就让它逐渐后移到 LRU 端，在缓存满时，就优先删除它。</p>
<p>不过，LRU 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 MRU 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。</p>
<p>所以，在 Redis 中，LRU 算法被做了简化，以减轻数据淘汰对缓存性能的影响，Redis 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 RedisObject 中的 lru 字段记录）。然后，Redis 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。</p>
<p>当需要再次淘汰数据时，Redis 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：能进入候选集合的数据的 lru 字段值必须小于候选集合中最小的 lru 值。当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 maxmemory-samples，Redis 就把候选数据集中 lru 字段值最小的数据淘汰出去。</p>
<p>这样一来，Redis 缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。</p>
<h3 id="10、-Redis的淘汰策略的选择"><a href="#10、-Redis的淘汰策略的选择" class="headerlink" title="10、 Redis的淘汰策略的选择"></a>10、 Redis的淘汰策略的选择</h3><p><strong>建议：</strong></p>
<p>优先使用 allkeys-lru 策略。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</p>
<p>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除。</p>
<h3 id="11、-什么是热Key问题，如何解决热key问题"><a href="#11、-什么是热Key问题，如何解决热key问题" class="headerlink" title="11、 什么是热Key问题，如何解决热key问题"></a>11、 什么是热Key问题，如何解决热key问题</h3><p>热Key问题是指在Redis中，某个或某些特定的键被频繁访问，导致对这些键的操作成为系统的性能瓶颈。热Key问题可能会导致Redis负载过高，响应时间延长，甚至造成系统崩溃。</p>
<p>为了解决热Key问题，可以采取以下一些策略：</p>
<ol>
<li>增加缓存容量：扩大Redis内存容量可以提高缓存命中率，减少对热Key的访问次数，从而缓解热Key问题。可以考虑升级Redis服务器或增加Redis集群节点来增加内存容量。</li>
<li>分片：将热Key均匀地分散到多个Redis实例中，每个实例处理一部分热Key的请求。这样可以降低单个Redis实例的负载压力，提系统整体的吞吐量。</li>
<li>缓存预热：在系统启动或流量低峰期，提前加载热Key的数据到缓存中，使得这些热Key的数据在实际访问时已经存在于缓存中，减少对后端存储的访问。</li>
<li>数据分片：对于热Key所对的数据量较大的情况，可以考虑将数据进行分片存储，将不同片段的数据存放在不同的键上，从而减轻单个键的访问压力。</li>
<li>缓存降级：对于某些热Key，可以考虑将其缓存时间设置较短，或者不缓存，直接访问后端存储。这样可以避免热Key对缓存系统的过度压力，同时确保其他非热Key正常缓存。</li>
<li>使用Redis集群：通过搭建Redis集群，将热Key分散到多个节点上，实现负载均衡和高可用性，提高系统的整体性能和稳定性。</li>
</ol>
<p>综合考虑具体业务场景和系统需求，可以采取不同的策略或组合使用来解决热Key问题。</p>
<h3 id="12、-什么是大Key问题，如何解决？"><a href="#12、-什么是大Key问题，如何解决？" class="headerlink" title="12、 什么是大Key问题，如何解决？"></a>12、 什么是大Key问题，如何解决？</h3><p>大Key问题是指在Redis数据库中存储了过大的数据结构，如大型列表、哈希、集合等，导致内存占用过高，影响Redis性能的情况。这可能会导致以下问题：</p>
<p>内存占用过高： 大Key占用了大量的内存空间，导致其他数据无法被缓存，从而影响Redis的性能和响应速度。</p>
<p>数据加载时间延长： 由于大Key的加载和传输需要较长时间，会导致读取和写入操作的延迟。</p>
<p>持久化问题： 在进行数据持久化（如RDB快照、AOF日志）时，大Key会增加持久化的时间和磁盘空间占用。</p>
<p>解决大Key问题的方法包括：</p>
<p>数据分片： 将大数据拆分成多个小数据，分别存储在不同的Key中。例如，将一个大型哈希表分成多个小型哈希表。</p>
<p>使用分布式存储： 将大数据存储在分布式数据库中，如Redis Cluster或其他分布式存储系统。</p>
<p>合理选择数据结构： 根据实际需求，选择合适的数据结构，避免在单个Key中存储过大的数据。</p>
<p>数据压缩： 对于可以压缩的数据，使用Redis提供的数据压缩功能，减小存储占用。</p>
<p>使用大Key分析工具： Redis提供了一些工具可以用于识别和处理大Key问题，例如Redis内存分析工具和命令。</p>
<p>定期清理： 周期性地检查数据库，发现并处理大Key，例如将大Key转移至其他存储系统。</p>
<p>合理设置过期时间： 对于不再需要的数据，设置适当的过期时间，让Redis可以自动淘汰这些数据。</p>
<p>综合使用这些方法可以有效地解决大Key问题，提高Redis的性能和稳定性。</p>
<h3 id="13、-什么是缓存击穿、缓存穿透、缓存雪崩？"><a href="#13、-什么是缓存击穿、缓存穿透、缓存雪崩？" class="headerlink" title="13、 什么是缓存击穿、缓存穿透、缓存雪崩？"></a>13、 什么是缓存击穿、缓存穿透、缓存雪崩？</h3><p>击穿、缓存穿透和缓存雪崩都是与缓存相关的常见问题现象。</p>
<p><strong>缓存击穿</strong>：是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li>设置热点数据永远不过期。</li>
<li>加互斥锁</li>
</ul>
<p><strong>缓存穿透</strong>：是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案：</strong></p>
<p>1）固定值攻击：缓存一个空对象key-null或者任意一个数据，比如缓存key-“x”</p>
<p>2）随机值攻击：</p>
<p>1、接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；</p>
<p>2、全量缓存：将数据库的数据全部缓存到Redis。</p>
<p>3、缓存id:  将数据库全部数据的id(id要具有唯一性)全部缓存到Redis。</p>
<p>4、布隆过滤器：在项目一启动的时，将数据库中所有的数据全部缓存到布隆过滤器（本地或者分布式版本都可以，根据服务的实例数决定）中。布隆过滤器一个足够大的 bitmap ，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>5、Redis自带的bitmap</p>
<p><strong>缓存雪崩</strong>：是指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存。</li>
<li>搭建高可用Redis集群架构比如哨兵模式</li>
<li>业务服务层面使用降级、熔断、限流手段。（注意这是三套具体的解决方案落地）</li>
</ul>
<h3 id="14、-什么情况下会出现数据库和缓存不一致的问题？"><a href="#14、-什么情况下会出现数据库和缓存不一致的问题？" class="headerlink" title="14、 什么情况下会出现数据库和缓存不一致的问题？"></a>14、 什么情况下会出现数据库和缓存不一致的问题？</h3><p>数据库和缓存不一致的问题可能会出现在以下几种情况下：</p>
<ol>
<li>写操作未更新缓存：当应用程序对数据库进行写操作时，如果没有及时更新相关的缓存数据，就会导致数据库和缓存的数据不一致。这通常发生在缓存和数据库的更新操作没有保持同步的情况下。</li>
<li>缓存过期和数据库更新：当缓存中的数据过期时，如果此时有大量的并发请求查询该数据，而后端数据库正在进行更新操作，就有可能导致缓存中的旧数据被读取，与数据库中的新数据不一致。</li>
<li>多级缓存不一致：在多级缓存架构中，不同层级的缓存可能会出现数据不一致的情况。例如，一级缓存（本地缓存）和二级缓存（分布式缓存）之间的数据同步问题，如果没有及时更新或失效旧的缓存数据，就会导致数据库和缓存数据的不一致。</li>
<li>数据库异常和缓存更新失败：当数据库发生异常或写操作失败时，如果缓存更新操作也失败了，就会导致数据库和缓存的数据不一致。例如，数据库写操作成功了，但是缓存更新失败，导致缓存中的数据是旧的或不一致的。</li>
</ol>
<p><strong>最终一句话：不管哪种方式，在高并发（读读 读写）情况下都可能导致数据库数据和缓存数据不一致问题。</strong></p>
<h3 id="15、-如何解决Redis和数据库的一致性问题？"><a href="#15、-如何解决Redis和数据库的一致性问题？" class="headerlink" title="15、 如何解决Redis和数据库的一致性问题？"></a>15、 如何解决Redis和数据库的一致性问题？</h3><p><strong>解决方案一：双写模式</strong></p>
<ul>
<li>在写数据库的同时 去将数据写入Redis</li>
<li>在无并发的情况下，重试即可。</li>
<li>在并发的情况下可能会数据不一致</li>
<li><strong>慢的线程旧数据居然把新数据覆盖</strong> 这是暂时性的脏数据问题，但是在数据稳定，缓存过期以后，又能得到最新的正确数据。</li>
</ul>
<p><strong>双写模式下的：数据实时更新</strong></p>
<p>当更新数据库的时候，同步更新缓存，并且加锁。</p>
<p>优点：数据一致性强</p>
<p>缺点：有耦合性，并且写和读的操作成为了串行，牺牲了高并发读数据的能力。</p>
<p>适用环境：适用于数据一致性要求高的场景，比如银行业务，证券交易业务。</p>
<p><strong>双写模式下的：数据准实时更新</strong></p>
<p>当更新数据库的同时，异步去更新缓存，比如更新数据库后把一条消息发送到mq中去。</p>
<p>优点：修改数据库数据的业务和修改缓存的数据业务完成了解耦。</p>
<p>缺点：有较短的延迟，并且可能无法保证最终一致性，需要补偿机制。【保证消息百分百投递】</p>
<p>适用环境：对数据实时性要求不严格的场景，比如对一些商品热度值的统计。</p>
<p><strong>解决方案二：失效模式：</strong></p>
<ul>
<li>先删缓存 在写数据库或者在写数据库的同时，去删除缓存，</li>
<li>在并发的情况下也可能出现不一致</li>
</ul>
<p>会有两种情况：</p>
<p>情况一：先删除缓存，再更新数据库。</p>
<p>若异常情况：删除缓存成功了，更新数据库失败了。</p>
<ul>
<li>无并发的情况下，重试修改数据库操作即可解决，保证最终的一致性。</li>
<li>有并发的情况下，给缓存数据设置过期时间，但是在缓存数据失效的这一段时间内，缓存数据仍然和数据库数据是不一致的。因此还可以在写完数据库之后主动在来删除缓存。（双删）。思想：【主动删除缓存+缓存key的被动失效】</li>
</ul>
<p>情况二：先更新数据库值，再删除缓存值。</p>
<p>若异常情况：更新数据库成功了，删除缓存失败了。</p>
<ul>
<li>无并发的情况下，重试修删除缓存操作即可解决，保证最终的一致性。</li>
<li>有并发（读）的情况下，可以不用管，因为等待缓存删除完成，下一次在来读的时候，发现缓存缺失，就会将数据最新的数据读到并同步到缓存中。在等待删除缓存期间也会有一段时间不一致</li>
<li><h2 id="有并发（读、写）的情况下，仍然会出现缓存数据和数据库数据不一致问题，因此还需要通过缓存数据的失效机制-主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）"><a href="#有并发（读、写）的情况下，仍然会出现缓存数据和数据库数据不一致问题，因此还需要通过缓存数据的失效机制-主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）" class="headerlink" title="有并发（读、写）的情况下，仍然会出现缓存数据和数据库数据不一致问题，因此还需要通过缓存数据的失效机制+主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）"></a>有并发（读、写）的情况下，仍然会出现缓存数据和数据库数据不一致问题，因此还需要通过缓存数据的失效机制+主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）</h2></li>
</ul>
<p><strong>解决方案三：缓存失效机制</strong></p>
<p>基于缓存本身的失效机制，具体实现方式为设置缓存失效时间，如果有缓存就从缓存中取数据，如果没缓存就从数据库中取数据，并且重新设置缓存。</p>
<p>优点：实现方式简单，与业务完美解耦，不影响正常业务。</p>
<p>缺点：在缓存失效期间仍然会出现不一致，所以有数据一致性有延迟。</p>
<p>适用环境：能接受一定的数据延迟场景，比如对商品的热度值统计。</p>
<p><strong>解决方案四：延时双删（主要是针对失效模式）</strong></p>
<p>情况一：先删除缓存，再更新数据库。</p>
<p>在线程A更新完数据库值以后，我们可以让它先sleep一小段时间，再进行一次缓存删除操作。</p>
<p>之所以要加上sleep的这段时间，就是为了让线程B能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程A再进行删除。所以，线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。 redis.delKey(X) db.update(X) Thread.sleep(N) redis.delKey(X)</p>
<p>情况二：先更新数据库值，再删除缓存值。</p>
<p>如果线程A删除了数据库中的值，但还没来得及删除缓存值，线程B就开始读取数据了，那么此时，线程B查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程A一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，这种情况对业务的影响较小 db.update(X)</p>
<p>redis.delKey(X)</p>
<p>Thread.sleep(N) redis.delKey(X)</p>
<p><strong>解决方案五：</strong> 引入Canal中间件，类似于MySQL的主从数据同步。</p>
<p>大致的流程如下：</p>
<p>1）读Redis：热数据基本都在Redis</p>
<p>2）写MySQL:增删改都是操作MySQL</p>
<p>3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis</p>
<p>第一次将数据全部写入到redis中做一个全量备份，接这mysql中的insert update delet</p>
<p>作为增量进行实时更新。当读取到binglog后分析，利用消息对列，推送到各个redis实例中去，对redis进行更新。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E7%BC%93%E5%AD%98%5CRedis%5Cimage%5C%E5%9B%BE%E7%89%87_l9V18CxJPo.png"></p>
<p>优点：类似于MySQL的主从模式，因为MySQL的主从也是通过订阅binlog日志来实现的数据一致性。</p>
<p>缺点： 引入中间件，代码开发难度较大，成本较高。</p>
<h3 id="16、-Redis如何实现延迟消息？"><a href="#16、-Redis如何实现延迟消息？" class="headerlink" title="16、 Redis如何实现延迟消息？"></a>16、 Redis如何实现延迟消息？</h3><p>Redis本身并不提供延迟消息的特性，但可以通过一些技术手段实现延迟消息的功能。以下是一种基于Redis的延迟消息实现方法：</p>
<ol>
<li>使用有序集合（Sorted Set）：将延迟消息的到期时间作为有序集合的分数(score)，消息内容作为有序集合的成员(member)。</li>
<li>将延迟消息添加到有序集合中：将延迟消息按照到期时间添加到有序集合中。</li>
<li>定时检查有序集合：通过定时任务或者后台线程，定期检查有序集合中的消息，找到到期的消息。</li>
<li>处理到期的消息：当有序集合中的消息到期时，将其从有序集合中移除，并进行相应的处理，可以将消息发送到消息队列或者进行其他业务操作。</li>
</ol>
<p>通过以上方法，可以实现延迟消息的功能。需要注意的是，在实现过程中需要考虑以下几点：</p>
<ul>
<li>需要保证定时检查的频率，以确保消息能够及时被处理。</li>
<li>可以使用多个有序集合来支持不同延迟时间的消息，将消息按照不同的延迟时间分组存储。</li>
<li>可以使用Redis的发布&#x2F;订阅功能将到期的消息发送到其他服务进行处理。</li>
<li>需要考虑消息的可靠性，如处理失败时的重试机制等。</li>
</ul>
<p>需要根据具体的业务需求和系统架构选择合适的延迟消息方案，以上方法只是其中一种常见的实现方式之一。</p>
<h3 id="17、-除了做缓存，Redis还能用来干什么？"><a href="#17、-除了做缓存，Redis还能用来干什么？" class="headerlink" title="17、 除了做缓存，Redis还能用来干什么？"></a>17、 除了做缓存，Redis还能用来干什么？</h3><p>除了做缓存，Redis还可以用来实现以下几个功能：</p>
<ol>
<li>数据存储：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。可以将Redis作为主要的数据存储，用于存储和查询数据。例如，可以将用户会话信息、配置信息、计数器等数据存储在Redis中。</li>
<li>消息队列：Redis的发布&#x2F;订阅功能可以用作简单的消息队列系统。发布者将消息发布到指定的频道，订阅者可以监听频道并接收消息。这种方式可以用于实现异步任务、事件驱动等场景。</li>
<li>分布式锁：利用Redis的原子性操作和过期时间特性，可以实现分布式锁。通过在Redis中存储一个特定键值对作为锁标识可以实现对共享资源的互斥访问，避免并发问题。</li>
<li>计数器：Redis的自增和自减操作可以用于实现计数器功能。可以用于统计网站的访问量、点赞数量、订单数量等场景。</li>
<li>地理位置应用：Redis理位置数据结构（Geo）可以存储和查询地理位置信息，如地理坐标、半径查询等。可以用于实现附近的人、地理位置搜索等功能。</li>
<li>实时排行榜：利用Redis的有序集合数据结构，可以实现实时的排行榜功能。可以根据特定的规则将成员和分数存储在有序集合中，并根据分数进行排名。</li>
<li>分布式缓存：Redis可以作为分布式缓存系统，通过集群和主从复制等机制，提供高可用性和高性能的缓存服务。</li>
</ol>
<p>总之，Redis不仅仅是一个缓存系统还可以用于实现多种功能和应用场景，包括数据存储、消息队列、分布式锁、计数器、地理位置应用、实时排行榜等。</p>
<h3 id="18、-如何用SETNX实现分布式锁？"><a href="#18、-如何用SETNX实现分布式锁？" class="headerlink" title="18、 如何用SETNX实现分布式锁？"></a>18、 如何用SETNX实现分布式锁？</h3><p>使用Redis的SETNX命令可以实现简单的分布式锁。下面是使用SETNX实现分布式锁的基本步骤：</p>
<ol>
<li><p>获取：当一个进程或线程需要获取锁时，使用SETNX命令尝试设置一个指定的键（作为锁的标识）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock_key 1</span><br></pre></td></tr></table></figure>

<p>如果返回值为1，表示成功获取锁；如果返回值为0，表示锁已被其他进程或线程持有，获取锁失败。</p>
</li>
<li><p>释放锁：当持有锁的进程或线程需要释放锁时，使用DEL命令删除对应的键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过以上步骤，可以实现简单的分布式锁。需要注意的是，分布式锁的实现需要考虑以下几点：</p>
<ul>
<li>锁的粒度：需要明确锁的范围，即确定需要保护的共享资源。可以使用不同的锁标识来实现对不同资源的锁定。</li>
<li>锁的超时：为了避免死锁，可以为获取到的锁设置一个超时时间，避免锁被长时间持有。</li>
<li>锁的可重入性：如果同一个进程或线程多次获取同一个锁，需要确保锁的可重入性，即能够正常释放锁。</li>
<li>锁的可靠性：需要考虑锁的可靠性，如处理锁的异常情况、网络分区等。</li>
<li>锁的误删：B线程加入的锁，可能被A线程删除</li>
<li>锁的原子性：加锁设置过期时间和判断删除锁</li>
</ul>
<p>需要根据具体的业务场景和系统需求，综合考虑以上因素来设计和实现分布式锁。</p>
<h3 id="19、-什么是RedLock，他解决了什么问题？"><a href="#19、-什么是RedLock，他解决了什么问题？" class="headerlink" title="19、 什么是RedLock，他解决了什么问题？"></a>19、 什么是RedLock，他解决了什么问题？</h3><p>RedLock是一个用于解决分布式系统中的锁竞争问题的算法。它是由Redis作者Antirez提出的一种算法，旨在解决Redis的分布式锁在网络分区等异常情况下可能出现的问题。</p>
<p>在分布式系统中使用Redis的SETNX命令来实现锁时，可能会遇到网络分区（例如主节点与从节点之间的网络断开）等故障情况，导致锁的可靠性受到影响。RedLock算法通过引入多个独立的Redis实例，使得锁在多个Redis实例上创建，增加了锁的可靠性。</p>
<p>RedLock算法的基本思想是，使用多个Redis实例（理论上最少需要3个以上）来创建锁。在获取锁时，需要在多个Redis实例上尝试获取锁，并使用大部分Redis实例都获取到锁才算成功。这样即使其中一个实例出现故障或网络分区，仍然可以保证锁的可用性。</p>
<p>RedLock算法的步骤如下：</p>
<ol>
<li>获取当前时间戳timestamp及随机字符串nonce。</li>
<li>在多个Redis实例上依次尝试获取锁，使用SET命令设置锁标识，设置过期时间为锁的超时时间（一般为较短的时间，避免长时间锁定）。</li>
<li>统计成功获取到锁的Redis实例数。</li>
<li>如果成功获取到锁的Redis实例数大于等于大部分实例数（例如大于等于N&#x2F;2+1，N为总实例数），则认为获取锁成功。</li>
<li>如果获取锁失败，则需要在已获取锁的Redis实例上释放锁。</li>
</ol>
<p>RedLock算法并不是用所有场景的通用解决方案，仍然存在一些局限性，例如对于时钟不同步的Redis实例、网络延迟等情况可能会导致锁的可靠性下降。因此，在使用RedLock算法时需要根据具体的业务需求和系统环境进行评估和测试。</p>
<h3 id="20、-如何用Redisson实现分布式锁？"><a href="#20、-如何用Redisson实现分布式锁？" class="headerlink" title="20、 如何用Redisson实现分布式锁？"></a>20、 如何用Redisson实现分布式锁？</h3><p>Redisson是一个基Redis的分布式对象和服务的框架，它提供了一种简单且可靠的方式来实现分布式锁。下面是使用Redisson实现分布式锁的基本步骤：</p>
<ol>
<li>引入Redisson依赖：在项目的构建文件中引入Redisson的依赖，例如Maven的pom.xml文件中添加以下依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建Redisson客户端：实例化Redisson客户端，并配置连接信息，例如Redis的地址和密码等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="string">&quot;your_password&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br></pre></td></tr></table></figure>

<ol>
<li>获取分布式锁：通过Redisson的getLock方法获取一个分布式锁对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>加锁和解锁：使用lock方法加锁，并在锁定的代码块执行完毕后使用unlock方法解锁。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock.locktry &#123;</span><br><span class="line">    <span class="comment">// 执行需要加锁的代码块</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上步骤，就可以使用Redisson实现分布式锁。Redisson还提供了一些其他的功能，如可重入锁、公平锁、读写锁等，可以根据具体的需求选择合适的锁类型。此外，Redisson还支持异步执行和监听锁状态的功能，提供了更多灵活和便捷的方法来操作分布式锁。</p>
<p>需要注意的是，在Redisson实现分布式锁时，仍然需要考虑锁的超时时间、可重入性、互斥性和可靠性等因素，以确保分布式锁的正确和性能优化。</p>
<h1 id="热门领域概念–了解"><a href="#热门领域概念–了解" class="headerlink" title="热门领域概念–了解"></a>热门领域概念–了解</h1><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><h3 id="1、什么是云计算？"><a href="#1、什么是云计算？" class="headerlink" title="1、什么是云计算？"></a>1、什么是云计算？</h3><p>云计算是一种基于互联网的计算模式，它通过将计算资源（例如服务器、存储、数据库、网络、软件等）提供给用户，使用户能够根据需要获得灵活的、可扩展的计算能力，而无需购买、配置和维护物理硬件设备。云计算的主要特点包括：</p>
<ol>
<li><strong>按需服务：</strong> 用户可以根据实际需求随时获得所需的计算资源，无需事先购买或预留。</li>
<li><strong>资源共享：</strong> 多个用户可以共享同一组物理资源，通过虚拟化技术将资源划分为多个虚拟实例，从而提高资源利用率。</li>
<li><strong>可扩展性：</strong> 用户可以根据业务需求快速扩展或缩减计算资源，以适应不断变化的工作负载。</li>
<li><strong>灵活性：</strong> 用户可以选择不同类型的计算资源和服务，根据实际需求进行配置，从而满足不同的应用场景。</li>
<li><strong>付费模式：</strong> 通常采用按使用量付费的方式，用户只需支付实际使用的资源量，避免了高昂的起始投资和维护成本。</li>
<li><strong>自动化管理：</strong> 云计算平台通常提供自动化管理功能，例如自动扩展、备份、监控等，减少了用户的管理工作量。</li>
</ol>
<p>云计算可以分为三种主要模式：基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）。</p>
<ul>
<li><strong>IaaS：</strong> 提供基本的计算、存储和网络基础设施，用户可以在此基础上构建和管理自己的应用程序和环境。</li>
<li><strong>PaaS：</strong> 在IaaS的基础上，还提供了开发和部署应用程序所需的平台和工具，使开发者能够专注于应用逻辑而无需担心底层基础设施。</li>
<li><strong>SaaS：</strong> 提供完整的应用程序作为服务，用户可以直接通过互联网访问和使用，无需安装和维护。</li>
</ul>
<p>总之，云计算通过提供灵活、高效、经济的计算资源，为个人和企业提供了一种更便捷的方式来开发、部署和管理应用程序和服务。</p>
<h3 id="2、什么是公有云、私有云、混合云？"><a href="#2、什么是公有云、私有云、混合云？" class="headerlink" title="2、什么是公有云、私有云、混合云？"></a>2、什么是公有云、私有云、混合云？</h3><p>公有云、私有云和混合云是云计算中常用的部署模式，它们在云资源的管理和访问权限上有所不同：</p>
<ul>
<li><strong>公有云（Public Cloud）：</strong> 公有云是由第三方提供商建立和管理的云基础设施，供多个用户共享。这些提供商会提供各种计算、存储、网络和应用服务，用户可以根据需要按需购买和使用。公有云通常具有高度的可扩展性和灵活性，适用于各种规模的企业和个人用户。</li>
<li><strong>私有云（Private Cloud）：</strong> 私有云是一种基于云计算概念的部署模式，但它是为单个组织或企业独立建立和管理的。私有云通常在组织内部的数据中心中部署，提供更高的安全性和定制性，因为云资源仅供特定组织使用。这种模式适用于有特殊安全和合规需求的企业，或者需要更多控制权的情况。</li>
<li><strong>混合云（Hybrid Cloud）：</strong> 混合云是将公有云和私有云结合起来的部署模式。在混合云中，组织可以将某些工作负载部署在公有云上，同时将敏感数据或合规性要求较高的工作负载部署在私有云中。这种模式可以充分利用公有云的弹性和灵活性，同时满足特定的安全和隐私需求。</li>
</ul>
<p>综上所述，公有云、私有云和混合云是根据云资源的共享性质和管理控制程度来划分的不同云计算部署模式，组织可以根据自身需求选择适合的模式。</p>
<h3 id="3、什么是IaaS、PaaS、SaaS？"><a href="#3、什么是IaaS、PaaS、SaaS？" class="headerlink" title="3、什么是IaaS、PaaS、SaaS？"></a>3、什么是IaaS、PaaS、SaaS？</h3><p>IaaS、PaaS 和 SaaS 是云计算中常见的服务模型，用于描述不同层次的云服务提供方式：</p>
<ul>
<li><strong>IaaS（基础设施即服务，Infrastructure as a Service）：</strong> 在这种模型下，提供的是基础的计算资源，如虚拟机、存储、网络等。用户可以在这些基础设施上构建、管理和运行自己的应用程序，拥有更高的灵活性和控制权。但用户需要自己管理操作系统、中间件、应用等层面的内容。</li>
<li><strong>PaaS（平台即服务，Platform as a Service）：</strong> PaaS 提供了比 IaaS 更高层次的抽象，除了基础设施，还提供了开发、部署和管理应用程序所需的平台和工具。用户可以将注意力集中在应用程序的开发和部署上，而不必过多关注底层的基础设施管理。PaaS 通常包括运行时环境、开发工具、数据库管理等。</li>
<li><strong>SaaS（软件即服务，Software as a Service）：</strong> 在这种模型下，提供的是完整的应用程序作为服务。用户无需关心底层的基础设施、平台，只需通过网络浏览器或其他客户端访问应用程序。常见的 SaaS 包括电子邮件服务、在线办公套件、客户关系管理系统等。</li>
</ul>
<p>这些服务模型从底层基础设施到应用程序层面提供了不同层次的抽象和服务，使用户能够根据需求选择合适的模型来构建、部署和使用应用程序。</p>
<h3 id="4、什么是Serverless？"><a href="#4、什么是Serverless？" class="headerlink" title="4、什么是Serverless？"></a>4、什么是Serverless？</h3><p>Serverless（无服务器）是一种计算模型，旨在让开发者能够更专注于编写代码和功能，而无需显式管理服务器和基础设施。虽然名称中带有“无服务器”，但实际上并不意味着没有服务器存在，而是指开发者无需关心服务器的管理细节。</p>
<p>在传统的应用部署中，开发人员需要管理服务器的配置、扩展性、负载平衡等方面。而在Serverless模型中，这些管理任务由云服务提供商来处理。开发者只需上传包含其代码的函数或服务，然后在需要时触发这些函数。云提供商会根据请求自动分配和释放资源，使开发者只需为实际使用的计算资源付费。</p>
<p>Serverless模型的特点包括：</p>
<ol>
<li><strong>按需付费：</strong> 开发者只需为实际使用的计算资源付费，避免了不必要的资源浪费。</li>
<li><strong>自动扩展：</strong> 云服务提供商会根据请求的负载自动扩展资源，确保应用程序始终具有所需的性能。</li>
<li><strong>事件驱动：</strong> Serverless架构通常是基于事件驱动的，函数会在特定事件发生时被触发执行，如HTTP请求、数据库更改等。</li>
<li><strong>无状态：</strong> 每个函数执行都是独立的，不会保留状态，这使得函数更易于扩展和管理。</li>
</ol>
<p>常见的Serverless服务包括 AWS Lambda、Azure Functions、Google Cloud Functions等。开发者可以使用这些服务来部署单个函数或更复杂的应用程序逻辑，而无需直接管理底层的服务器基础设施。</p>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="场景题—理解"><a href="#场景题—理解" class="headerlink" title="场景题—理解"></a>场景题—理解</h2><h3 id="1、如果你的业务量突然提升100倍QPS你会怎么做？"><a href="#1、如果你的业务量突然提升100倍QPS你会怎么做？" class="headerlink" title="1、如果你的业务量突然提升100倍QPS你会怎么做？"></a>1、如果你的业务量突然提升100倍QPS你会怎么做？</h3><p>面对业务量突然提升100倍的情况，我会采取以下一些措施来应对：</p>
<ol>
<li><strong>性能优化：</strong> 首先，我会仔细分析系统瓶颈，寻找性能瓶颈并进行优化。这可能涉及到代码优化、数据库查询优化、缓存的使用等。确保系统能够高效地处理更多的请求。</li>
<li><strong>扩容：</strong> 如果性能优化无法满足需求，我会考虑增加系统的计算资源，比如扩展服务器集群，使用负载均衡器来分担流量。这可以提高系统的容量和并发处理能力。</li>
<li><strong>缓存策略：</strong> 我会审查系统中的缓存策略，确保数据可以合理地被缓存，从而减轻数据库的压力。使用适当的缓存方案可以提高响应速度。</li>
<li><strong>异步处理：</strong> 对于一些可以延迟处理的任务，我会考虑将其改为异步处理，这可以减少实时请求的压力，提高系统的稳定性。</li>
<li><strong>限流和排队：</strong> 为了防止系统过载，我会引入限流机制，控制每秒处理的请求数量。对于超出处理能力的请求，可以引入排队机制，以避免系统崩溃。</li>
<li><strong>数据库优化：</strong> 数据库通常是系统的瓶颈之一。我会考虑数据库分库分表、索引优化等措施，以提高数据库的承载能力和查询效率。</li>
<li><strong>监控和警报：</strong> 增加监控和警报系统，实时监测系统的性能指标，如CPU、内存、网络等。一旦达到预定阈值，系统可以自动触发警报，让维护团队可以及时采取措施。</li>
<li><strong>紧急计划：</strong> 虽然我们希望一切都能顺利处理，但是突发情况仍然可能发生。我会制定紧急计划，包括回滚方案、灾难恢复策略等，以应对意外情况。</li>
</ol>
<p>总之，面对业务量大幅提升的情况，综合考虑系统的性能、资源、架构等各个方面，采取一系列综合措施，以确保系统能够稳定、高效地应对挑战。</p>
<h3 id="2、让你设计一个订单号生成服务，该怎么做"><a href="#2、让你设计一个订单号生成服务，该怎么做" class="headerlink" title="2、让你设计一个订单号生成服务，该怎么做?"></a>2、让你设计一个订单号生成服务，该怎么做?</h3><p>设计一个订单号生成服务需要考虑多个方面，包括唯一性、可扩展性、性能和易用性。以下是一个基本的设计方案：</p>
<p><strong>1. 唯一性保证：</strong> 订单号必须保证唯一性，可以通过以下几种方式来实现：</p>
<ul>
<li><strong>自增序列：</strong> 使用数据库自增序列来生成订单号。每次插入一条订单记录时，自增序列会自动递增，生成唯一的订单号。</li>
<li><strong>UUID（通用唯一标识符）：</strong> 使用UUID作为订单号，几乎可以保证全局唯一性。但是，UUID相对较长，可能影响存储和索引效率。</li>
</ul>
<p><strong>2. 分布式生成：</strong> 如果系统需要处理大量订单，可以考虑分布式生成订单号，以避免单点性能瓶颈。一种方法是引入分布式ID生成器，如Snowflake算法，保证在多个节点上生成唯一的ID。</p>
<p><strong>3. 编码信息：</strong> 在订单号中可以包含一些有意义的信息，比如订单类型、时间戳等，以便快速识别订单属性。</p>
<p><strong>4. 缓存机制：</strong> 为了提高性能，可以引入缓存机制。将最近生成的订单号缓存起来，避免频繁地访问数据库或分布式ID生成器。</p>
<p><strong>5. 生成算法：</strong> 设计一个高效的生成算法，以避免长时间的等待或计算开销。算法应该在保证唯一性的前提下，尽量减小订单号的长度。</p>
<p><strong>6. 高可用性：</strong> 考虑实现多个订单号生成服务的实例，以提供高可用性。可以使用负载均衡来分配请求，同时保证各实例之间的订单号唯一性。</p>
<p><strong>7. 错误处理：</strong> 考虑异常情况，如数据库连接断开或分布式ID生成器不可用。设计适当的错误处理机制，确保系统的稳定性。</p>
<p><strong>8. 订单号格式：</strong> 定义订单号的格式，使其易于阅读和管理。可以使用前缀、日期、随机数等方式。</p>
<p><strong>9. 日志记录：</strong> 记录每个生成的订单号，包括生成时间、相关信息等，以便后续追踪和排查问题。</p>
<p>最终的设计取决于具体业务需求和技术栈。在设计过程中，需要综合考虑系统的性能、可靠性和易用性，确保订单号生成服务能够满足预期需求。</p>
<h3 id="3、订单到期关闭如何实现"><a href="#3、订单到期关闭如何实现" class="headerlink" title="3、订单到期关闭如何实现"></a>3、订单到期关闭如何实现</h3><p>订单到期关闭是许多业务系统中常见的功能之一，通常涉及到以下步骤和考虑：</p>
<ol>
<li><strong>订单到期时间设定：</strong> 首先，你需要在订单的数据模型中添加一个到期时间字段。这个字段可以是订单创建时间加上一个固定的时限，或者根据业务需求进行动态设置。</li>
<li><strong>定期检查：</strong> 设计一个定期的任务或者后台服务，以便在每个订单的到期时间到来时进行检查。这可以使用定时任务、消息队列等机制来实现。</li>
<li><strong>关闭过期订单：</strong> 当检查到订单的到期时间已经过了当前时间，系统应该将这些订单标记为已过期或者关闭状态。具体的操作可能包括更改订单状态、发送通知给相关人员，或者执行其他业务逻辑。</li>
<li><strong>通知用户：</strong> 对于用户，及时地通知订单的过期状态是很重要的。你可以通过电子邮件、短信、推送通知等方式通知用户，让他们知道订单已经关闭或者过期。</li>
<li><strong>清理和归档：</strong> 过期订单可能占用数据库空间或者内存资源。根据实际需求，你可以考虑定期清理或者归档这些已关闭或者过期的订单，以释放资源。</li>
<li><strong>日志和监控：</strong> 在订单到期关闭的过程中，记录相关的日志信息以便后续排查问题。同时，建立监控机制，及时发现和处理因订单到期引起的异常情况。</li>
<li><strong>恢复和处理：</strong> 有时候订单过期后，用户可能会要求恢复订单或者进行一些特殊处理。你需要设计相应的流程和界面来支持这些需求，以便管理员或客户支持人员可以进行干预。</li>
<li><strong>测试和优化：</strong> 在实际运行中，不断测试和优化订单到期关闭的流程。这可以帮助你发现潜在的问题并进行改进，确保系统在各种情况下都能正确地处理订单的到期关闭。</li>
</ol>
<p>综上所述，订单到期关闭涉及到多个环节，需要在系统设计中充分考虑这些步骤，并根据业务需求和技术架构进行适当的实现。</p>
<h3 id="4、如何设计一个购物车功能？"><a href="#4、如何设计一个购物车功能？" class="headerlink" title="4、如何设计一个购物车功能？"></a>4、如何设计一个购物车功能？</h3><p>设计购物车功能涉及到使用户能够方便地添加、管理和结算所选商品，以及提供良好的用户体验。以下是一个基本的购物车功能设计概述：</p>
<ol>
<li><strong>添加商品：</strong> 在商品页面上，为每个商品提供一个“添加到购物车”按钮。当用户点击该按钮时，将选定的商品添加到购物车。</li>
<li><strong>购物车图标和总览：</strong> 在页面的适当位置显示一个购物车图标，以及显示当前购物车中的商品数量和总金额的总览区域。这样用户可以随时查看购物车的状态。</li>
<li><strong>购物车页面：</strong> 提供一个单独的购物车页面，用户可以通过点击购物车图标或导航链接访问。在购物车页面上，列出已添加的商品、数量、单价和小计。还可以提供移除商品、更改数量以及清空购物车的选项。</li>
<li><strong>商品数量和编辑：</strong> 在购物车中，为每个商品提供一个数量字段，允许用户手动输入或使用增减按钮调整数量。还可以提供一个“编辑”选项，以便用户查看和修改商品的属性（如颜色、尺寸等）。</li>
<li><strong>小计和总计：</strong> 对于每个商品，显示小计金额（数量 × 单价）。在购物车底部显示所有商品的总金额，以及可能的运费和税费等附加费用，计算出订单的总金额。</li>
<li><strong>结算流程：</strong> 提供一个“去结算”或“结算”按钮，引导用户进入结算流程。在结算页面，用户可以选择收货地址、支付方式等，并进行最终确认。</li>
<li><strong>登录和账户关联：</strong> 如果你的网站或应用需要用户登录，可以将购物车与用户账户关联，使用户可以在不同设备间同步购物车内容。</li>
<li><strong>保存购物车状态：</strong> 在用户离开网站或关闭浏览器后，保留购物车中的商品，使用户下次访问时可以继续购物。</li>
<li><strong>库存管理：</strong> 在用户添加商品到购物车时，需要实时检查库存，以避免售罄情况。如果商品在用户结算前被其他用户购买，应及时更新购物车信息。</li>
<li><strong>提供推荐：</strong> 在购物车页面或结算页面，可以显示相关的商品推荐，鼓励用户继续浏览和购买其他商品。</li>
<li><strong>移动端适配：</strong> 确保购物车功能在移动设备上的用户体验良好，可以考虑采用折叠式购物车侧边栏等方式。</li>
<li><strong>安全和隐私：</strong> 确保用户的购物车信息安全，并遵循相关的隐私政策和法规。</li>
</ol>
<p>最终的设计应该根据你的业务需求、用户画像和技术架构进行调整和定制。购物车功能不仅是一个交易过程，还能影响用户对你产品的整体印象，所以提供一个流畅、直观且安全的购物车体验至关重要。</p>
<h3 id="5、每天100w次登录请求，4C8G机器如何做JVM调优？"><a href="#5、每天100w次登录请求，4C8G机器如何做JVM调优？" class="headerlink" title="5、每天100w次登录请求，4C8G机器如何做JVM调优？"></a>5、每天100w次登录请求，4C8G机器如何做JVM调优？</h3><p>对于每天100万次的登录请求，针对4核8GB的机器进行JVM调优可以有以下一些建议：</p>
<ol>
<li><strong>内存分配：</strong> 确保为JVM分配足够的内存，但不要超过机器可用内存的合理范围。可以使用启动参数 <code>-Xms</code> 和 <code>-Xmx</code> 来设置初始堆内存和最大堆内存，例如 <code>-Xms4G -Xmx4G</code>。</li>
<li><strong>垃圾回收策略：</strong> 选择合适的垃圾回收策略以平衡吞吐量和延迟。对于高吞吐量的场景，可以考虑使用 G1 垃圾回收器。启用G1可以通过参数 <code>-XX:+UseG1GC</code>。</li>
<li><strong>并发线程数：</strong> 调整并发线程数以充分利用多核CPU。对于4核的机器，可以考虑设置参数 <code>-XX:ParallelGCThreads=4 -XX:ConcGCThreads=2</code>。</li>
<li><strong>内存回收周期：</strong> 根据应用的特点和负载，调整垃圾回收的时间间隔。可以使用参数 <code>-XX:G1NewSizePercent</code> 和 <code>-XX:G1MaxNewSizePercent</code> 来控制新生代的内存分配百分比。</li>
<li><strong>堆区域划分：</strong> G1垃圾回收器允许将堆内存划分为多个区域，可以通过参数 <code>-XX:G1HeapRegionSize</code> 来调整每个区域的大小，以优化垃圾回收的效率。</li>
<li><strong>元空间设置：</strong> 对于大量的类加载和反射操作，需要适当调整元空间的大小。可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>。</li>
<li><strong>JVM日志和监控：</strong> 开启JVM的日志和监控可以帮助你实时了解JVM的运行状态和性能指标，以便及时调整参数。可以使用参数 <code>-XX:+PrintGC -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code> 来输出垃圾回收日志。</li>
<li><strong>硬件资源利用：</strong> 考虑将登录请求分散到多个实例上，以充分利用硬件资源，降低单个实例的负载。</li>
</ol>
<p>以上建议仅供参考，实际的调优策略需要根据你的应用特点、负载情况和机器配置进行调整。建议在调优过程中逐步引入变更，并使用监控工具来评估性能的变化。</p>
<h3 id="6、不用redis分布式锁，-如何防止用户重复点击？"><a href="#6、不用redis分布式锁，-如何防止用户重复点击？" class="headerlink" title="6、不用redis分布式锁， 如何防止用户重复点击？"></a>6、不用redis分布式锁， 如何防止用户重复点击？</h3><p>不使用 Redis 分布式锁时，你仍然可以采取其他方法来防止用户重复点击。以下是一些可能的替代方案：</p>
<ol>
<li><strong>前端防御：</strong> 在前端实现一些防御措施，例如在用户点击后禁用相应的按钮或链接，直到后台处理完成。这可以通过 JavaScript 来实现。虽然前端控制不是绝对可靠的方法（用户可能通过浏览器开发工具绕过），但可以防止大部分普通用户的重复点击。</li>
<li><strong>请求队列：</strong> 在后端服务中实现一个请求队列，当用户发起请求时，将请求放入队列中进行处理，并且确保同一个用户的相同请求在队列中只有一个。这可以通过用户标识（如用户ID）来实现。在请求处理完成之前，拒绝队列中同一用户的相同请求。</li>
<li><strong>记录请求时间：</strong> 对于每个用户，记录其最近一次请求的时间戳。当用户发起请求时，先检查距离上一次请求的时间间隔是否足够，如果不够则拒绝处理。这可以防止用户在短时间内连续点击。</li>
<li><strong>限制请求频率：</strong> 设置一个全局的请求频率限制，确保同一个用户在一段时间内只能发起有限次数的请求。这可以通过限制 IP 地址、用户标识等来实现。</li>
<li><strong>使用数据库锁：</strong> 尽管不如 Redis 分布式锁高效，但你可以在数据库中使用行级锁或者悲观锁来防止并发修改，从而防止用户重复点击。</li>
</ol>
<p>需要注意的是，这些方法并不能完全消除用户重复点击的可能性，因为客户端和网络环境复杂多变，总会存在一些特殊情况。综合使用多种方法可以提高防御效果。最终的选择应该基于你的应用需求、可用技术以及风险承受能力来确定。</p>
<h3 id="7、让你设计一个秒杀系统，你会考虑哪些问题？"><a href="#7、让你设计一个秒杀系统，你会考虑哪些问题？" class="headerlink" title="7、让你设计一个秒杀系统，你会考虑哪些问题？"></a>7、让你设计一个秒杀系统，你会考虑哪些问题？</h3><p>当设计一个秒杀系统时，需要考虑以下一些关键问题：</p>
<ol>
<li><strong>高并发处理：</strong> 秒杀活动通常会引起巨大的并发请求，系统需要能够处理大量用户同时发起的请求，确保系统稳定运行，不会因为负载过重而崩溃。</li>
<li><strong>数据一致性：</strong> 在秒杀过程中，多个用户可能会竞争有限的资源，如商品库存。需要确保并发操作不会导致数据不一致或超卖现象。</li>
<li><strong>库存管理：</strong> 如何高效地管理商品库存，避免超卖和卖完的情况，同时能够迅速更新库存状态，是一个关键问题。</li>
<li><strong>限流和防刷：</strong> 需要采取措施限制用户频繁的请求，以防止恶意刷单和重复点击。</li>
<li><strong>队列和异步处理：</strong> 使用队列技术可以将请求缓冲起来，然后异步处理，以减轻数据库和服务器压力，提高系统性能。</li>
<li><strong>缓存策略：</strong> 合理使用缓存可以减轻数据库压力，提高数据访问速度，但需要注意缓存的更新策略，以确保数据的实时性和准确性。</li>
<li><strong>分布式架构：</strong> 考虑采用分布式架构，将不同功能模块分散在不同的服务器上，以提高系统的扩展性和可用性。</li>
<li><strong>安全性和防护：</strong> 防止恶意攻击、SQL 注入、XSS 等安全问题，保障用户数据安全和系统稳定。</li>
<li><strong>用户体验：</strong> 设计友好的用户界面和流程，确保用户能够顺利参与秒杀活动，同时避免因为系统问题造成用户体验不佳。</li>
<li><strong>监控和调优：</strong> 设置合适的监控系统，实时监测系统运行状态、性能指标和异常情况，及时进行调优和处理故障。</li>
<li><strong>容灾和备份：</strong> 考虑系统的容灾和备份方案，确保系统在故障时能够快速恢复，并保障数据不会丢失。</li>
<li><strong>业务流程设计：</strong> 定义清晰的秒杀流程，包括商品展示、下单、支付、发货等环节，确保整个流程顺畅运行。</li>
</ol>
<p>这些只是设计秒杀系统时需要考虑的一些关键问题，具体方案需要根据业务需求和技术栈来定制。</p>
<h3 id="8、如果让你实现消息队列，会考虑哪些问题？"><a href="#8、如果让你实现消息队列，会考虑哪些问题？" class="headerlink" title="8、如果让你实现消息队列，会考虑哪些问题？"></a>8、如果让你实现消息队列，会考虑哪些问题？</h3><p>如果要设计和实现一个消息队列，需要考虑以下问题：</p>
<ol>
<li><strong>消息传递方式：</strong> 确定消息是通过什么方式进行传递，常见的方式包括点对点传递和发布-订阅模式。</li>
<li><strong>消息持久化：</strong> 考虑消息是否需要被持久化，以防止消息在系统故障时丢失。可以选择将消息存储在数据库、文件系统或者其他持久化存储中。</li>
<li><strong>消息顺序性：</strong> 某些场景下，消息的顺序性非常重要。设计时需要确保相同的消息顺序被保留，并且不同消息之间的顺序不会混淆。</li>
<li><strong>消息传递的可靠性：</strong> 系统应该能够保证消息的可靠传递，即使在网络不稳定或者其他异常情况下也能够确保消息的送达。</li>
<li><strong>消息重试机制：</strong> 考虑在消息处理失败时的重试机制，以确保消息最终被成功处理，避免因为一次失败就丢失了重要信息。</li>
<li><strong>消息格式与序列化：</strong> 确定消息的格式以及如何进行序列化和反序列化，以便消息能够在不同组件之间进行传递和解析。</li>
<li><strong>消息过滤与路由：</strong> 考虑如何根据消息的内容对消息进行过滤和路由，确保消息被正确地发送到目标处理程序。</li>
<li><strong>性能和吞吐量：</strong> 根据预期的负载和性能需求，选择合适的消息队列实现，并进行性能测试和优化。</li>
<li><strong>扩展性：</strong> 系统应该能够方便地进行横向扩展，以适应日益增长的消息量。</li>
<li><strong>监控和管理：</strong> 设计合适的监控系统，实时监测消息队列的状态和性能指标，同时提供管理工具来管理消息的发送、消费和处理。</li>
<li><strong>安全性：</strong> 考虑消息队列的安全性，防止未经授权的访问和消息篡改。</li>
<li><strong>集成和支持：</strong> 考虑消息队列与其他系统的集成，提供适当的API和文档，以便开发人员能够方便地使用消息队列。</li>
</ol>
<p>这些是设计和实现消息队列时需要考虑的一些关键问题，具体方案会根据实际需求和技术选择进行定制。</p>
<h3 id="9、库存扣减如何避免超卖和少卖？"><a href="#9、库存扣减如何避免超卖和少卖？" class="headerlink" title="9、库存扣减如何避免超卖和少卖？"></a>9、库存扣减如何避免超卖和少卖？</h3><p>针对库存扣减避免超卖和少卖的问题，你可以结合消息队列的设计和实现来解决。以下是一个基本的思路：</p>
<ol>
<li><strong>库存管理系统：</strong> 首先，你需要一个库存管理系统来跟踪每个商品的库存数量。这个系统应该能够及时更新库存数量，记录每次的库存变动。</li>
<li><strong>消息队列应用：</strong> 对于库存扣减操作，你可以将其转化为消息队列的任务。每次有订单需要扣减库存时，将一个消息发送到消息队列。</li>
<li><strong>消费者服务：</strong> 在消息队列中，你可以有一个或多个消费者服务，负责实际的库存扣减操作。这样做的好处是，你可以控制同时进行库存扣减的并发量，从而避免超卖和少卖的问题。</li>
<li><strong>事务处理：</strong> 在库存扣减操作中，确保消息队列中的每个消息都被消费者服务原子性地处理。这可以使用消息队列的事务特性或者结合数据库事务来实现。如果扣减库存和订单的状态更新在不同系统中进行，确保这两个操作要么同时成功，要么同时失败，以保持数据的一致性。</li>
<li><strong>库存预检查：</strong> 在处理消息之前，消费者服务可以进行库存预检查，检查库存是否足够以执行扣减操作。如果库存不足，可以将消息退回到队列或者将其标记为失败。</li>
<li><strong>库存补偿机制：</strong> 如果发生了少卖的情况，你可以设计一个库存补偿机制。例如，定期检查库存和实际销售情况，如果有差异，则自动增加库存以补偿。</li>
<li><strong>监控和报警：</strong> 针对库存扣减过程，设计监控系统来实时监测消息队列状态和性能，同时监控库存的变化。设置报警机制，如果出现异常情况（比如消息积压、库存异常等），及时通知相关人员进行处理。</li>
<li><strong>安全性和集成：</strong> 确保消息队列的安全性，只允许授权的操作访问消息队列。同时，提供集成接口和文档，让开发人员能够方便地使用消息队列进行库存扣减。</li>
</ol>
<p>总之，通过合理的消息队列设计、事务处理、预检查和监控机制，你可以有效地避免库存的超卖和少卖问题，保证系统的稳定和一致性。具体的实现会根据你所选择的消息队列系统和技术栈有所不同。</p>
<h3 id="10、如何用Redis实现朋友圈点赞功能？"><a href="#10、如何用Redis实现朋友圈点赞功能？" class="headerlink" title="10、如何用Redis实现朋友圈点赞功能？"></a>10、如何用Redis实现朋友圈点赞功能？</h3><p>当使用Redis来实现朋友圈点赞功能时，可以按照以下步骤进行设计和实现：</p>
<ol>
<li><strong>存储点赞关系：</strong> 使用Redis的数据结构，例如Set，来存储点赞关系。对于每篇朋友圈动态，可以使用一个Set来存储点赞的用户ID。每个用户ID只能在Set中出现一次，确保每个用户只能点赞一次。</li>
<li><strong>点赞计数：</strong> 可以使用Redis的Sorted Set来存储点赞计数信息。每篇朋友圈动态都对应一个Sorted Set，其中成员是用户ID，分数是点赞的时间戳。这样可以实现点赞时间的排序，并且可以通过Sorted Set的长度来获取点赞的总数。</li>
<li><strong>取消点赞：</strong> 如果用户取消点赞，只需从点赞关系的Set中移除相应的用户ID，同时从Sorted Set中删除对应的成员。</li>
<li><strong>查看点赞状态：</strong> 通过判断用户ID是否在点赞关系的Set中，可以确定用户是否已经点赞。</li>
<li><strong>获取点赞列表：</strong> 如果需要展示最近点赞的用户列表，可以通过获取Sorted Set中的成员（用户ID）和分数（时间戳），然后根据时间戳排序，得到最近点赞的用户列表。</li>
</ol>
<p>以下是一个简化的示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class RedisLikeDemo &#123;</span><br><span class="line"></span><br><span class="line">      private static final String LIKE_PREFIX = &quot;like:&quot;;</span><br><span class="line">      private static final String USER_PREFIX = &quot;user:&quot;;</span><br><span class="line"></span><br><span class="line">       //点赞</span><br><span class="line">      public static void likePost(String postId, String userId, Jedis jedis) &#123;</span><br><span class="line">          </span><br><span class="line">           String key = LIKE_PREFIX + postId;</span><br><span class="line">           Long now = System.currentTimeMillis();</span><br><span class="line">           jedis.zadd(key, now.doubleValue(), userId);// 将用户ID及当前时间戳加入有序集合</span><br><span class="line">            </span><br><span class="line">      &#125;</span><br><span class="line">        //取消点赞</span><br><span class="line">       public static void unlikePost(String postId, String userId, Jedis jedis) &#123;</span><br><span class="line">          String key = LIKE_PREFIX + postId;</span><br><span class="line">          jedis.zrem(key, userId);// 将用户ID从有序集合中移除</span><br><span class="line">       &#125;</span><br><span class="line">       //查看点赞列表</span><br><span class="line">       public List&lt;String&gt; getLikes(String postId, Jedis jedis) &#123;</span><br><span class="line">         </span><br><span class="line">          String key = LIKE_PREFIX + postId;</span><br><span class="line">          ZParams zParams = new ZParams().asc();</span><br><span class="line">          return jedis.zrangeByScoreWithScores(key, &quot;+inf&quot;, &quot;-inf&quot;, 0, -1, zParams)</span><br><span class="line">          .stream()</span><br><span class="line">           .map(tuple -&gt; &#123;</span><br><span class="line">             String userId = tuple.getElement();</span><br><span class="line">             return userId;</span><br><span class="line">          &#125;).collect(Collectors.toList());</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这只是一个基本的示例，实际应用中可能需要考虑更多的异常情况和优化。同时，为了保证数据的一致性和安全性，可能需要进一步的设计和措施。</p>
<h3 id="11、Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？"><a href="#11、Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？" class="headerlink" title="11、Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？"></a>11、Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？</h3><p>要在Redis的ZSET（有序集合）中实现分数相同情况下按时间顺序排序，可以借助一些技巧和额外的字段来实现。以下是一种可能的实现方法：</p>
<p>假设你要存储帖子的排行榜，分数表示点赞数，时间戳表示点赞时间。</p>
<ol>
<li><p>添加帖子点赞时，使用ZADD命令将帖子的ID作为成员，点赞时间戳作为分数添加到ZSET中。</p>
<p><code>ZADD post_likes:&lt;post_id&gt; &lt;timestamp&gt; &lt;user_id&gt;</code></p>
</li>
<li><p>当多个用户点赞同一帖子时，由于分数是点赞时间戳，相同分数的成员会按照字典序排序。</p>
</li>
<li><p>查询排行榜时，使用ZREVRANGE命令按分数（时间戳）倒序获取排行榜列表。</p>
<p><code>ZREVRANGE post_likes:&lt;post_id&gt; 0 -1</code></p>
<p>这将返回按时间倒序的点赞列表，如果多个用户的点赞时间戳相同，它们会按照插入顺序排列，符合你的要求。</p>
</li>
</ol>
<p>需要注意的是，由于Redis的ZSET是基于分数排序的，所以我们将时间戳作为分数存储，这样就能够实现相同分数情况下的时间顺序排序。在实际应用中，你可能还需要考虑数据清理、数据同步等问题，以确保系统的稳定性和一致性。</p>
<h3 id="12、如何实现”查找附近的人”功能？"><a href="#12、如何实现”查找附近的人”功能？" class="headerlink" title="12、如何实现”查找附近的人”功能？"></a>12、如何实现”查找附近的人”功能？</h3><p>实现”查找附近的人”功能通常涉及到地理位置数据和距离计算。在这里，我将为你提供一个基本的思路和步骤，使用Redis的地理位置数据结构（Geospatial Indexes）来实现这个功能。</p>
<p>在Redis中，地理位置数据可以使用有序集合（Sorted Set）的功能来存储和查询。每个成员都有一个经度（longitude）和纬度（latitude）的坐标，可以通过这些坐标来计算距离并进行查询。</p>
<p>以下是一个基本的实现步骤：</p>
<ol>
<li><p><strong>存储用户地理位置信息：</strong> 对于每个用户，使用<code>GEOADD</code>命令将其地理位置信息存储在一个有序集合中，键可以是类似于 “user_locations” 的标识。</p>
<p><code>GEOADD user_locations &lt;longitude&gt; &lt;latitude&gt; &lt;user_id&gt;</code></p>
</li>
<li><p><strong>查询附近的人：</strong> 使用<code>GEORADIUS</code>命令来查询附近的人。你可以指定一个中心点的坐标（比如当前用户的位置），然后指定一个距离范围，命令会返回在这个范围内的用户列表。</p>
<p><code>GEORADIUS user_locations &lt;center_longitude&gt; &lt;center_latitude&gt; &lt;radius&gt; m WITHDIST</code></p>
<p>这将返回一组用户及其与中心点的距离。</p>
</li>
<li><p><strong>筛选结果：</strong> 你可以根据需要对查询结果进行进一步的筛选和处理，比如根据距离排序、限制结果数量等。</p>
</li>
</ol>
<p>请注意，这只是一个简单的实现示例，实际情况可能会更加复杂。在实际应用中，你还需要考虑数据的更新、清理、错误处理以及性能优化等问题。</p>
<p>另外，随着技术的不断发展，可能会有其他更高级的方法和工具来实现类似的功能，例如使用地理信息数据库或专门的地理位置服务。</p>
<h3 id="13、消息队列使用拉模式好还是推模式好？为什么？"><a href="#13、消息队列使用拉模式好还是推模式好？为什么？" class="headerlink" title="13、消息队列使用拉模式好还是推模式好？为什么？"></a>13、消息队列使用拉模式好还是推模式好？为什么？</h3><p>消息队列可以采用拉模式（Pull）或推模式（Push）来处理消息传递。选择哪种模式取决于你的应用场景和需求。</p>
<p><strong>拉模式（Pull）：</strong> 在拉模式中，消费者主动从消息队列中拉取消息。消费者决定何时获取消息以及获取多少消息。这种模式的优势在于消费者可以控制消息的处理速率，以适应自己的处理能力。拉模式适用于以下情况：</p>
<ol>
<li><strong>消费者处理能力不稳定：</strong> 如果消费者的处理速度波动较大，拉模式可以避免消息积压问题。</li>
<li><strong>消费者需要灵活控制：</strong> 如果消费者希望在特定时间获取消息，或者根据自身逻辑选择性地获取特定消息，拉模式更适合。</li>
</ol>
<p><strong>推模式（Push）：</strong> 在推模式中，消息队列将消息主动推送给消费者。消费者只需提供一个回调函数或处理方法，消息队列会在有消息到达时调用该回调函数。推模式的优势在于即时性，适用于以下情况：</p>
<ol>
<li><strong>低延迟要求：</strong> 如果你需要实现低延迟的消息传递，推模式可以更快地将消息发送给消费者。</li>
<li><strong>实时通知：</strong> 如果你需要及时通知消费者进行某些操作，推模式可以满足这种即时性的需求。</li>
</ol>
<p>选择拉模式还是推模式取决于你的应用需求和场景：</p>
<ul>
<li><strong>拉模式适用于：</strong><ul>
<li>需要灵活控制消息获取的场景。</li>
<li>消费者处理能力波动较大的情况。</li>
<li>对消息处理的顺序有严格要求。</li>
</ul>
</li>
<li><strong>推模式适用于：</strong><ul>
<li>需要低延迟和实时性的场景。</li>
<li>需要及时通知和即时反馈的情况。</li>
<li>消费者处理能力稳定，不容易被消息积压。</li>
</ul>
</li>
</ul>
<p>需要注意的是，有些消息队列系统甚至允许在同一个应用中同时使用拉模式和推模式，以满足不同消息处理需求。在实际应用中，根据业务需求来选择适合的模式是非常重要的。</p>
<h3 id="14、如果让你实现一个Dubbo，会考虑用哪些技术解决哪些问题？"><a href="#14、如果让你实现一个Dubbo，会考虑用哪些技术解决哪些问题？" class="headerlink" title="14、如果让你实现一个Dubbo，会考虑用哪些技术解决哪些问题？"></a>14、如果让你实现一个Dubbo，会考虑用哪些技术解决哪些问题？</h3><p>要实现类似于Dubbo这样的分布式服务框架，需要考虑多个方面的技术和问题。以下是一些可能的考虑和解决方案：</p>
<ol>
<li><strong>服务注册与发现：</strong> 使用类似Zookeeper、Etcd或Consul等分布式系统作为服务注册中心，用于服务提供者注册自己的服务，并供消费者发现可用的服务。</li>
<li><strong>远程通信协议：</strong> 选择合适的远程通信协议，如RPC（Remote Procedure Call）协议，可以使用基于TCP的协议，如Netty，或者HTTP&#x2F;2等。</li>
<li><strong>序列化与反序列化：</strong> 选用高效的序列化方式，如Google Protocol Buffers、Apache Avro或者MessagePack，以减少网络传输时的数据体积。</li>
<li><strong>负载均衡：</strong> 实现负载均衡策略，确保服务消费者能够均匀地调用不同的服务提供者，可考虑使用轮询、随机、权重等策略。</li>
<li><strong>容错与熔断：</strong> 实现容错机制，处理服务提供者不可用或者网络故障等情况，可以引入熔断器，如Hystrix，以避免级联故障。</li>
<li><strong>并发与线程池：</strong> 考虑到服务提供者可能会被大量请求同时调用，需要使用线程池等技术来管理并发请求，避免资源耗尽。</li>
<li><strong>超时与重试：</strong> 实现超时机制，避免长时间等待，同时可以引入重试机制，确保在某些网络瞬时问题导致的失败情况下，能够进行自动重试。</li>
<li><strong>跨语言支持：</strong> 如果需要支持不同编程语言间的服务调用，可以使用通用的IDL（接口定义语言）来定义接口，再根据不同语言生成对应的客户端和服务端代码。</li>
<li><strong>监控与治理：</strong> 引入监控和管理工具，如Dubbo-admin、Prometheus等，用于实时监控服务的调用情况、性能指标等，并能进行故障排查和性能优化。</li>
<li><strong>安全与认证：</strong> 考虑数据传输的安全性，可以使用SSL&#x2F;TLS加密通信，另外还可以引入认证和授权机制，确保只有合法的服务消费者能够调用服务。</li>
<li><strong>分布式事务：</strong> 如果需要支持分布式事务，可以考虑使用分布式事务管理器，如Seata或TCC（Try-Confirm-Cancel）等机制。</li>
<li><strong>扩展性：</strong> 构建可扩展的架构，允许根据业务需求动态添加新的服务提供者，同时保持系统的稳定性。</li>
</ol>
<p>最终的选择会依赖于具体的业务需求、技术栈以及团队的经验和技术偏好。以上列举的技术和问题只是其中的一部分，实际实现时还需要根据具体情况进行详细的设计和调优。</p>
<h3 id="15、Kafka，单分区单消费者实例，如何提高吞吐量"><a href="#15、Kafka，单分区单消费者实例，如何提高吞吐量" class="headerlink" title="15、Kafka，单分区单消费者实例，如何提高吞吐量"></a>15、Kafka，单分区单消费者实例，如何提高吞吐量</h3><p>针对 Kafka 单分区单消费者实例如何提高吞吐量的问题，以下是一些可能的优化策略：</p>
<ol>
<li><strong>增加分区数：</strong> Kafka 的吞吐量与分区数相关，增加分区数可以充分利用多个消费者并行处理消息。但需要注意，分区数的调整可能需要对生产者和消费者的代码进行适当的修改。</li>
<li><strong>调整消费者数：</strong> 尽可能多地创建消费者实例，每个实例处理一个分区。这样可以最大化地利用 CPU 和网络资源，提高并行处理能力。</li>
<li><strong>调整消费者的并行处理能力：</strong> 在消费者代码中，确保消息的处理逻辑能够高效运行。可以考虑使用多线程或异步处理，以提高并行处理的能力。</li>
<li><strong>提高消费者端的配置：</strong> 调整消费者的配置参数，例如 <code>fetch.min.bytes</code>、<code>fetch.max.wait.ms</code> 等，以优化拉取消息的性能。</li>
<li><strong>使用批量处理：</strong> 将多条消息批量处理，而不是逐条处理，可以减少网络开销和处理开销，从而提高吞吐量。</li>
<li><strong>调整服务器端的配置：</strong> 调整 Kafka 服务器端的配置参数，例如 <code>num.io.threads</code>、<code>num.network.threads</code> 等，以适应高吞吐量的需求。</li>
<li><strong>考虑使用压缩：</strong> 如果网络带宽有限，可以考虑在生产者端启用消息压缩，以减少传输的数据量。</li>
<li><strong>使用更快的硬件和网络：</strong> 升级硬件和网络设备，以提供更大的计算和通信能力。</li>
<li><strong>监测性能和瓶颈：</strong> 使用监控工具监测 Kafka 集群、消费者和生产者的性能指标，找出可能的瓶颈，并针对性地进行优化。</li>
<li><strong>版本更新：</strong> 确保使用了较新的 Kafka 版本，因为每个版本都可能对性能进行了改进和优化。</li>
</ol>
<p>需要注意的是，上述优化策略的效果取决于具体的使用情境和环境，因此建议在应用这些策略之前，先进行充分的测试和评估，以确保其对吞吐量的提升效果符合预期。同时，持续的性能监测和调优也是保持高吞吐量的关键。</p>
<h3 id="16、一个订单，在11-00超时关闭，但在11-00也支付成功了，怎么办？"><a href="#16、一个订单，在11-00超时关闭，但在11-00也支付成功了，怎么办？" class="headerlink" title="16、一个订单，在11:00超时关闭，但在11:00也支付成功了，怎么办？"></a>16、一个订单，在11:00超时关闭，但在11:00也支付成功了，怎么办？</h3><p>在这种情况下，处理订单超时和支付成功的冲突可能需要以下步骤：</p>
<ol>
<li><strong>确认订单状态：</strong> 首先，需要确保订单状态的准确性。检查订单数据库或系统，确认订单在11:00是否确实被标记为超时关闭，同时也确认支付是否在11:00之前成功完成。</li>
<li><strong>审查日志：</strong> 查看相关系统的日志记录，尤其是订单处理和支付流程的日志。这可以帮助你了解事件发生的确切时间以及可能的问题。</li>
<li><strong>恢复订单状态：</strong> 如果支付在11:00之前成功完成，并且订单被错误地标记为超时关闭，你可能需要通过后台操作或管理员权限来恢复订单状态。将订单状态重新设置为已支付或待处理，以便继续订单的后续流程。</li>
<li><strong>通知用户：</strong> 如果出现了这种情况，及时通知相关用户。向用户解释发生的问题，向其确认订单的实际状态，并道歉为带来的不便。</li>
<li><strong>系统改进：</strong> 这种问题可能暴露出订单处理系统或支付系统的一些潜在问题。你需要分析为什么会出现这种错误，以避免类似问题再次发生。可能需要对系统流程、数据库事务处理和事件触发机制进行审查和改进。</li>
<li><strong>测试与验证：</strong> 在进行任何更改之前，务必进行全面的测试。模拟类似的情况，确保订单状态和支付能够正确处理，以避免再次出现类似的问题。</li>
</ol>
<p>总之，处理订单超时和支付成功冲突需要综合考虑数据的准确性、用户体验和系统流程。及时纠正错误，通知用户，并采取措施防止未来类似问题的发生是关键步骤。</p>
<h3 id="17、一个支付单，多个渠道同时支付成功了怎么办？"><a href="#17、一个支付单，多个渠道同时支付成功了怎么办？" class="headerlink" title="17、一个支付单，多个渠道同时支付成功了怎么办？"></a>17、一个支付单，多个渠道同时支付成功了怎么办？</h3><p>如果出现一个支付单被多个渠道同时支付成功的情况，需要采取以下步骤来解决这个问题：</p>
<ol>
<li><strong>确认支付状态：</strong> 首先，确保支付状态的准确性。检查系统记录，确认是否真的存在多个渠道同时支付成功的情况，或者是系统记录出现了错误。</li>
<li><strong>数据处理：</strong> 如果确认多个渠道确实同时支付成功，需要对支付数据进行处理。通常情况下，系统会自动处理相同订单的多次支付，将多余的支付金额退还给用户。确保这个过程是自动化的，以减少用户的不便。</li>
<li><strong>用户通知：</strong> 如果需要进行退款或其他处理，务必及时通知用户。解释情况，并说明后续的操作步骤，例如退款的时间和方式。</li>
<li><strong>系统改进：</strong> 类似于上面提到的订单超时问题，这种情况可能也暴露出支付系统的潜在问题。分析为什么会出现这种冲突，检查支付系统的流程和事件处理机制，确保类似问题不会再次发生。</li>
<li><strong>测试与验证：</strong> 在进行任何系统改进之前，进行全面的测试和验证。模拟多个渠道同时支付的情况，确保系统能够正确处理，并防止类似问题的再次发生。</li>
<li><strong>监测与预防：</strong> 建立监测机制，定期检查支付系统的表现，以及是否出现类似的问题。预防措施可能包括对并发支付的处理机制进行优化，确保数据的一致性和准确性。</li>
</ol>
<p>总之，解决一个支付单多渠道同时支付成功的问题需要综合考虑数据处理、用户通知、系统改进以及未来预防措施。确保用户的权益不受损害，同时优化系统以避免类似问题的再次发生。</p>
<h3 id="18、如何解决消息重复消费、重复下单等问题？"><a href="#18、如何解决消息重复消费、重复下单等问题？" class="headerlink" title="18、如何解决消息重复消费、重复下单等问题？"></a>18、如何解决消息重复消费、重复下单等问题？</h3><p>要解决消息重复消费、重复下单等问题，通常可以采取以下一些方法：</p>
<ol>
<li><strong>消息去重：</strong> 在消息队列中，你可以实现消息的唯一标识。当消费者从队列中获取消息时，首先检查该消息的唯一标识是否已经被处理过。如果已经处理过，就可以跳过该消息，避免重复消费。</li>
<li><strong>幂等性设计：</strong> 在系统中引入幂等性概念，即使同一个操作被多次执行，结果也保持一致。对于下单操作，可以设计成幂等操作，确保多次重复请求只会产生一次订单。可以通过为每个订单生成一个唯一的订单号，使用订单号来识别订单的唯一性。</li>
<li><strong>事务控制：</strong> 在涉及到多个操作的情况下，使用事务来确保操作的原子性。例如，在创建订单的同时扣减库存，可以将这两个操作放在同一个事务中，如果其中一个操作失败，整个事务会回滚，保证数据的一致性。</li>
<li><strong>幂等性校验：</strong> 在处理请求之前，可以先查询系统的状态，判断该请求是否已经被处理过。如果已经处理过，可以直接返回之前的结果，避免重复操作。</li>
<li><strong>定时任务清理：</strong> 可以设置定时任务来清理过期的数据，如未支付的订单或已经处理过的消息。这样可以确保系统中不会长期存在无效数据。</li>
<li><strong>消息确认机制：</strong> 在消息队列中，可以使用消息确认机制来确保消息被成功消费。只有在消费者确认后，消息才会被标记为已消费，避免消息在处理失败时被重复消费。</li>
<li><strong>日志记录与审计：</strong> 记录每个操作的日志，并建立审计机制。这样可以追踪操作的历史，及时发现异常情况并进行处理。</li>
</ol>
<p>综合使用上述方法，可以有效地解决消息重复消费、重复下单等问题，保证系统的稳定性和数据的一致性。</p>
<h3 id="19、你是如何进行SQL调优的？"><a href="#19、你是如何进行SQL调优的？" class="headerlink" title="19、你是如何进行SQL调优的？"></a>19、你是如何进行SQL调优的？</h3><p>进行SQL调优时，通常可以采取以下步骤来优化查询性能和提高数据库操作效率：</p>
<ol>
<li><strong>分析查询执行计划：</strong> 使用数据库管理工具或命令，获取SQL查询的执行计划。执行计划将显示查询的执行路径，包括表的连接方式、索引的使用情况等。通过分析执行计划，可以确定查询中存在的性能瓶颈。</li>
<li><strong>索引优化：</strong> 确保表中的字段上存在适当的索引，以加快数据检索速度。然而，不宜过度索引，因为索引也会增加数据写入的开销。使用复合索引来覆盖多个查询条件，避免使用过多的单列索引。</li>
<li><strong>合理编写SQL语句：</strong> 编写高效的SQL查询语句是调优的关键。避免使用”SELECT *”，而是只选择需要的列；合理使用JOIN操作，避免多余的连接；使用子查询时，确保子查询返回的数据量有限。</li>
<li><strong>缓存数据：</strong> 对于频繁查询的数据，可以使用缓存技术，如Redis，将结果缓存起来，减少对数据库的频繁访问。</li>
<li><strong>分区表和分表：</strong> 如果数据表过大，可以考虑使用分区表或分表的方式，将数据分散存储，提高查询效率。</li>
<li><strong>定期维护和统计：</strong> 定期进行数据库的维护工作，如重新生成索引、更新统计信息等，以保持数据库的优化状态。</li>
<li><strong>避免全表扫描：</strong> 尽量避免全表扫描操作，可以通过适当的索引、条件过滤等方式来减少数据量，提高查询速度。</li>
<li><strong>优化数据库参数配置：</strong> 根据数据库类型，调整数据库的参数配置，如缓冲池大小、连接数等，以适应实际业务负载。</li>
<li><strong>使用合适的存储引擎：</strong> 根据具体的应用需求，选择合适的数据库存储引擎，如InnoDB、MyISAM等。</li>
<li><strong>使用慢查询分析工具：</strong> 数据库管理工具提供了慢查询分析功能，可以帮助你识别哪些查询语句执行较慢，从而有针对性地进行优化。</li>
</ol>
<p>综合考虑上述方法，根据具体的业务需求和数据库特点，可以进行有效的SQL调优，提升数据库性能和查询效率。</p>
<h3 id="20、不使用synchronized和Lock如何设计一个线程安全的单例？"><a href="#20、不使用synchronized和Lock如何设计一个线程安全的单例？" class="headerlink" title="20、不使用synchronized和Lock如何设计一个线程安全的单例？"></a>20、不使用synchronized和Lock如何设计一个线程安全的单例？</h3><p>不使用 <code>synchronized</code> 和 <code>Lock</code> 来设计一个线程安全的单例可以考虑使用一些其他方式，例如基于静态内部类的单例模式，或者使用双重检查锁定（Double-Checked Locking）等技术来实现。以下是两种常见的线程安全单例实现方法：</p>
<p><strong>1. 静态内部类单例模式：</strong></p>
<p>这种方法利用了类加载的特性，保证了只有在第一次使用单例的时候才会加载内部类，从而实现懒加载，同时又保证线程安全。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private Singleton() &#123; /* 私有构造方法 */ &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. CAS：</strong></p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。实现单例的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">     private static final AtomicReference&lt;Singleton&gt; INSTANCE = new AtomicReference&lt;Singleton&gt;();</span><br><span class="line"> </span><br><span class="line">     private Singleton() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">     public static Singleton getInstance() &#123;</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             Singleton singleton = INSTANCE.get();</span><br><span class="line">             if (null != singleton) &#123;</span><br><span class="line">                 return singleton;</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             singleton = new Singleton();</span><br><span class="line">             if (INSTANCE.compareAndSet(null, singleton)) &#123;</span><br><span class="line">                 return singleton;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。</p>
<p>CAS的一个重要缺点在于如果忙等待一直执行不成功(一直在死循环中),会对CPU造成较大的执行开销。</p>
<p>另外，如果N个线程同时执行到singleton &#x3D; new Singleton();的时候，会有大量对象创建，很可能导致内存溢出。</p>
<h3 id="21、索引失效的问题是如何排查的，有那些种情况？"><a href="#21、索引失效的问题是如何排查的，有那些种情况？" class="headerlink" title="21、索引失效的问题是如何排查的，有那些种情况？"></a>21、索引失效的问题是如何排查的，有那些种情况？</h3><p>索引失效是数据库性能调优中常见的问题之一，通常会导致查询变慢甚至超时。排查索引失效问题需要仔细分析查询语句、表结构、索引设计以及数据库统计信息等因素。以下是一些可能导致索引失效的情况以及排查方法：</p>
<ol>
<li><strong>查询条件与索引不匹配：</strong> 如果查询条件中使用的列与索引的列不匹配，数据库可能无法使用索引来加速查询。检查查询条件是否涵盖了索引的前缀，或者是否需要重新设计索引以更好地匹配查询。</li>
<li><strong>索引选择性低：</strong> 索引的选择性是指索引中不同值的数量与总行数的比率。如果索引选择性很低，意味着索引中的值重复较多，数据库可能会选择全表扫描而不是使用索引。可以通过查看统计信息，比如索引的基数（distinct值的数量）来评估索引的选择性。</li>
<li><strong>数据分布不均匀：</strong> 如果索引列的数据分布不均匀，一些值的数量过多，而另一些值很少，那么在查询时可能会导致部分索引失效。考虑重新设计索引或者优化查询条件以解决这个问题。</li>
<li><strong>数据类型不匹配：</strong> 查询条件中使用的数据类型与索引列的数据类型不匹配时，索引可能无法被使用。确保查询条件的数据类型与索引列的数据类型相同。</li>
<li><strong>隐式类型转换：</strong> 如果在查询条件中进行了隐式类型转换，可能会导致索引失效。数据库无法在索引上执行隐式类型转换，因此尽量避免在查询条件中进行类型转换。</li>
<li><strong>OR 条件：</strong> 当查询条件中使用了多个 OR 条件时，如果这些条件涉及不同的列，可能会导致索引失效。尽量将 OR 条件转换为使用 UNION 或其他方式，以避免索引失效。</li>
<li><strong>函数操作：</strong> 在查询条件中使用函数操作，比如对索引列进行函数操作，可能会导致索引失效。数据库无法使用索引来加速函数操作，因此尽量避免在索引列上进行函数操作。</li>
<li><strong>统计信息过期：</strong> 数据库使用统计信息来选择查询计划，如果统计信息过期或者不准确，可能会导致数据库做出错误的优化决策。定期更新统计信息以确保数据库选择正确的查询计划。</li>
</ol>
<p>排查索引失效问题时，可以通过数据库的执行计划、索引状态、统计信息以及查询语句的优化来识别问题所在，并采取相应的措施进行优化。</p>
<h3 id="22、40亿个QQ号，限制1G内存，如何去重？"><a href="#22、40亿个QQ号，限制1G内存，如何去重？" class="headerlink" title="22、40亿个QQ号，限制1G内存，如何去重？"></a>22、40亿个QQ号，限制1G内存，如何去重？</h3><p>对于在限制为1GB内存的情况下对40亿个QQ号进行去重，可以考虑使用外部排序（External Sorting）的方法来处理。外部排序是一种适用于数据量大于内存可容纳的情况的排序方法，它将数据分成小块，每次处理一块数据，最终将这些有序的小块合并成一个有序的完整数据集。</p>
<p>下面是一个基本的思路，你可以根据实际情况进行调整：</p>
<ol>
<li><strong>分割数据块：</strong> 将40亿个QQ号按照一定的规则划分成多个小块。每个小块的大小要适合你的内存限制，比如可以选择将每个小块限制在100MB左右。</li>
<li><strong>对每个小块进行内部排序：</strong> 将每个小块加载到内存中，使用一种高效的排序算法（比如快速排序、归并排序等）对每个小块进行排序。</li>
<li><strong>逐一合并小块：</strong> 在内存中维护一个小块合并的队列，每次从每个小块中取出一个最小的QQ号，将其写入输出文件，并从对应的小块中取出下一个QQ号填充进队列。重复这个步骤直到所有小块都被处理完毕。</li>
<li><strong>重复合并过程：</strong> 如果输出文件仍然过大，可以将输出文件继续分割成更小的块，然后进行多次合并，直到得到一个完整的有序数据集。</li>
</ol>
<p>需要注意的是，外部排序过程需要额外的磁盘空间来存储临时数据块和合并结果。同时，选择合适的小块大小和合并策略也会影响整体性能。</p>
<p>在实际操作中，你可能需要使用一些编程语言或工具来实现外部排序，比如使用Python的<code>heapq</code>库来维护小块合并的队列，以及逐步处理数据块。由于数据量庞大，整个过程可能会比较耗时，所以耐心和合理的资源规划都是必要的。</p>
<p>另外，如果你的情况允许，也可以考虑使用分布式计算框架，将数据分布到多台机器上进行处理，以加快去重的速度。</p>
<p>23、说一说多级缓存是如何应用的？</p>
<p>多级缓存是计算机体系结构中常用的一种优化技术，旨在加速数据访问并提高系统性能。它利用不同容量和速度的存储设备来缓存数据，以降低CPU访问主存储器的频率，从而减少访问延迟。</p>
<p>多级缓存通常分为三级，分别是L1、L2和L3缓存，它们按照从最近到最远的访问距离进行层次划分。以下是多级缓存的应用方式：</p>
<ol>
<li><strong>L1缓存</strong>：位于CPU内部，速度最快但容量最小。通常用于存储当前正在执行的指令和相关数据。由于其位置接近CPU核心，可以迅速提供数据，适用于对访问延迟敏感的任务。</li>
<li><strong>L2缓存</strong>：位于CPU核心外部，容量较大，速度较快。它承担了L1缓存无法容纳的数据，并提供更大的缓存空间。L2缓存可以通过一些高效的算法来预测数据的使用模式，从而更好地满足CPU的数据需求。</li>
<li><strong>L3缓存</strong>：位于CPU芯片上但多个核心共享，容量更大，速度相对较慢。L3缓存通常用于存储多个核心之间共享的数据，以及更大规模的工作负载。它有助于降低多核处理器之间的数据传输延迟。</li>
</ol>
<p>多级缓存的应用方式包括以下几个方面：</p>
<ul>
<li><strong>缓存命中和缓存失效</strong>：当CPU需要访问数据时，会首先在最小的L1缓存中查找，如果找到则为缓存命中，否则会在更大的L2或L3缓存中查找。如果所有缓存层都没有找到需要的数据，就会发生缓存失效，需要从主存储器中加载数据。</li>
<li><strong>缓存替换算法</strong>：当缓存空间不足时，会采用一些算法来决定替换哪些数据。常见的替换算法包括LRU（最近最少使用）、LFU（最不常用）等，以及一些变种。</li>
<li><strong>数据预取</strong>：缓存控制器可能会根据访问模式预测未来可能需要的数据，并提前将其加载到缓存中，以提高命中率。</li>
</ul>
<p>总之，多级缓存通过提供不同层次的缓存存储，有效地提高了计算机系统的数据访问速度和整体性能。在设计中，需要权衡容量、速度和成本等因素，以达到最佳的性能提升效果。</p>
<h3 id="23、从B-树的角度分析为什么单表2000万要考虑分表？"><a href="#23、从B-树的角度分析为什么单表2000万要考虑分表？" class="headerlink" title="23、从B+树的角度分析为什么单表2000万要考虑分表？"></a>23、从B+树的角度分析为什么单表2000万要考虑分表？</h3><p>从B+树的角度分析为什么单表2000万要考虑分表涉及数据库性能和查询效率的考虑。B+树是一种常用于数据库索引的数据结构，用于加速数据的插入、更新和查询操作。当单表数据量逐渐增大，可能会出现以下几个问题，从而考虑分表：</p>
<ol>
<li><strong>查询性能下降</strong>：随着数据量的增加，B+树的高度可能会增加，导致查询操作的时间复杂度增加。较深的B+树意味着需要更多的磁盘I&#x2F;O操作，从而影响查询的效率。</li>
<li><strong>索引维护成本增加</strong>：当数据量大时，B+树的维护成本也会增加。插入、更新和删除操作可能需要频繁地调整B+树结构，这可能导致性能下降。</li>
<li><strong>内存压力增大</strong>：单表数据量增加会增加B+树节点的数量，从而需要更多的内存来存储索引。如果内存无法容纳足够多的索引节点，就可能导致频繁的磁盘访问，进而影响查询性能。</li>
<li><strong>数据备份和恢复困难</strong>：单表数据量庞大时，数据备份和恢复变得更加复杂和耗时。分表可以使数据管理和维护变得更加灵活，有助于更好地进行备份和恢复操作。</li>
</ol>
<p>因此，当单表数据量达到2000万这个数量级时，可能需要考虑分表来缓解上述问题。通过将数据拆分为多个表，每个表的数据量减少，B+树的高度降低，查询性能和索引维护成本可以得到改善。同时，分表还有助于更好地利用内存、简化数据管理和提高数据备份恢复的效率。然而，分表也需要综合考虑业务需求、查询模式等因素，避免出现过度分表导致的查询性能下降或连接操作复杂的问题。</p>
<p>25、InnoDB为什么不用跳表，Redis为什么不用B+树？</p>
<p>InnoDB 和 Redis 都是流行的数据库或数据存储引擎，它们在设计和实现上有各自的考虑和特点，这也影响了它们在数据结构选择方面的决策。</p>
<p><strong>InnoDB 不使用跳表的原因</strong>： InnoDB 是 MySQL 数据库的默认存储引擎，它采用了 B+ 树作为主要的索引数据结构。B+ 树在数据库领域广泛应用，因为它对范围查询、排序等操作有着良好的支持，适合于数据库的多样化查询需求。相比之下，跳表在某些方面可能表现出色，但在数据库场景下，它的性能和特点可能不如 B+ 树。</p>
<p>跳表适用于有序数据的搜索，它可以在某些情况下实现快速查找，但相对于 B+ 树，跳表的实现和维护可能更为复杂，而且跳表对于范围查询的性能可能不如 B+ 树。此外，B+ 树在磁盘存储和内存管理方面也有优势，这在数据库中尤为重要。</p>
<p><strong>Redis 不使用 B+ 树的原因</strong>： Redis 是一个内存存储数据库，它主要用于缓存和快速数据存取。在这样的场景下，B+ 树不一定是最优选择。B+ 树的设计和优势更多地与磁盘存储相关，而 Redis 的数据通常完全存储在内存中，磁盘访问并不是主要瓶颈。</p>
<p>Redis 使用了一种称为「跳跃表」（Skip List）的数据结构来实现有序集合。跳跃表在内存中的实现相对简单，适用于 Redis 的高速内存存储和快速读写操作。它在某些情况下可以提供良好的性能，尤其是在不需要像 B+ 树那样复杂的平衡和维护操作时。</p>
<p>总之，InnoDB 和 Redis 在选择数据结构上考虑了各自的使用场景、性能需求以及存储特点。虽然跳表在某些情况下可能表现得很好，但在数据库和内存存储引擎的背景下，B+ 树和跳跃表分别被选择以满足不同的性能和设计要求。</p>
<h3 id="24、线上接口如果响应很慢如何去排查定位问题呢？"><a href="#24、线上接口如果响应很慢如何去排查定位问题呢？" class="headerlink" title="24、线上接口如果响应很慢如何去排查定位问题呢？"></a>24、线上接口如果响应很慢如何去排查定位问题呢？</h3><p>线上接口响应缓慢可能涉及多个因素，需要逐步排查和定位问题。以下是一些可能的步骤和方法：</p>
<ol>
<li><strong>监控和日志分析</strong>：<ul>
<li>检查系统监控指标，例如 CPU 使用率、内存占用、网络流量等，以确定是否存在资源瓶颈。</li>
<li>分析应用程序日志和性能监控数据，查找是否有异常或错误信息，以及哪些操作或查询导致响应变慢。</li>
</ul>
</li>
<li><strong>数据库查询性能</strong>：<ul>
<li>如果接口涉及数据库查询，检查数据库性能。使用数据库性能分析工具（如EXPLAIN查询计划）来评估查询的性能，查看是否存在慢查询。</li>
<li>确保数据库索引的正确性和有效性。</li>
</ul>
</li>
<li><strong>代码审查</strong>：<ul>
<li>仔细审查接口的代码，检查是否有低效或冗余的操作。特别关注循环、递归、不必要的IO操作等。</li>
<li>确保代码中没有阻塞、死锁或竞争条件。</li>
</ul>
</li>
<li><strong>网络延迟</strong>：<ul>
<li>检查网络延迟，特别是在分布式系统中。使用网络分析工具，查看是否存在网络瓶颈或连接问题。</li>
</ul>
</li>
<li><strong>缓存使用</strong>：<ul>
<li>如果应用程序使用缓存（如 Redis），确保缓存的正确使用。检查缓存是否过期，是否频繁失效，以及缓存命中率等。</li>
</ul>
</li>
<li><strong>第三方服务</strong>：<ul>
<li>如果接口依赖于其他第三方服务，检查这些服务是否正常运行。可能的问题包括第三方服务响应变慢、不稳定或不可用。</li>
</ul>
</li>
<li><strong>性能测试</strong>：<ul>
<li>进行性能测试，模拟高负载情况，观察接口在负载下的表现。这可以帮助确定是否存在扩展性问题。</li>
</ul>
</li>
<li><strong>代码优化和重构</strong>：<ul>
<li>基于分析结果，进行代码优化或重构。可能需要改进算法、减少数据库查询次数、使用缓存等手段来提高性能。</li>
</ul>
</li>
<li><strong>横向扩展</strong>：<ul>
<li>如果系统瓶颈主要来自资源限制，考虑横向扩展，增加服务器数量以分担负载。</li>
</ul>
</li>
<li><strong>监控和警报</strong>：<ul>
<li>设置实时监控和警报机制，以便在出现性能问题时能够及时采取行动。</li>
</ul>
</li>
</ol>
<p>总之，排查和解决线上接口响应缓慢的问题需要综合考虑多个因素，并逐步进行分析和改进。及时的监控和持续的性能优化是保障系统稳定和高效运行的关键。</p>
<h3 id="25、怎么做数据对账？"><a href="#25、怎么做数据对账？" class="headerlink" title="25、怎么做数据对账？"></a>25、怎么做数据对账？</h3><p>当需要进行数据对账时，通常涉及比较两个或多个数据源之间的差异，以确保数据的一致性和准确性。以下是一般的数据对账步骤：</p>
<ol>
<li><strong>确定对账目标</strong>： 确定要对账的数据源和目标，例如两个不同系统之间的数据、两个时间点的数据等。</li>
<li><strong>数据提取</strong>： 从每个数据源中提取需要对账的数据。这可能涉及数据库查询、API调用、文件导出等。</li>
<li><strong>数据转换</strong>： 将提取的数据转换成统一的格式，以便于后续比较。确保数据字段名、数据类型等匹配。</li>
<li><strong>数据比较</strong>： 对转换后的数据进行比较。比较的方法可以包括逐行比对、使用哈希函数生成数据指纹后进行比对等。</li>
<li><strong>差异分析</strong>： 如果数据源之间存在差异，进行详细的差异分析。确定哪些数据不一致，并找出造成差异的原因。</li>
<li><strong>差异解决</strong>： 根据差异分析结果，采取适当的措施来解决数据差异。可能需要更新数据、纠正错误等。</li>
<li><strong>记录和报告</strong>： 记录对账过程的结果，包括哪些数据一致，哪些数据不一致，以及差异的原因和解决方案。这可以作为后续审计和改进的依据。</li>
<li><strong>自动化对账</strong>（可选）： 对于频繁进行的对账任务，可以考虑建立自动化对账流程。这可以减少人工错误和时间成本。</li>
<li><strong>定期重复对账</strong>： 数据对账不是一次性任务，应该定期重复执行，以确保数据一致性的持续性。</li>
</ol>
<p>值得注意的是，数据对账可能会因应用场景和数据的不同而有所不同，上述步骤提供了一个通用的框架，可以根据实际情况进行调整和扩展。此外，对于大规模数据，可能需要考虑性能和效率问题，选择合适的工具和算法来进行对账操作。</p>
<h3 id="26、MySQL千万级大表如何做数据清理？"><a href="#26、MySQL千万级大表如何做数据清理？" class="headerlink" title="26、MySQL千万级大表如何做数据清理？"></a>26、MySQL千万级大表如何做数据清理？</h3><p>清理MySQL千万级大表的数据可以采取以下几种方法：</p>
<ol>
<li>分区表：如果你的表支持分区，可以根据时间范围将数据分散到不同的分区中。这样，当需要清理数据时，只需删除相应的分区即可，而不需要扫描整个表。这种方法可以提高清理数据的效率。</li>
<li>分批删除：将要删除的数据分成多个较小的批次进行删除，而不是一次性删除整个表的数据。可以使用LIMIT和OFFSET子句来限制每个批次的删除数量，并使用循环或脚本来逐批删除数据。这样可以减少对数据库的负载，避免一次性删除大量数据时的性能问题。</li>
<li>使用索引：确保表中的字段上有适当的索引。索引可以加快删除操作的速度，特别是在大表中。根据删除条件创建适当的索引，这样数据库可以更快地定位到要删除的数据。</li>
<li>优化删除语句：使用DELETE语句删除数据时，可以优化语句的性能。避免在删除操作中使用不必要的子查询或复杂的条件，这可能会导致查询执行时间过长。确保删除语句的WHERE条件能够充分利用索引，以提高删除操作的效率。</li>
<li>数据归档：如果你需要保留历史数据但不经常查询，可以考虑将旧数据归档到其他表或存储介质中，例如归档表、归档文件或其他数据库。这样可以减小主表的大小，提高查询性能。</li>
<li>定期维护：定期进行数据库维护操作，例如优化表结构、重建索引、收集统计信息等。这些操作可以提高数据库的性能，并减少数据清理的需要。</li>
</ol>
<p>在进行数据清理操作之前，请务必备份数据库以防止意外数据丢失。此外，根据你的具体情况，可能需要结合其他方法或工具来进行数据清理，例如使用分布式数据库、数据分片或数据迁移等。最好在测试环境中进行测试和验证，以确保清理操作的安全性和效果。</p>
<h3 id="27、为什么MySQL用B-树，MongoDB用B树？"><a href="#27、为什么MySQL用B-树，MongoDB用B树？" class="headerlink" title="27、为什么MySQL用B+树，MongoDB用B树？"></a>27、为什么MySQL用B+树，MongoDB用B树？</h3><p>MySQL和MongoDB使用不同的树结构（B+树和B树）作为其索引数据结构，这是基于它们的设计目标和特点而做出的选择。</p>
<p>B树（B-Tree）： &#x20;<br>B树是一种多路搜索树，用于在数据库中实现索引。它的主要特点是每个节点可以有多个子节点，适用于磁盘存储的数据库系统。B树的特点包括：</p>
<ol>
<li>平衡性：B树保持了树的平衡性，使得在查找操作时，最坏情况下的搜索时间仍然是O(log n)。这对于磁盘存储系统来说非常重要，因为它减少了磁盘I&#x2F;O次数，提高了查询效率。</li>
<li>节点包含键值和数据：B树的每个节点既包含键值，也包含数据。这意味着在叶子节点上即可找到实际的数据记录，而不需要再次跳转到另一个位置。56</li>
</ol>
<p>MongoDB使用B树作为索引数据结构，因为它被设计为一种灵活的文档数据库，支持丰富的数据模型。B树适用于在磁盘上存储大量数据，适合MongoDB这种需要处理大量文档的情况。然而，MongoDB在某些情况下可能也使用B+树的变体，比如Compound Indexes，以提高查询性能。</p>
<p>B+树（B-Plus Tree）： &#x20;<br>B+树是B树的变体，在B树的基础上进行了一些优化。它的主要特点是内部节点不存储数据，而只存储键值，实际的数据都存储在叶子节点上。B+树的特点包括：</p>
<ol>
<li>更适合范围查询：由于B+树的数据都存储在叶子节点上，并且叶子节点之间使用指针连接，因此范围查询更高效。这对于数据库系统非常重要，因为范围查询是数据库常见的查询类型之一。</li>
<li>适合磁盘存储：B+树的叶子节点形成了一个有序链表，便于顺序访问。这对于磁盘存储来说非常高效，因为可以减少磁盘的随机I&#x2F;O操作。</li>
</ol>
<p>MySQL使用B+树作为其索引数据结构，这是因为MySQL通常处理关系型数据，B+树适合在关系型数据库中进行范围查询和有序遍历。此外，B+树的结构使得它更适合支持聚簇索引（将数据和索引存储在一起），这在关系型数据库中非常常见。</p>
<p>综上所述，MySQL选择B+树作为索引结构，以适应其关系型数据模型和范围查询的需求，而MongoDB则选择B树，以适应其面向文档的数据模型。虽然两者的索引结构不同，但都旨在提供高效的数据访问和查询性能。</p>
<h3 id="28、高并发的积分系统，在数据库增加积分，怎么实现？"><a href="#28、高并发的积分系统，在数据库增加积分，怎么实现？" class="headerlink" title="28、高并发的积分系统，在数据库增加积分，怎么实现？"></a>28、高并发的积分系统，在数据库增加积分，怎么实现？</h3><p>在高并发的积分系统中，实现数据库增加积分的方式可以采用以下几种方法：</p>
<ol>
<li>乐观锁（Optimistic Locking）：使用乐观锁机制可以在不加锁的情况下实现并发操作。在数据库表中添加一个版本号（或时间戳）字段，每次更新积分时检查版本号，如果版本号匹配，则更新积分并增加版本号；如果版本号不匹配，则表示其他并发操作已修改数据，需要进行冲突处理。</li>
<li>悲观锁（Pessimistic Locking）：使用悲观锁可以在操作期间锁定数据，防止其他并发操作对数据进行修改。在更新积分之前，对相关的数据行或表进行加锁，确保只有一个线程可以修改数据。但悲观锁可能会导致性能下降，因为其他线程需要等待锁的释放。</li>
<li>分布式锁（Distributed Lock）：使用分布式锁可以实现多个应用程序实例之间的协调，确保只有一个实例可以执行增加积分的操作。可以使用基于数据库的分布式锁，如在MySQL中使用行级锁或表级锁，或者使用分布式锁服务，如Redis的分布式锁。</li>
<li>队列（Queue）：将增加积分的请求放入队列中，由单个线程或多个工作线程按顺序处理请求。这样可以避免并发冲突，并提供顺序处理的能力。常见的队列系统包括RabbitMQ、Kafka等。</li>
<li>事务（Transaction）：在数据库操作中使用事务可以确保操作的原子性和一致性。将增加积分的操作放在一个事务中，当多个并发操作同时进行时，数据库会自动处理并发冲突，保证数据的正确性。</li>
</ol>
<p>无论采用哪种方法，都需要根据具体的业务需求和系统架构来选择合适的方案。同时，还需要考虑数据库的性能和扩展性，以及并发操作可能带来的性能瓶颈和资源竞争。在设计和实现时，可以结合使用以上的方法，以满足高并发积分系统的需求。</p>
<h3 id="29、MySQL热点数据更新会带来哪些问题？"><a href="#29、MySQL热点数据更新会带来哪些问题？" class="headerlink" title="29、MySQL热点数据更新会带来哪些问题？"></a>29、MySQL热点数据更新会带来哪些问题？</h3><p>当MySQL中的热点数据频繁更新时，可能会导致以下问题：</p>
<ol>
<li>锁竞争：多个并发事务同时更新同一行或同一组数据时，会引发锁竞争。如果没有合适的锁策略和并发控制机制，可能会导致事务等待和阻塞，降低系统的并发性能。</li>
<li>死锁：如果多个事务之间存在循环依赖的更新操作，并且没有正确处理锁的顺序，可能会导致死锁的发生。死锁会导致事务无法继续执行，需要通过超时或者手动干预来解决。</li>
<li>数据不一致：当热点数据频繁更新时，如果没有正确的事务隔离级别和并发控制策略，可能会导致数据不一致的问题。例如，读取到未提交的数据或者读取到部分更新的数据。</li>
<li>性能瓶颈：频繁的热点数据更新可能会导致数据库性能瓶颈，特别是在高并发的情况下。数据库需要处理大量的更新操作，可能会增加CPU和磁盘的负载，导致响应时间延长和吞吐量下降。</li>
<li>数据库压力：热点数据更新可能会导致数据库的存储空间增加和磁盘IO的负载增加。如果没有及时的数据库优化和调整，可能会导致数据库性能下降和存储资源的消耗。</li>
</ol>
<p>为了解决这些问题，可以采取以下措施：</p>
<ol>
<li>优化查询和更新语句：通过合理的索引设计、查询优化和更新批量处理等方式，减少对热点数据的频繁更新操作，降低锁竞争和数据库负载。</li>
<li>选择合适的事务隔离级别：根据业务需求和数据一致性要求，选择合适的事务隔离级别，避免读取到脏数据或不可重复读的问题。</li>
<li>使用合理的并发控制策略：通过锁机制、乐观锁或悲观锁等方式，控制并发事务对热点数据的访问和更新，避免锁竞争和死锁的发生。</li>
<li>数据库优化和扩展：通过合理的数据库配置、硬件升级、分库分表、读写分离等方式，提升数据库的性能和扩展性，以应对高并发的热点数据更新。</li>
</ol>
<p>综上所述，热点数据的频繁更新可能会带来锁竞争、死锁、数据不一致、性能瓶颈和数据库压力等问题。通过合理的数据库设计、并发控制和优化策略，可以有效地解决这些问题，并提升系统的性能和可靠性。</p>
<h3 id="30、和外部机构交互如何防止被外部服务不可用而拖垮"><a href="#30、和外部机构交互如何防止被外部服务不可用而拖垮" class="headerlink" title="30、和外部机构交互如何防止被外部服务不可用而拖垮"></a>30、和外部机构交互如何防止被外部服务不可用而拖垮</h3><p>与外部机构交互时，为了防止外部服务不可用导致自身服务受到影响，可以采取以下一些策略：</p>
<ol>
<li><strong>超时设置和重试机制：</strong> 在与外部服务进行交互时，设置合适的超时时间。如果在预定时间内未收到响应，可以触发重试机制，多次尝试与外部服务建立连接。但是要注意避免无限制的重试，以免对自身系统造成过多负担。</li>
<li><strong>限流和熔断：</strong> 使用限流和熔断机制来控制与外部服务的交互频率。当外部服务不可用或响应时间过长时，可以暂时停止或降低对该服务的请求，防止过多的请求集中到不可用的服务上，从而拖垮自身服务。</li>
<li><strong>服务降级：</strong> 在外部服务不可用的情况下，可以采取服务降级策略，提供一个备用的功能或响应，确保自身系统的基本功能仍然可用。例如，展示缓存数据、提供默认值等。</li>
<li><strong>异步处理：</strong> 将与外部服务的交互设计为异步操作，不会直接阻塞主要流程。将请求放入消息队列或异步任务中，从而减少直接依赖外部服务的耦合。</li>
<li><strong>多地域部署：</strong> 如果外部服务支持多地域部署，可以选择将自身服务部署在多个地理位置，以减少单一地区外部服务不可用对整体系统的影响。</li>
<li><strong>监控和报警：</strong> 实施有效的监控和报警系统，及时检测外部服务的可用性和性能。一旦发现问题，可以迅速采取措施，如切换到备用服务、通知相关人员等。</li>
<li><strong>合理的容错策略：</strong> 在代码中实施合理的容错策略，例如处理异常情况、优雅降级和自动恢复机制，确保系统在外部服务不稳定时也能正常运行。</li>
<li><strong>预案和应急准备：</strong> 制定与外部服务不可用时的应急预案，明确责任人员和处理流程，以便在发生问题时能够迅速应对。</li>
<li><strong>合作伙伴选择：</strong> 在选择外部服务供应商时，要考虑其稳定性和可靠性。选择有良好服务记录和强大基础设施的供应商，减少不可用风险。</li>
</ol>
<p>总之，通过合理的设计和应对策略，可以最大程度地降低外部服务不可用对自身服务造成的影响，保障系统的稳定性和可用性。</p>
<h3 id="31、MySQL-里有-2000W-数据，Redis-中只存-20W-的数据，如何保证-Redis-中的数据都是热点数据"><a href="#31、MySQL-里有-2000W-数据，Redis-中只存-20W-的数据，如何保证-Redis-中的数据都是热点数据" class="headerlink" title="31、MySQL 里有 2000W 数据，Redis 中只存 20W 的数据，如何保证 Redis 中的数据都是热点数据?"></a>31、MySQL 里有 2000W 数据，Redis 中只存 20W 的数据，如何保证 Redis 中的数据都是热点数据?</h3><p>要确保Redis中存储的数据都是热点数据，可以考虑以下策略：</p>
<ol>
<li><strong>缓存策略选择：</strong> 选择合适的缓存策略，如LRU（最近最少使用）、LFU（最不经常使用）或基于时间过期等。这些策略可以根据数据的访问频率和使用情况来淘汰冷数据，确保Redis中存储的数据都是热点数据。</li>
<li><strong>数据预热：</strong> 在系统启动或负载低峰期，可以通过预热的方式将热点数据加载到Redis中。预热可以通过批量读取数据库中的热点数据，并将其存储到Redis中，以提前缓存热点数据，减少后续访问时的延迟。</li>
<li><strong>数据更新时同步更新Redis：</strong> 当MySQL中的数据发生更新时，及时将更新的数据同步到Redis中。可以通过在应用程序中实现数据更新的逻辑，保持MySQL和Redis中数据的一致性。这样可以确保Redis中存储的数据是最新的热点数据。</li>
<li><strong>定期更新数据：</strong> 定期更新Redis中的数据，将最新的热点数据加载到Redis中。可以通过定时任务或者触发器来实现定期更新，以保证Redis中的数据与MySQL中的热点数据保持同步。</li>
<li><strong>监控和自动清理：</strong> 监控Redis中的数据访问情况和存储空间占用情况。根据实际情况，自动清理不再是热点数据的缓存，以释放存储空间并保持Redis中存储的数据都是热点数据。</li>
<li><strong>合理设置过期时间：</strong> 对于不再频繁访问的数据，可以设置较短的过期时间，以便在一段时间内没有被访问时自动从Redis中淘汰。这样可以确保Redis中存储的数据都是当前较为活跃的热点数据。</li>
</ol>
<p>通过以上策略，可以有效地保证Redis中存储的数据都是热点数据，提高数据访问的性能和响应速度。但需要根据具体业务场景和数据访问模式来选择和调整策略，以达到最佳效果。</p>
<h2 id="项目上线问题排查–工作经验"><a href="#项目上线问题排查–工作经验" class="headerlink" title="项目上线问题排查–工作经验"></a>项目上线问题排查–工作经验</h2><h3 id="1、RT飙高问题排查过程"><a href="#1、RT飙高问题排查过程" class="headerlink" title="1、RT飙高问题排查过程"></a>1、RT飙高问题排查过程</h3><p>当遇到实时（RT）飙高的问题时，可以按照以下步骤进行排查：</p>
<ol>
<li><strong>确认问题现象：</strong> 首先，需要明确实时飙高的具体表现和受影响的方面。例如，是CPU使用率飙高还是网络延迟增加，是某个特定服务的响应时间增长，还是整个系统的吞吐量下降等。</li>
<li><strong>监测系统指标：</strong> 使用系统监控工具或性能分析工具来收集系统的关键指标。这些指标包括CPU使用率、内存使用率、网络吞吐量、磁盘IO等。通过监测这些指标，可以了解系统在实时飙高期间的状态。</li>
<li><strong>查看日志和错误信息：</strong> 检查系统日志和错误日志，寻找与实时飙高相关的任何错误或异常信息。这些信息可能会提供有关问题原因的线索，例如异常堆栈跟踪、错误消息等。</li>
<li><strong>分析负载和请求模式：</strong> 研究实时飙高期间的负载和请求模式。检查是否有异常的请求频率或请求量增加，是否有突发的负载压力，以及是否有特定的请求类型或资源导致了飙高问题。</li>
<li><strong>检查系统配置和资源限制：</strong> 检查系统的配置和资源限制，包括服务器硬件配置、操作系统参数、应用程序配置等。确保系统的配置与实际需求相匹配，并且没有过度限制资源的设置。</li>
<li><strong>排查代码问题：</strong> 检查应用程序的代码，寻找可能导致实时飙高的问题。这可能包括低效的算法、循环中的死循环、资源泄漏、线程阻塞等。使用性能分析工具来确定代码中的瓶颈和性能热点。</li>
<li><strong>排查第三方服务：</strong> 如果系统依赖于第三方服务，检查这些服务是否出现故障或延迟。可能需要联系第三方服务提供商来了解是否存在与实时飙高相关的问题。</li>
<li><strong>进行压力测试和负载测试：</strong> 使用压力测试工具模拟实际负载，并观察系统在高负载情况下的表现。这有助于确定系统的性能极限和可能的瓶颈。</li>
<li><strong>逐步回退变更：</strong> 如果实时飙高问题与最近的系统变更相关，可以逐步回退这些变更，以确定是否有特定的变更引起了飙高问题。</li>
<li><strong>寻求专家帮助：</strong> 如果以上步骤无法解决问题，可以寻求专家的帮助，例如系统管理员、开发人员或性能工程师。他们可能有更深入的知识和经验来解决实时飙高问题。</li>
</ol>
<p>通过以上排查步骤，可以逐步缩小问题范围，找到实时飙高问题的根本原因，并采取相应的措施来解决问题。</p>
<h3 id="2、CPU飙高问题排查过程"><a href="#2、CPU飙高问题排查过程" class="headerlink" title="2、CPU飙高问题排查过程"></a>2、CPU飙高问题排查过程</h3><p>排查 CPU 飙高问题的过程可以分为以下步骤：</p>
<ol>
<li><strong>确认问题：</strong> 首先，要明确 CPU 飙高的问题是否真实存在。可以通过监控工具、系统日志等途径来验证 CPU 使用率是否异常升高。</li>
<li><strong>确定影响范围：</strong> 确定是整个系统的 CPU 使用率升高还是特定进程&#x2F;应用程序导致的。这可以通过查看系统级别的监控数据和进程级别的监控数据来判断。</li>
<li><strong>分析进程和应用程序：</strong> 如果是特定进程或应用程序导致的 CPU 飙高，就需要分析这些进程&#x2F;应用程序的行为。可以使用工具如 <code>top</code>、<code>htop</code>、<code>ps</code> 等来查看进程的 CPU 使用率、内存占用、线程数等信息。</li>
<li><strong>查看系统资源使用情况：</strong> 检查内存、磁盘、网络等资源的使用情况，因为资源竞争也可能导致 CPU 飙高。特别注意内存的使用情况，过多的交换（swap）可能会导致 CPU 使用率升高。</li>
<li><strong>检查日志：</strong> 查看系统日志、应用程序日志以及可能的错误日志，以便找到任何异常或错误信息。有时候某些异常事件可能导致 CPU 使用率升高。</li>
<li><strong>性能分析工具：</strong> 使用性能分析工具，如 <code>perf</code>、<code>strace</code>、<code>dtrace</code> 等，来跟踪进程的系统调用、函数调用和事件，以帮助确定是哪些操作导致了 CPU 飙高。</li>
<li><strong>检查代码：</strong> 如果问题与特定应用程序相关，可能需要检查应用程序的代码，查找可能的瓶颈或死循环。代码中可能存在的资源竞争、不合理的循环等问题都可能导致 CPU 使用率升高。</li>
<li><strong>硬件问题排除：</strong> 考虑硬件故障可能导致的问题，如散热不足、硬件损坏等，这些问题也可能导致 CPU 飙高。</li>
<li><strong>升级和优化：</strong> 如果确定问题是由于某个应用程序或组件的性能问题导致的，可以尝试升级软件版本，应用性能优化技巧，或者调整配置参数来缓解问题。</li>
<li><strong>监控和预防：</strong> 一旦问题解决，建议设置持续的监控来跟踪系统和应用程序的性能，以便及时发现并预防类似问题的再次发生。</li>
</ol>
<p>在排查 CPU 飙高问题时，关键是收集足够的信息，从多个角度进行分析，以便确定问题的根本原因。根据不同的情况，可能需要结合多种方法和工具来解决问题。</p>
<h3 id="3、数据库连接池满排查过程"><a href="#3、数据库连接池满排查过程" class="headerlink" title="3、数据库连接池满排查过程"></a>3、数据库连接池满排查过程</h3><p>数据库连接池满的报警，报错信息如下</p>
<p>应用报警：4103.ERR_ATOM_CONNECTION_POOL_FULL，应用数据库连接池满。</p>
<p>陆续出现 4200.ERR_GROUP_NOT_AVALILABLE、4201.ERR_GROUP_NO_ATOM_AVAILABLE、4202.ERR_SQL_QUERY_TIMEOUT等数据库异常报警。</p>
<p>当数据库连接池满时，可以按照以下步骤进行排查：</p>
<ol>
<li><strong>确认连接池满的迹象：</strong> 监控数据库连接池的指标，例如连接数、活动连接数、空闲连接数等。如果这些指标达到连接池的最大限制，说明连接池已满。</li>
<li><strong>查看数据库连接池配置：</strong> 检查连接池的配置参数，包括最大连接数、最小空闲连接数、连接超时时间等。确保这些参数的设置合理，并且能够满足系统的需求。</li>
<li><strong>分析连接池使用情况：</strong> 查看连接池的使用情况，包括连接的获取和释放过程。记录下频繁获取连接的代码路径和时间点，以及连接释放是否及时。这有助于找出连接泄露或者连接使用不当的问题。</li>
<li><strong>检查数据库连接资源：</strong> 检查数据库服务器的连接资源情况。查看数据库服务器的最大连接数设置，以及当前连接数是否接近最大限制。如果数据库服务器也存在连接数限制，可以考虑增加最大连接数的配置。</li>
<li><strong>检查数据库性能：</strong> 检查数据库服务器的性能指标，例如 CPU 使用率、内存使用率、磁盘 I&#x2F;O 等。如果数据库服务器的性能达到瓶颈，可能导致连接池满。优化数据库性能可以缓解连接池满的问题。</li>
<li><strong>检查数据库操作：</strong> 检查应用程序中的数据库操作，包括查询语句、事务处理等。优化数据库操作可以减少连接的占用时间，从而减少连接池的压力。</li>
<li><strong>检查应用程序并发访问：</strong> 检查应用程序的并发访问情况，特别是在高峰时段。如果并发访问量过大，可能会导致连接池满。可以考虑增加连接池的大小或者优化应用程序的并发处理能力。</li>
<li><strong>查看日志和异常信息：</strong> 检查应用程序的日志和异常信息，查找是否有连接池相关的错误或异常。这些信息可以帮助定位连接池满的原因。</li>
<li><strong>性能分析工具：</strong> 使用性能分析工具来跟踪应用程序的数据库连接使用情况，例如连接的创建、销毁、使用时间等。这有助于找出连接使用不当或者泄露的问题。</li>
<li><strong>优化和调整：</strong> 根据排查结果，进行相应的优化和调整。可以调整连接池的配置参数，增加连接池的大小，优化数据库操作，或者增加数据库服务器的性能。</li>
</ol>
<p>通过以上步骤的排查，可以找出数据库连接池满的原因，并采取相应的措施来解决问题。重要的是收集足够的信息，从多个角度进行分析，以便确定问题的根本原因。</p>
<h3 id="4、数据库CPU被打满排查过程"><a href="#4、数据库CPU被打满排查过程" class="headerlink" title="4、数据库CPU被打满排查过程"></a>4、数据库CPU被打满排查过程</h3><p>开发经常收到数据库的报警，提示我们的数据库的CPU有异常飙高的情况，通过top命令发现，经常把CPU打满了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/%E5%9C%BA%E6%99%AF%E9%A2%98%5C%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%5Cimage%5Cimage_EA4lcUqgLZ.png"></p>
<p>排查数据库CPU被打满的问题通常需要一系列步骤来定位和解决。下面是一般的排查过程：</p>
<ol>
<li><strong>确认CPU使用率高</strong>: 首先，确保数据库服务器的CPU使用率确实是高的。可以使用操作系统提供的工具（如<code>top</code>、<code>htop</code>等）或数据库性能监控工具来验证。</li>
<li><strong>检查数据库负载</strong>: 查看数据库的当前负载情况，包括并发连接数、查询数量、事务处理数等。这可以帮助确认是否存在异常的数据库活动。</li>
<li><strong>分析长时间运行的查询</strong>: 使用数据库性能分析工具，如<code>EXPLAIN</code>语句、查询计划查看是否有复杂、低效率的查询在运行。优化这些查询可以减轻CPU负担。</li>
<li><strong>检查索引使用情况</strong>: 确保数据库表使用了适当的索引。没有或者不正确使用索引可能导致查询变得非常耗时，进而导致CPU使用率上升。</li>
<li><strong>检查锁等待情况</strong>: 死锁或者大量的锁等待会导致CPU被打满。确保应用程序和数据库使用了合适的锁策略，避免锁争用。</li>
<li><strong>检查硬件资源</strong>: 确保数据库服务器的硬件资源足够，包括CPU核数、内存、磁盘I&#x2F;O等。不足的硬件资源可能导致CPU过载。</li>
<li><strong>检查并发连接数</strong>: 大量并发连接可能导致CPU过载。评估并优化应用程序连接池的设置，确保不会有过多的闲置连接。</li>
<li><strong>监控长时间运行的进程</strong>: 使用操作系统的工具来监控是否有长时间运行的进程占用了过多的CPU资源。这可能是恶意进程或者其他异常情况。</li>
<li><strong>审查系统日志</strong>: 检查数据库服务器的系统日志，查找异常、错误消息，这有助于找到可能的问题根源。</li>
<li><strong>考虑数据库优化</strong>: 如果排查过程中发现一些持续存在的性能问题，考虑数据库的整体优化，包括配置优化、硬件升级、数据库版本升级等。</li>
<li><strong>性能测试</strong>: 在排查过程结束后，可以进行性能测试，验证优化措施是否有效，是否解决了CPU被打满的问题。</li>
</ol>
<p>总之，排查数据库CPU被打满的过程需要综合考虑多个因素，从数据库层面、应用程序层面和硬件层面分析，最终找到根本原因并采取相应措施来解决问题。</p>
<h3 id="5、OOM问题排查过程"><a href="#5、OOM问题排查过程" class="headerlink" title="5、OOM问题排查过程"></a>5、OOM问题排查过程</h3><p>OOM（Out of Memory）问题是指系统内存不足，无法满足进程的内存需求，导致进程被操作系统终止的情况。下面是一般的OOM问题排查过程：</p>
<ol>
<li><strong>确认OOM错误</strong>: 首先，确认系统中是否发生了OOM错误。可以查看系统日志（如&#x2F;var&#x2F;log&#x2F;messages）或者使用命令<code>dmesg</code>来检查系统日志中是否有OOM相关的错误信息。</li>
<li><strong>检查内存使用情况</strong>: 使用系统监控工具（如top、htop）或者命令（如free、vmstat）来检查系统的内存使用情况。确认系统内存是否已经耗尽。</li>
<li><strong>检查进程内存使用</strong>: 确定哪个进程使用了大量的内存。可以使用top命令按内存使用排序，或者使用ps命令查看进程的内存占用情况。</li>
<li><strong>检查内存泄漏</strong>: 如果发现某个进程占用了大量内存，但是没有明显的原因，可能存在内存泄漏的情况。可以使用内存分析工具（如Valgrind）来检测和定位内存泄漏问题。</li>
<li><strong>检查进程资源限制</strong>: 确认进程的资源限制是否合理，包括内存限制（ulimit -a）和文件描述符限制（ulimit -n）。如果限制过低，可能导致进程无法获取足够的内存资源。</li>
<li><strong>检查系统交换空间</strong>: 确认系统是否启用了交换空间（swap），以及交换空间的大小。如果交换空间过小或者未启用，当内存不足时，系统无法将部分内存数据交换到磁盘，从而导致OOM错误。</li>
<li><strong>检查程序日志</strong>: 检查程序的日志文件，查找是否有与内存使用相关的错误或异常信息。这有助于定位程序中可能导致OOM的问题。</li>
<li><strong>优化程序内存使用</strong>: 根据具体情况，优化程序的内存使用方式。可以考虑使用内存池、减少内存分配次数、释放不再使用的内存等方法来降低内存占用。</li>
<li><strong>调整系统配置</strong>: 根据具体情况，可能需要调整系统的内核参数或者其他配置，以提高系统的内存管理和利用效率。</li>
<li><strong>增加硬件资源</strong>: 如果经过优化和调整后仍然无法解决OOM问题，可能需要考虑增加系统的硬件资源，如增加内存容量或者升级到更高性能的服务器。</li>
</ol>
<p>总之，OOM问题的排查过程需要综合考虑多个因素，包括内存使用情况、进程资源限制、系统配置等，通过定位问题原因并采取相应措施来解决问题。</p>
<h3 id="6、频繁FullGC问题排查"><a href="#6、频繁FullGC问题排查" class="headerlink" title="6、频繁FullGC问题排查"></a>6、频繁FullGC问题排查</h3><p>频繁的Full GC（Full Garbage Collection）问题通常是由于Java应用程序中的内存管理问题导致的。下面是一般的排查过程：</p>
<ol>
<li><strong>确认Full GC频率</strong>: 首先，确认Full GC确实发生频繁。可以通过查看Java应用程序的GC日志或者性能监控工具来确定Full GC的发生频率和持续时间。</li>
<li><strong>检查堆内存设置</strong>: 确认Java应用程序的堆内存设置是否合理。堆内存过小可能导致频繁的垃圾回收，而堆内存过大可能导致Full GC时间过长。可以通过调整-Xmx和-Xms参数来适当调整堆内存大小。</li>
<li><strong>分析GC日志</strong>: 详细分析GC日志，查看Full GC发生的原因。GC日志中会提供关于垃圾回收的详细信息，包括每个GC阶段的时间、堆内存使用情况、对象分配速率等。通过分析GC日志可以确定Full GC的具体原因。</li>
<li><strong>检查内存泄漏</strong>: 频繁的Full GC可能是由于内存泄漏导致的。使用内存分析工具（如MAT、VisualVM）来检测和定位内存泄漏问题。分析内存快照可以查看对象的引用链，找出造成内存泄漏的代码或对象。</li>
<li><strong>检查对象生命周期</strong>: 确认应用程序中的对象生命周期是否合理。如果有大量长时间存活的对象，可能会导致频繁的Full GC。可以考虑优化对象的创建和销毁方式，减少对象的生命周期。</li>
<li><strong>优化垃圾回收器参数</strong>: 根据具体情况，可以调整垃圾回收器的参数来优化GC性能。不同的垃圾回收器有不同的参数可供调整，如新生代和老年代的比例、垃圾回收算法等。</li>
<li><strong>减少对象分配</strong>: 频繁的Full GC可能是由于过多的对象分配导致的。可以通过重用对象、使用对象池、减少临时对象的创建等方式来降低对象分配的频率。</li>
<li><strong>检查外部资源释放</strong>: 确保应用程序正确释放外部资源，如数据库连接、文件句柄等。未正确释放外部资源可能导致内存泄漏和频繁的Full GC。</li>
<li><strong>增加堆内存或调整GC策略</strong>: 如果经过优化后仍然无法解决频繁的Full GC问题，可以考虑增加堆内存大小或者尝试其他的GC策略，如G1 GC。</li>
<li><strong>性能测试和监控</strong>: 在排查过程结束后，进行性能测试和监控，验证优化措施是否有效，是否解决了频繁的Full GC问题。</li>
</ol>
<p>总之，频繁的Full GC问题排查需要综合考虑堆内存设置、GC日志分析、内存泄漏、对象生命周期等因素，并采取相应的优化措施来减少Full GC的频率和持续时间。</p>
<h3 id="7、Arthas统计方法耗时的原理是什么？"><a href="#7、Arthas统计方法耗时的原理是什么？" class="headerlink" title="7、Arthas统计方法耗时的原理是什么？"></a>7、Arthas统计方法耗时的原理是什么？</h3><p>Arthas 是一款用于 Java 应用程序的诊断工具，可以实时地查看和修改应用程序的运行状态。其中一个功能就是统计方法的耗时，这个功能主要是通过对字节码的修改来实现的。</p>
<p>具体原理如下：</p>
<ol>
<li><strong>字节码修改</strong>: Arthas 使用字节码增强技术，通过在类加载时修改字节码，在方法的入口和出口处插入计时代码。这使得 Arthas 能够在不修改源代码的情况下，动态地统计方法的执行时间。</li>
<li><strong>方法耗时统计</strong>: 当目标方法被调用时，Arthas 在方法入口处记录当前时间戳（start time），然后在方法退出时记录另一个时间戳（end time）。通过这两个时间戳的差值，就可以计算出方法的执行时间，从而实现方法耗时的统计。</li>
<li><strong>展示和分析</strong>: Arthas 收集到方法耗时的数据后，会将这些数据进行汇总并展示给用户。用户可以通过 Arthas 提供的命令或者 Web 控制台来查看方法的平均执行时间、最大执行时间、执行次数等信息，从而快速定位潜在的性能瓶颈。</li>
</ol>
<p>需要注意的是，由于 Arthas 是通过字节码增强实现方法耗时的统计，所以在某些情况下可能会对应用程序的性能产生一定的影响，特别是当需要对大量方法进行耗时统计时。因此，在生产环境中，应该谨慎使用 Arthas 的耗时统计功能，避免过度的方法耗时统计对应用程序性能造成不必要的影响。</p>
<p>另外，Arthas 还提供了其他强大的功能，如实时查看方法参数、修改方法返回值等，可以帮助开发人员更方便地诊断和调试 Java 应用程序。</p>
<h3 id="8、慢SQL问题排查"><a href="#8、慢SQL问题排查" class="headerlink" title="8、慢SQL问题排查"></a>8、慢SQL问题排查</h3><p>慢SQL问题是指在数据库中执行的SQL语句花费了过长的时间来完成。下面是一般的慢SQL问题排查过程：</p>
<ol>
<li><strong>确认慢SQL</strong>: 首先，确认哪些SQL语句被认为是慢SQL。可以通过数据库的性能监控工具或日志来获取执行时间较长的SQL语句。</li>
<li><strong>分析执行计划</strong>: 对于慢SQL，分析其执行计划是非常重要的。执行计划描述了数据库是如何执行SQL语句的，包括使用的索引、表的访问方式等。通过执行计划可以确定是否存在索引缺失、全表扫描等性能问题。</li>
<li><strong>检查索引使用</strong>: 确认慢SQL是否使用了适当的索引。可以通过执行计划或数据库的索引统计信息来判断是否存在索引缺失、索引选择不当等问题。根据需要，可以创建、修改或删除索引来优化查询性能。</li>
<li><strong>优化SQL语句</strong>: 对于慢SQL，可以考虑对SQL语句进行优化。可以通过重写SQL语句、使用更合适的查询方式（如JOIN、子查询等）、避免使用不必要的函数或操作符等来提高查询性能。</li>
<li><strong>检查表结构和数据量</strong>: 确认表的结构是否合理，并检查表中的数据量是否过大。如果表结构不合理或数据量过大，可能会导致查询性能下降。可以考虑调整表结构、拆分大表、分区等方式来优化查询性能。</li>
<li><strong>数据库优化</strong>: 除了SQL语句本身，还可以考虑对数据库进行优化。例如，调整数据库的缓冲区大小、增加内存、优化数据库参数配置等，以提升数据库的整体性能。</li>
<li><strong>使用数据库工具</strong>: 使用数据库性能监控工具或查询分析工具可以更直观地分析慢SQL问题。这些工具可以提供更详细的性能指标、执行计划、索引建议等信息，帮助更准确地定位和解决慢SQL问题。</li>
<li><strong>性能测试和监控</strong>: 在优化慢SQL后，进行性能测试和监控，验证优化措施是否有效，是否解决了慢SQL问题。</li>
</ol>
<p>总之，慢SQL问题排查需要综合考虑SQL语句本身、索引使用、表结构、数据库配置等多个因素，并采取相应的优化措施来提高查询性能。同时，定期监控数据库的性能，及时发现和解决慢SQL问题，以保证应用程序的正常运行和良好的性能。</p>
<h3 id="9、Load飙高问题排查过程"><a href="#9、Load飙高问题排查过程" class="headerlink" title="9、Load飙高问题排查过程"></a>9、Load飙高问题排查过程</h3><p>有一个项目，平常都没事的，运行的都比较好，但每次在发布过程中，刚刚重启好机器经常会有cpu利用率和load飙高的现象，导致我们项目的RT变高，反馈有大量超时.</p>
<p>当服务器的负载（Load）飙高，表示服务器正在承受超过其处理能力的负载，导致性能下降或服务不可用。以下是一般的 Load 飙高问题排查过程：</p>
<ol>
<li><strong>确认负载情况</strong>: 使用系统监控工具（如top、htop等）或性能监控平台，确认服务器的负载情况。负载通常由三个数字表示，分别是1分钟、5分钟和15分钟的平均负载。如果这些数字超过服务器的处理能力，说明负载过高。</li>
<li><strong>检查系统资源使用</strong>: 检查服务器的 CPU、内存、磁盘和网络等资源的使用情况。使用工具（如top、free、iostat等）来查看各个资源的使用情况，确定是否有资源瓶颈导致负载飙高。</li>
<li><strong>查找高负载进程</strong>: 使用系统监控工具或命令（如top、ps等）查找占用系统资源较多的进程。关注 CPU 使用率高的进程，以及可能导致高磁盘IO或网络流量的进程。</li>
<li><strong>分析高负载进程</strong>: 对于占用系统资源较多的进程，进一步分析其原因。可以查看进程的日志、配置文件、线程信息等，以确定是否存在异常情况、死循环、资源竞争等问题。</li>
<li><strong>优化高负载进程</strong>: 根据分析结果，对高负载进程进行优化。可能的优化措施包括改进代码逻辑、减少资源占用、增加缓存、调整线程池大小等。</li>
<li><strong>扩展资源</strong>: 如果负载过高是由于资源不足导致的，可以考虑扩展服务器资源。例如，增加 CPU 核心、扩大内存容量、使用更快的磁盘等。</li>
<li><strong>监控和自动化</strong>: 部署监控系统，实时监测服务器的负载情况，及时发现和解决负载飙高问题。可以设置警报机制，当负载超过一定阈值时，及时通知运维人员。</li>
<li><strong>性能测试和调优</strong>: 在优化措施实施后，进行性能测试和监控，验证是否解决了负载飙高问题，并持续监控服务器的性能，及时调整和优化。</li>
</ol>
<p>需要注意的是，负载飙高可能由多种原因引起，可能是由于应用程序的问题，也可能是由于系统配置不当或硬件故障等。因此，在排查过程中需要综合考虑多个因素，并采取相应的措施来解决负载飙高问题。</p>
<h1 id="人事面试–情商"><a href="#人事面试–情商" class="headerlink" title="人事面试–情商"></a>人事面试–情商</h1><h2 id="一、请介绍一下你自己"><a href="#一、请介绍一下你自己" class="headerlink" title="一、请介绍一下你自己"></a>一、请介绍一下你自己</h2><p><strong>回答提示：</strong> 这是面试官100%会问的问题，一般人回答这个问题过于平常，只说姓名、年龄、爱好、所学专业等，如果你用一分钟来重复你的简历，那么，你的印象加分没有了！不妨坦诚自信地展现自我，重点突出与应聘职位相吻合的优势。你的相关能力和素质是企业最感兴趣的信息。因为，在许多情况下，在听取你的介绍时，面试官也会抓住他感兴趣的点深入询问。所以，在进行表述时，要力求以真实为基础，顾及表达的逻辑性和条理性，避免冗长而没有重点的叙述。一定要在最短的时间内激发起面试官对你的好感。</p>
<p><strong>回答范例：</strong></p>
<p>1、我叫XX，今年X岁，XXXX年毕业于XX大学。有3年的开发工作经验，我对技术有深厚的兴趣，专业知识面宽，责任心强，思路清晰，沟通力能好，精通.Net技术体系，熟悉MVC。平常有时间看看博客，并且自己也喜欢在CSDN上写技术类的文章，与博友一起讨论。谢谢！</p>
<p>2、如果跟人事自我介绍：您好！我叫** <em>，（如果学校和专业好的话可以提一下，一般的话就算了。）我之前在XX公司做过两年JAVA开发工程师，在这两年当中大概接触过什么样类型的项目，（比如商城，金融等）今天看了咱们公司招聘的岗位需求跟我之前的工作内容挺相符的，而且咱们公司的业务也是我喜欢的类型，所以我今天过来面试。希望可以加入到咱们公司当中来。 3、如果是跟技术自我介绍：您好！我叫</em>**，（如果学校和专业好的话可以提一下，一般的话就算了。）我之前在XX公司做过两年JAVA开发工程师，在这两年当中大概接触过什么样类型的项目，（比如商城，金融等）；在做这些项目的当中常用的一些技术点包括XX技术，（另外除了常用的技术还会一些其他的专业技能），今天看了咱们公司招聘的岗位需求跟我之前的工作内容挺相符的，所以我今天过来咱们公司面试，希望可以加入到咱们这个大家庭当中来。</p>
<h2 id="二、为什么来深圳找工作？"><a href="#二、为什么来深圳找工作？" class="headerlink" title="二、为什么来深圳找工作？"></a><strong>二、为什么来</strong>深圳找工作？</h2><p>面试官对异地求职者90%都会问的问题，主要考察你是否稳定，个人经验能力之外，排在第一位的就是稳定性，如果不够稳定，那么其余都是空谈。</p>
<p><strong>回答范例：</strong> 我来自湖南，湖南是一个农业大省，IT行业还不是很发达，我是学计算机专业的，也很喜欢这个行业，深圳在国内IT行业发展是最快的，所以我想来这里谋求发展，学习更多的新技术，能够带来自我的提升。</p>
<p><strong>注意：</strong> 不要说以前公司有多么不好。也不要说哪个哥们混的很不错，羡慕才来深圳。因为企业招人想要的都是能够长期工作的人，可能哪个哥们哪天在别的地方又混的更好了，你是不是还要跳槽？所以，只要说来学习更多新技术和管理经验就够了。</p>
<h2 id="三、你为什么离开原来的公司？"><a href="#三、你为什么离开原来的公司？" class="headerlink" title="三、你为什么离开原来的公司？"></a>三、你为什么离开原来的公司？</h2><p><strong>回答提示：</strong> 最重要的是：应聘者要使找招聘单位相信，应聘者在过往的单位的“离职原因”在此家招聘单位里不存在。避免把“离职原因”说得太详细、太具体。不能掺杂主观的负面感受，如“太辛苦”、“人际关系复杂”、“管理太混乱”、“公司不重视人才”、“公司排斥我们某某的员工”等。但也不能躲闪、回避，如“想换换环境”、“个人原因”等。不能涉及自己负面的人格特征，如不诚实、懒惰、缺乏责任感、不随和等。尽量使解释的理由为应聘者个人形象添彩。</p>
<p><strong>回答范例：</strong> 如“我离职是因为这家公司倒闭；我在公司工作了三年多，有较深的感情；从去年始，由于市场形势突变，公司的局面急转直下；到眼下这一步我觉得很遗憾，但还要面对显示，重新寻找能发挥我能力的舞台。”同一个面试问题并非只有一个答案，而同一个答案并不是在任何面试场合都有效，关键在应聘者掌握了规律后，对面试的具体情况进行把握，有意识地揣摩面试官提出问题的心理背景，然后投其所好。</p>
<p>分析：除非是薪资太低，或者是最初的工作，否则不要用薪资作为理由。“求发展”也被考官听得太多，离职理由要根据每个人的真实离职理由来设计，但是在回答时一定要表现得真诚。离职原因没有定式，要根据自己的情况以及应聘公司的情况灵活的去说，大概方向就是：合同到期，距离，技术，发展，公司经营不好，其他。</p>
<h2 id="四、你最大的缺点是什么？"><a href="#四、你最大的缺点是什么？" class="headerlink" title="四、你最大的缺点是什么？"></a>四、你最大的缺点是什么？</h2><p>被面试官问的概率很大，也是HR的杀手锏和狠招，这个问题最难回答，通常面试官不希望听到求职直接回答的缺点是什么，如果求职者说自己小心眼、脾气大、工作效率低，企业肯定不会录用你。不要自作聪明地回答“我最大的缺点就是过于追求完美”，有的人以为这样回答会显得自己比较出色，但事实上，他已经岌岌可危了。面试官喜欢求职者从自己的优点说起，中间加一些小缺点，最后再把问题转到优点上，突出优点的部分，面试官喜欢聪明的求职者。</p>
<p><strong>回答范例：</strong> 这个问题好难回答啊！我想想……（亲和力表现，也缓解了自己的紧张情绪）</p>
<p>我的缺点是比较执着，比如在技术方面比较爱钻研，有的时候会为一个技术问题加班到深夜。还有就是，工作比较按部就班，总是按照项目经管的要求完成任务。另外的缺点是，总在息的工作范围内有创新意识，并没有扩展给其他同事。这些问题我想我可以进入公司后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。我想就这些吧。</p>
<h2 id="五、你未来3-5年的职业规划是怎样的？"><a href="#五、你未来3-5年的职业规划是怎样的？" class="headerlink" title="五、你未来3-5年的职业规划是怎样的？"></a>五、你未来3-5年的职业规划是怎样的？</h2><p>大部分面试官司都会问你是否有职业规划，这个问题的背后是了解你的求职动机和对自己中长期职业发展的思考。在回答这个问题之前，要对自己有个清晰的认识，知道自己想往哪个方向发展以及未来有什么计划，要给面试官一种积极向上，好学上进，有追求，有规划的感觉，面试官喜欢有规划的求职者。</p>
<p><strong>回答范例：</strong> 我希望从现在开始，1-2年之内能够在我目前申请的这个职位上沉淀下来，通过不断的努力后，最好能有晋升，希望3-5年内可以做到（架构师、算法工程师、建模工程师或者做管理）。同时我也希望自己能够在企业的平台上得到进一步的职业能力提升。</p>
<h2 id="六、你对薪资的要求？"><a href="#六、你对薪资的要求？" class="headerlink" title="六、你对薪资的要求？"></a>六、你对薪资的要求？</h2><p>如果你对薪酬的要求太低，那显然贬低自己的能力；如果你对薪酬的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求职的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。</p>
<p><strong>回答范例一：</strong> 我对工资没有硬性要求，我相信贵公司在处理我的问题上会友善合理。我注重的是找对工作机会，所以只要条件公平，我则不会计较太多。</p>
<p>如果你必须自己说出具体数目，那就不要说一个宽泛的范围，不要说10000-13000之间，那样你将只会得到最低限底的数字，也就是10000。最好给出一个具体的数字。</p>
<h2 id="七、什么时候能入职？"><a href="#七、什么时候能入职？" class="headerlink" title="七、什么时候能入职？"></a>七、什么时候能入职？</h2><p>大多数企业会关心就职时间，最好是回答“如果被录用的话，到职日可按公司的规定上班”，如果还未辞去上一个工作，但上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。</p>
<h2 id="八、介绍一个你认为最熟悉的项目（项目经理）"><a href="#八、介绍一个你认为最熟悉的项目（项目经理）" class="headerlink" title="八、介绍一个你认为最熟悉的项目（项目经理）"></a>八、介绍一个你认为最熟悉的项目（项目经理）</h2><p>这个问题在技术面试时常被问到，问这个问题的意图是想考察你的成长路径和编程习惯，因为，你最熟悉的项目往往是你成长最快的项目，那个成长最快的项目往往会给你今后的编程习惯留下很多痕迹。所以，通过你对熟悉项目的描述，有经验的他会很快锁定你技术成长中的缺陷和闪光点，从而判断是否能够“为我所用”。</p>
<p>你最好拿出一个自己最擅长技术的那个项目进行介绍，他听完你的介绍后，会接下来进行提问，这样他所有问的问题，你都成竹在胸了。</p>
<p>切忌拿自己参与很少的项目来介绍，一旦他深入的询问很可能你会答非所问，反而造成更严重的影响。你大强以和他谈谈在那个项目中获得的经验，这样会引起此君的共鸣，有可能的话，说出一些你自己的小技巧，他会很高兴，同时这场面试也会很轻松，拿到Offer基本没问题了。</p>
<h2 id="九、如果公司录用你，你将怎样开展工作？"><a href="#九、如果公司录用你，你将怎样开展工作？" class="headerlink" title="九、如果公司录用你，你将怎样开展工作？"></a>九、如果公司录用你，你将怎样开展工作？</h2><p>很多企业在招聘开发人员时很看重是否能够尽快上手，所以回答这个问题时要“实打实”的回答，在回答中最好强调能够“尽快”投入开发工作中，这样领导就放心了，会觉得你不是一个只会盲目工作的人，而是一个按部就班，稳打稳扎的人。</p>
<p><strong>回答范例：</strong> 我对咱们公司的大体情况只有一个大概了解，在这个职位的工作性质仅仅是我自己的一个理解。作为这个职位而言，我想我首先要对本公司的主营业务要有一个了解，了解公司的业务组成部分、业务的发展方向、我们面向的客户性质等。第二我要了解所属部门在公司中的地位，以及部门的工作目标，从而确定自身的工作努力方向。第三，了解我参与项目的开发方式，架构方式，紧密配合领导工作，尽快投入具体的开发工作中。这就是我开展工作的计划。</p>
<h2 id="十、你还有什么问题问我吗？"><a href="#十、你还有什么问题问我吗？" class="headerlink" title="十、你还有什么问题问我吗？"></a>十、你还有什么问题问我吗？</h2><p>这个问题看上去可有可无，其实很关键，面试官不喜欢说“没有问题”的人，没有问题就是自寻死路，没有问题传达出你对公司缺乏兴趣，而只是来寻找一笔薪水。其实在面试过程中谦虚礼貌的问面试官怎么称呼，该部门工作中的信息，如项目情况，开发技术再或者说贵公司的晋升机制是什么样的等。表现出一种很积极主动的状态是非常讨巧的。也可以更多的了解到自己来的工作环境。企业很欢迎这样的求职者，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。这个要分析面试官的身份，如果是普通技术面试官，可以问问对方目前项目的规划，使用的技术情况，还有就是您在这边工作多久了，是否能分享一些您在这边的工作体会。如果是HR的话，可以问问公司的企业文化，工资评定是否跟绩效挂钩，公司是否定期组织员工活动、团建等等，如果是公司CEO或者是CTO的话，可以问问团队的组成和公司前景之类的。或者告诉面试官关于公司的部分情况通过查看公司网站，还有面试基本上了解了，比较喜欢咱们公司这个平台和氛围，希望有机会能加入一起共事，如果您这边觉得我合适的话，最快什么时间能给我回复。</p>
<h2 id="十一、社保问题"><a href="#十一、社保问题" class="headerlink" title="十一、社保问题"></a><strong>十一、社保问题</strong></h2><p>如果上家公司写的是外地公司的话，之前是否上过社保深圳这边是查不到的，而且都要重新上。如果上家写的深圳公司，之前确实没有上过的话，就说之前公司规模小，五险一金一直没有上，但是签了自动放弃的协议，公司也给一部分补偿金，金额大概1000左右。如果之前你在深圳上过一段时间的社保，跟现在写的工作经历对不上的话，就说之前公司不给上，有一段时间自己通过关系找了一家公司挂靠了一段时间。面试的时候如果HR问你之前在深圳是否上过社保，只要说是或者否就可以，不用主动说太多。对方问的话再解释。</p>
<h2 id="十二、上家公司薪资构成，及到手多少钱"><a href="#十二、上家公司薪资构成，及到手多少钱" class="headerlink" title="十二、上家公司薪资构成，及到手多少钱"></a><strong>十二、上家公司薪资构成，及到手多少钱</strong></h2><p>网上找税收计算器，把上家薪资输入自动算出扣税多少，再加上社保补偿金，就是你最后到手的工资，不用跟面试官说的特详细，只要说个大概就好。</p>
<h2 id="十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？"><a href="#十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？" class="headerlink" title="十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？"></a><strong>十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？</strong></h2><p>工作中难免会有些问题难以被彻底的解决，在这样的情况下，我会思考这样几个问题：我是否已经尽了全力，是否还有什么方法或什么人能够帮助我解决问题？我是否已经全面的思考过问题的方方面面，还是钻在死胡同里出不来？我是否能在目前情况下改善问题，哪怕只是较小程度的改善？有时一些小小的改善积累起来可能最终就能够解决问题。</p>
<p>我认为遇到问题的态度切忌慌乱，往往欲速则不达，因此要冷静下来思考。另外就是切记不停的抱怨，不停的抱怨不但会给人留下负面印象，甚至因为消极的态度错过了解决问题的最后机会。</p>
<p>点评：该求职者首先表现了他不会轻易放弃解决问题的态度，懂得从各个角度去思考问题，并且会努力到最后一刻。在表述自己遇到问题的态度方面，该求职者也表现的非常完美，冷静、不抱怨并积极处理问题是所有面试官都会欣赏的态度。</p>
<h2 id="十四、压力面试："><a href="#十四、压力面试：" class="headerlink" title="十四、压力面试："></a><strong>十四、压力面试：</strong></h2><p>随着企业竞争的激烈，员工的压力也越来越大，因此企业希望寻找到能够接受挑战、承担责任并能够抵抗压力的高素质人才。因此压力面试越来越多地应用到面试中。面试官会制造一种具有压力的紧张气氛，采用的方式包括：</p>
<p>1、打击求职者的自信心。对求职者的回答表示不满意，希望得到更佳的答案，并且始终不给于正面的反馈。</p>
<p>2、对于求职者的回答步步紧逼，不断的追问。求职者回答中的任何细节都会被不断的追问，细节上有任何不相符之处都可能引起质疑。</p>
<p>3、突然提出出乎意料的问题，或是非常难以回答的问题，并用沉默的方式等待求职者给出回答。</p>
<p>其实，压力面试只是一种特殊形式的行为面试，无需感到恐慌，所需要做的只是冷静、冷静</p>
<p>再冷静。无论对方提出的问题有多刁难，要保持冷静的应答，如果遇到实在无法继续回答的情况，可以将皮球踢回给面试官，例如面对微笑的反问：我在这个方面确实并不清楚或者接触的少，非常希望能够得到您的指导，或者您遇到这种情况该怎么处理。在压力面试中，面试官需要考察的是求职者面对压力的处理能力，而不仅是那些不合理问题的答案。有的面试官故意出一些难题，打击你的自信心，让你在要薪资的时候不敢多要。因此，放松心态，做足准备面对即可。</p>
<h2 id="十五、电话面试："><a href="#十五、电话面试：" class="headerlink" title="十五、电话面试："></a>十五、<strong>电话面试：</strong></h2><p>1、避免没有重音、没有语音语调，这样会让听者变得非常的沉闷，甚至错过所需要留意的内容。</p>
<p>2、由于没有目光的接触以及肢体语言等辅助沟通手段，因此求职者必须把自己的回答尽可能整理的比较有逻辑，条理清晰，事例具体，否则很难给面试官留下深刻的印象。</p>
<p>3、由于电话面试常常应用于初期审核阶段，如果不能够较快抓住面试官的注意，面试官可能未必会花太多的时间去了解你，因此需要力求尽快地抓住面试官的注意。</p>
<h2 id="十六、你对加班的看法？"><a href="#十六、你对加班的看法？" class="headerlink" title="十六、你对加班的看法？"></a><strong>十六、你对加班的看法？</strong></h2><p>实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。</p>
<p>回答范例：如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。</p>
<h2 id="十七、你朋友对你的评价？"><a href="#十七、你朋友对你的评价？" class="headerlink" title="十七、你朋友对你的评价？"></a><strong>十七、你朋友对你的评价？</strong></h2><p><strong>回答提示：</strong> 想从侧面了解一下你的性格及与人相处的问题。</p>
<p><strong>回答样本一：</strong> 我的朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。</p>
<p><strong>回答样本二：</strong> 我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。</p>
<h2 id="十八、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"><a href="#十八、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？" class="headerlink" title="十八、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？"></a><strong>十八、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</strong></h2><p><strong>回答提示：</strong> 一段时间发现工作不适合我，有两种情况：</p>
<p>1、如果你确实热爱这个职业，那你就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；</p>
<p>2、你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。</p>
<h2 id="十九、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"><a href="#十九、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？" class="headerlink" title="十九、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？"></a><strong>十九、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</strong></h2><p><strong>回答提示：</strong> ①.原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③.还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。</p>
<h2 id="二十、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"><a href="#二十、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？" class="headerlink" title="二十、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？"></a><strong>二十、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</strong></h2><p><strong>回答提示：</strong> ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同完成工作，安慰同事并且帮助同事查找原因总结经验。</p>
<p>③总结经验教训，一个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、分析问题的深度和力度是否不够，以致出现了本可以避免的错误。</p>
<h2 id="二十一、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"><a href="#二十一、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？" class="headerlink" title="二十一、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？"></a><strong>二十一、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</strong></h2><p><strong>回答提示：</strong> 我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。</p>
<h2 id="二十二、谈谈你对跳槽的看法？"><a href="#二十二、谈谈你对跳槽的看法？" class="headerlink" title="二十二、谈谈你对跳槽的看法？"></a><strong>二十二、谈谈你对跳槽的看法？</strong></h2><p><strong>回答提示：</strong> ①正常的“跳槽”能促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。</p>
<h2 id="二十三、工作中你难以和同事、上司相处，你该怎么办？"><a href="#二十三、工作中你难以和同事、上司相处，你该怎么办？" class="headerlink" title="二十三、工作中你难以和同事、上司相处，你该怎么办？"></a><strong>二十三、工作中你难以和同事、上司相处，你该怎么办？</strong></h2><p><strong>回答提示：</strong> ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好让领导不满意，同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话 我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我在努力，总有一天会对我微笑的。</p>
<h2 id="二十四、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"><a href="#二十四、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？" class="headerlink" title="二十四、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？"></a><strong>二十四、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</strong></h2><p><strong>回答提示：</strong> ①成绩比较突出，得到领导的肯定是件好事情，以后更加努力。②检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。③工作中，切勿伤害别人的自尊心。④不再领导前拨弄是非。</p>
<h2 id="二十五、你对于我们公司了解多少？"><a href="#二十五、你对于我们公司了解多少？" class="headerlink" title="二十五、你对于我们公司了解多少？"></a><strong>二十五、你对于我们公司了解多少？</strong></h2><p><strong>回答提示：</strong> 在去公司面试前上网查一下该公司主营业务。如回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过5海外经销商。</p>
<h2 id="二十六、请说出你选择这份工作的动机？"><a href="#二十六、请说出你选择这份工作的动机？" class="headerlink" title="二十六、请说出你选择这份工作的动机？"></a><strong>二十六、请说出你选择这份工作的动机？</strong></h2><p><strong>回答提示：</strong> 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。</p>
<h2 id="二十七、你最擅长的技术方向是什么？"><a href="#二十七、你最擅长的技术方向是什么？" class="headerlink" title="二十七、你最擅长的技术方向是什么？"></a><strong>二十七、你最擅长的技术方向是什么？</strong></h2><p><strong>回答提示：</strong> 说和你要应聘的职位相关的课程，表现一下自己的热诚没有什么坏处。</p>
<h2 id="二十八、你能为我们公司带来什么呢？"><a href="#二十八、你能为我们公司带来什么呢？" class="headerlink" title="二十八、你能为我们公司带来什么呢？"></a><strong>二十八、你能为我们公司带来什么呢？</strong></h2><p><strong>回答提示：</strong> 技术、能力、人脉。</p>
<h2 id="二十九、最能概括你自己的三个词是什么？"><a href="#二十九、最能概括你自己的三个词是什么？" class="headerlink" title="二十九、最能概括你自己的三个词是什么？"></a><strong>二十九、最能概括你自己的三个词是什么？</strong></h2><p><strong>回答提示：</strong> 我经常用的三个词是：适应能力强，有责任心和做事有始终，结合具体例子向主考官解释，</p>
<h2 id="三十、你的业余爱好是什么？"><a href="#三十、你的业余爱好是什么？" class="headerlink" title="三十、你的业余爱好是什么？"></a><strong>三十、你的业余爱好是什么？</strong></h2><p><strong>回答提示：</strong> 找一些富于团体合作精神的，这里有一个真实的故事：有人被否决掉，因为他的爱好是深海潜水。主考官说：因为这是一项单人活动，我不敢肯定他能否适应团体工作。多说团体合作，爱浏览技术网站、博客、书籍。最好提前想好最近在看那本书，看到了哪个部分。</p>
<h2 id="三十一、作为被面试者给我打一下分？"><a href="#三十一、作为被面试者给我打一下分？" class="headerlink" title="三十一、作为被面试者给我打一下分？"></a><strong>三十一、作为被面试者给我打一下分？</strong></h2><p><strong>回答提示：</strong> 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。</p>
<h2 id="三十二、你怎么理解你应聘的职位？"><a href="#三十二、你怎么理解你应聘的职位？" class="headerlink" title="三十二、你怎么理解你应聘的职位？"></a><strong>三十二、你怎么理解你应聘的职位？</strong></h2><p><strong>回答提示：</strong> 把岗位职责和任务及工作态度阐述一下。</p>
<h2 id="三十三、喜欢这份工作的哪一点？"><a href="#三十三、喜欢这份工作的哪一点？" class="headerlink" title="三十三、喜欢这份工作的哪一点？"></a><strong>三十三、喜欢这份工作的哪一点？</strong></h2><p><strong>回答提示：</strong> 相信其实大家心中一定都有答案了吧！每个人的价值观不同，自然评断的标准也会不同，但是，在回答面试官这个问题时可不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。</p>
<h2 id="三十四、说说你对行业、技术发展趋势的看法？"><a href="#三十四、说说你对行业、技术发展趋势的看法？" class="headerlink" title="三十四、说说你对行业、技术发展趋势的看法？"></a><strong>三十四、说说你对行业、技术发展趋势的看法？</strong></h2><p><strong>回答提示：</strong> 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。</p>
<h2 id="三十五、说你的家庭？"><a href="#三十五、说你的家庭？" class="headerlink" title="三十五、说你的家庭？"></a><strong>三十五、说你的家庭？</strong></h2><p><strong>回答提示：</strong> 企业面试时询问家庭问题不是非要知道求职者家庭的情况，探究隐私，企业不喜欢探究个人隐私，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。企业最喜欢听到的是：我很爱我的家庭，我的家庭一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。企业相信，和睦的家庭关系对一个人的成长有潜移默化的影响。</p>
<h2 id="三十六、就你申请的这个职位，你认为你还欠缺什么？"><a href="#三十六、就你申请的这个职位，你认为你还欠缺什么？" class="headerlink" title="三十六、就你申请的这个职位，你认为你还欠缺什么？"></a><strong>三十六、就你申请的这个职位，你认为你还欠缺什么？</strong></h2><p><strong>回答提示：</strong> 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。他们希望看到这样的求职者：继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题我想我可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。”企业喜欢能够巧妙地躲过难题的求职者。</p>
<h2 id="三十七、你欣赏哪种性格的人？"><a href="#三十七、你欣赏哪种性格的人？" class="headerlink" title="三十七、你欣赏哪种性格的人？"></a><strong>三十七、你欣赏哪种性格的人？</strong></h2><p><strong>回答提示：</strong> 诚实、不死板而且容易相处的人、有“实际行动”的人。</p>
<h2 id="三十八、你通常如何处理別人的批评？"><a href="#三十八、你通常如何处理別人的批评？" class="headerlink" title="三十八、你通常如何处理別人的批评？"></a><strong>三十八、你通常如何处理別人的批评？</strong></h2><p><strong>回答提示：</strong> ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷靜下来再讨论。</p>
<h2 id="三十九、你为什么愿意到我们公司来工作？"><a href="#三十九、你为什么愿意到我们公司来工作？" class="headerlink" title="三十九、你为什么愿意到我们公司来工作？"></a><strong>三十九、你为什么愿意到我们公司来工作？</strong></h2><p><strong>回答提示：</strong> 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因，像“公司本身的高技术开发环境很吸引我。”、“我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。”、“你们公司一直都稳定发展，在近几年来在市场上很有竞争力。”、“我认为贵公司能够给我提供一个与众不同的发展道路。”这都显示出你已经做了一些调查，也说明你对自己的未来有了较为具体的远景规划。</p>
<h2 id="四十、你和别人发生过争执吗？你是怎样解决的？"><a href="#四十、你和别人发生过争执吗？你是怎样解决的？" class="headerlink" title="四十、你和别人发生过争执吗？你是怎样解决的？"></a><strong>四十、你和别人发生过争执吗？你是怎样解决的？</strong></h2><p><strong>回答提示：</strong> 这是面试中最险恶的问题，其实是考官布下的一个陷阱，千万不要说任何人的过错，应知成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的一个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。</p>
<h2 id="四十一、你做过的哪件事最令自己感到骄傲？"><a href="#四十一、你做过的哪件事最令自己感到骄傲？" class="headerlink" title="四十一、你做过的哪件事最令自己感到骄傲？"></a><strong>四十一、你做过的哪件事最令自己感到骄傲？</strong></h2><p><strong>回答提示：</strong> 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去午餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。</p>
<h2 id="四十二、对这项工作，你有哪些可预见的困难？"><a href="#四十二、对这项工作，你有哪些可预见的困难？" class="headerlink" title="四十二、对这项工作，你有哪些可预见的困难？"></a><strong>四十二、对这项工作，你有哪些可预见的困难？</strong></h2><p><strong>回答提示：</strong> ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度——工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。</p>
<p><strong>分析：</strong> 一般问这个问题，面试者的希望就比较大了，因为已经在谈工作细节，但常规思路中的回答，又被面试官“骗”了。当面试官询问这个问题的时候，有两个目的。第一，看看应聘者是不是在行，说出的困难是不是在这个职位中一般都不可避免的问题。第二，是想看一下应聘者解决困难的手法对不对，及公司能否提供这样的资源。而不是想了解应聘者对困难的态度。</p>
<h2 id="四十三、怎样对待自己的失敗？"><a href="#四十三、怎样对待自己的失敗？" class="headerlink" title="四十三、怎样对待自己的失敗？"></a><strong>四十三、怎样对待自己的失敗？</strong></h2><p><strong>回答提示：</strong> 我们大家生来都不是十全十美的，我相信我有第二个机会改正我的错误。</p>
<h3 id="四十四、什么会让你有成就感？"><a href="#四十四、什么会让你有成就感？" class="headerlink" title="四十四、什么会让你有成就感？"></a><strong>四十四、什么会让你有成就感？</strong></h3><p><strong>回答提示：</strong> 为贵公司竭力效劳，尽我所能，完成一个项目。</p>
<h3 id="四十五、眼下你生活中最重要的是什么？"><a href="#四十五、眼下你生活中最重要的是什么？" class="headerlink" title="四十五、眼下你生活中最重要的是什么？"></a><strong>四十五、眼下你生活中最重要的是什么？</strong></h3><p><strong>回答提示：</strong> 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。</p>
<h3 id="四十六、与上级意见不一是，你将怎么办？"><a href="#四十六、与上级意见不一是，你将怎么办？" class="headerlink" title="四十六、与上级意见不一是，你将怎么办？"></a><strong>四十六、与上级意见不一是，你将怎么办？</strong></h3><p><strong>回答提示：</strong> ①一般可以这样回答“我会给上级以必要的解释和提醒，在这种情况下，我会服从上级的意见。”②如果面试你的是总经理，而你所应聘的职位另有一位经理，且这位经理当时不在场，可以这样回答：“对于非原则性问题，我会服从上级的意见，对于涉及公司利益的重大问题，我希望能向更高层领导反映。”</p>
<p><strong>分析：</strong> 这个问题的标准答案是思路①，如果用②的回答，必死无疑。你没有摸清楚改公司的内部情况，先想打小报告，这样的人没有人敢要。</p>
<h3 id="四十七、你工作经验欠缺，如何能胜任这项工作？"><a href="#四十七、你工作经验欠缺，如何能胜任这项工作？" class="headerlink" title="四十七、你工作经验欠缺，如何能胜任这项工作？"></a><strong>四十七、你工作经验欠缺，如何能胜任这项工作？</strong></h3><p><strong>常规思路：</strong> ①如果招聘单位对应聘者提出这个问题，说明招聘公司并不真正在乎“经验”，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。③如“在项目经验方面的确会有所欠缺，但我有较强的责任心、适应能力和学习能力，而且比较勤奋，在上家公司无论遇到什么困难都能想办法完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，我一定能胜任这个职位。”</p>
<p><strong>点评：</strong> 这个问题思路中的答案尚可，突出自己的吃苦能力和适应性以及学习能力（不是学习成绩）为好。</p>
<h3 id="四十八、你希望与什么样的上级共事？"><a href="#四十八、你希望与什么样的上级共事？" class="headerlink" title="四十八、你希望与什么样的上级共事？"></a><strong>四十八、你希望与什么样的上级共事？</strong></h3><p><strong>回答提示：</strong> ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。③如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。</p>
<p><strong>分析：</strong> 这个问题比较好的回答是，希望我的上级能够在工作中对我多指导，对我工作中的错误能够立即指出。总之，从上级指导这个方面谈，不会有大的纰漏。</p>
<h3 id="四十九、谈谈如何适应办公室工作的新环境？"><a href="#四十九、谈谈如何适应办公室工作的新环境？" class="headerlink" title="四十九、谈谈如何适应办公室工作的新环境？"></a><strong>四十九、谈谈如何适应办公室工作的新环境？</strong></h3><p><strong>回答提示：</strong> ①办公室里每个人有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。</p>
<h3 id="五十、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"><a href="#五十、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？" class="headerlink" title="五十、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？"></a><strong>五十、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</strong></h3><p><strong>回答提示：</strong> 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些人明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。</p>
<h3 id="五十一、如果你在这次面试中没有被录用，你怎么打算？"><a href="#五十一、如果你在这次面试中没有被录用，你怎么打算？" class="headerlink" title="五十一、如果你在这次面试中没有被录用，你怎么打算？"></a><strong>五十一、如果你在这次面试中没有被录用，你怎么打算？</strong></h3><p><strong>回答提示：</strong> 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和精神上体现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距。正确对待自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，要克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④再接再厉，能进入像贵公司这样的平台一直是我的梦想，以后如果有机会我仍然后再次参加竞争。</p>
<h3 id="五十二、谈谈你过去做过的成功案例？"><a href="#五十二、谈谈你过去做过的成功案例？" class="headerlink" title="五十二、谈谈你过去做过的成功案例？"></a><strong>五十二、谈谈你过去做过的成功案例？</strong></h3><p><strong>回答提示：</strong> 举一个你最有把握的例子，把来龙去脉说清楚，而不要说了很多却没有重点。切忌夸大其词，把别人的功劳到说成自己的，很多主管为了确保要用的人是最适合的，会打电话向你的前一个主管征询对你的看法及意见，所以如果说谎，是很容易穿梆的。</p>
<h3 id="五十三、谈谈你过去的工作经验中，最令你挫折的事情？"><a href="#五十三、谈谈你过去的工作经验中，最令你挫折的事情？" class="headerlink" title="五十三、谈谈你过去的工作经验中，最令你挫折的事情？"></a><strong>五十三、谈谈你过去的工作经验中，最令你挫折的事情？</strong></h3><p><strong>回答提示：</strong> 可以在网上查查其他人在开发过程中会出现哪些问题，最后是怎么解决的。</p>
<p><strong>分析：</strong> 借此了解你对挫折的容忍度及调解方式。</p>
<p><strong>分析：</strong> 虽然不会有人心甘情愿的加班，但依旧要表现出高配合度的诚意。</p>
<h3 id="五十四、为什么我们要在众多的面试者中选择你？"><a href="#五十四、为什么我们要在众多的面试者中选择你？" class="headerlink" title="五十四、为什么我们要在众多的面试者中选择你？"></a><strong>五十四、为什么我们要在众多的面试者中选择你？</strong></h3><p><strong>回答提示：</strong> 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、ＥＱ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。</p>
<p><strong>分析：</strong> 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。</p>
<h3 id="五十五、你并非毕业于名牌院校？"><a href="#五十五、你并非毕业于名牌院校？" class="headerlink" title="五十五、你并非毕业于名牌院校？"></a><strong>五十五、你并非毕业于名牌院校？</strong></h3><p><strong>回答提示：</strong> 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我想我更适合贵公司这个职位。</p>
<h3 id="五十六、怎样看待学历和能力？"><a href="#五十六、怎样看待学历和能力？" class="headerlink" title="五十六、怎样看待学历和能力？"></a><strong>五十六、怎样看待学历和能力？</strong></h3><p><strong>回答提示：</strong> 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果贵公司把学历卡在博士上，我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢？</p>
<h3 id="五十七、工作中学习到了些什么？"><a href="#五十七、工作中学习到了些什么？" class="headerlink" title="五十七、工作中学习到了些什么？"></a><strong>五十七、工作中学习到了些什么？</strong></h3><p><strong>回答提示：</strong> 这是针对转职者提出的问题，建议此时可以配合面试工作的特点作为主要依据来回答，如业务工作需要与人沟通，便可举出之前工作与人沟通的例子，经历了哪些困难，学习到哪些经验，把握这些要点做陈述，就可以轻易过关了。</p>
<h3 id="五十八、想过创业吗？"><a href="#五十八、想过创业吗？" class="headerlink" title="五十八、想过创业吗？"></a><strong>五十八、想过创业吗？</strong></h3><p><strong>回答提示：</strong> 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢？</p>
<h3 id="五十九、除了本公司外，还应聘了哪些公司？"><a href="#五十九、除了本公司外，还应聘了哪些公司？" class="headerlink" title="五十九、除了本公司外，还应聘了哪些公司？"></a><strong>五十九、除了本公司外，还应聘了哪些公司？</strong></h3><p><strong>回答提示：</strong> 很奇怪，这是相当多公司会问的问题，其用意是要概略知道应徵者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“类似的公司（互联网）”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。</p>
<h3 id="六十、面试注意事项："><a href="#六十、面试注意事项：" class="headerlink" title="六十、面试注意事项："></a>六十、面试注意事项：</h3><p>1，在面试官面前千万不要抖脚，手脚不要动来动去，不能有小动作。</p>
<p>2，在面试过程中，千万不要跟面试官去争论，说话太冲，太能说、抢话说、乱说都不好，遇到难题，先思考一下，切记心浮气燥，表达时口气温和，谦虚。</p>
<p>3，如果面试过程中都不错，谈的也很好，之后却没有给Offer，完全是自己意料之外的情况，这个很有可能，或许是因为公司有了其他的人选，不用介意，更不要沮丧。</p>
<p>4，在面试过程中，切忌问关于公司计划、行业机密等相关的东西，不要打探公司的内幕，机密敏感性的问题不要问东问西。</p>
<p>5，千万要注意仪容仪表，要有礼貌，最好不要有口吃，口头表达，逻辑思维很重要，不要让面试官觉得你很幼稚，太过小孩子气，显的不够稳重踏实。</p>
<p>6，在去面试之前，要熟悉自己的简历，特别是工作经历，准备好关于一些离职原因、职业规划方面的问题的回答方式。</p>
<p>7，在面试过程中，80%的面试官会让做自我介绍，所以提前要准备一下，说出的内容既要和简历相符，又要有重点有突出的地方，不能像背简历一样。</p>
<p>8，面试完后，如果等待的时间较长，没有回应，就可能没有什么希望了，自己可以打电话去了解情况。</p>
<p>9，在面试过程中，谈到薪资的时候，如果没有说明是税后工资就是税前，假如是税前6000，这里面就包括了公司给交的公积金，还有其他五险要交的费用，拿到手差不多4000左右。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">lyon ai</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/')">八股文详细版</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=八股文详细版&amp;url=http://example.com/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/&amp;pic=https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Lyon`s Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/Java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Java<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>八股文<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>后端<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>网络编程<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>多线程<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据库<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>设计模式<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>计算机网络<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>场景题<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>尚硅谷<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/03/24/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/"><img class="prev-cover" src="https://img.090227.xyz/file/ae62475a131f3734a201c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">这是一篇新的博文</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/03/24/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="常见面试题"><img class="cover" src="https://img.090227.xyz/file/ae62475a131f3734a201c.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-03-24</div><div class="title">常见面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description">这是lyonai的博客</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">lyon ai</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/lyonai" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/397839784?spm_id_from=333.1007.0.0" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="card-widget calendar" id="card-widget-calendar"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="calendar-area-left">
  <div id="calendar-week"></div>
  <div id="calendar-date" style="font-size: 48px;"></div>
  <div id="calendar-solar"></div>
  <div id="calendar-lunar"></div>
</div>
<div id="calendar-area-right">
  <div id="calendar-main">
  </div>
</div>
</div></div><div class="card-widget schedule" id="card-widget-schedule"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="schedule-area-left">
  <div id="schedule-title">距离除夕</div>
  <div id="schedule-days"></div>
  <div id="schedule-date">2025-01-28</div>
</div>
<div id="schedule-area-right">
  <div class="schedule-r0">
    <div class="schedule-d0">本年</div>
    <div class="schedule-d1">
      <span id="p_span_year" class="aside-span1"></span>
      <span class="aside-span2">还剩<a></a>天</span>
      <progress max="365" id="pBar_year"></progress>
    </div>
  </div>
  <div class="schedule-r1">
    <div class="schedule-d0">本月</div>
    <div class="schedule-d1">
      <span id="p_span_month" class="aside-span1"></span>
      <span class="aside-span2">还剩<a></a>天</span>
      <progress max="30" id="pBar_month"></progress>
    </div>
  </div>
  <div class="schedule-r2">
    <div class="schedule-d0">本周</div>
    <div class="schedule-d1">
      <span id="p_span_week" class="aside-span1"></span>
      <span class="aside-span2">还剩<a></a>天</span>
      <progress max="7" id="pBar_week"></progress>
    </div>
  </div>
</div>
</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80-100"><span class="toc-number">1.</span> <span class="toc-text">Java基础 100%</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVASE"><span class="toc-number">1.1.</span> <span class="toc-text">JAVASE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%86%99%E5%87%BAJava%E7%9A%84%E5%9B%9B%E7%B1%BB%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、写出Java的四类八种基本数据类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB-x20"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、&amp; 和 &amp;&amp; 的区别 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81switch%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、switch的参数可以是什么类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%B4%E5%87%BA%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、说出实例变量和局部变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E9%83%BD%E8%83%BD%E4%BF%AE%E9%A5%B0%E4%BB%80%E4%B9%88%EF%BC%9F-%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.5.</span> <span class="toc-text">5、static关键字都能修饰什么？ 都有什么特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81overload%E5%92%8Coverride%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.6.</span> <span class="toc-text">6、overload和override的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-final-%E5%92%8C-finally%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.7.</span> <span class="toc-text">7、 final 和 finally的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81-this%E5%92%8Csuper%E9%83%BD%E8%83%BD%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9"><span class="toc-number">1.1.8.</span> <span class="toc-text">8、 this和super都能用到哪些地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.</span> <span class="toc-text">9、 接口与抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.10.</span> <span class="toc-text">10、 静态变量与实例变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81throw%E5%92%8Cthrows-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.11.</span> <span class="toc-text">11、throw和throws 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81String-StringBuilder-%E4%B8%8E-StringBuffer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.12.</span> <span class="toc-text">12、String,StringBuilder 与 StringBuffer 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81-%E5%92%8C-equals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.13.</span> <span class="toc-text">13、 &#x3D;&#x3D; 和 equals的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1"><span class="toc-number">1.1.14.</span> <span class="toc-text">14、包装类拆箱装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">1.1.15.</span> <span class="toc-text">15、异常结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81-HashSet-%E7%9A%84%E5%8E%BB%E9%87%8D%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.16.</span> <span class="toc-text">16、 HashSet 的去重原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.17.</span> <span class="toc-text">17、集合与数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.18.</span> <span class="toc-text">18、多线程的五种实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.19.</span> <span class="toc-text">19、多线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81TreeSet%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.20.</span> <span class="toc-text">20、TreeSet和HashSet的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E6%89%80%E5%AD%A6%E4%B9%A0%E7%9A%84io%E6%B5%81%E4%B8%80%E5%85%B1%E5%88%86%E4%B8%BA%E5%87%A0%E7%B1%BB"><span class="toc-number">1.1.21.</span> <span class="toc-text">21、所学习的io流一共分为几类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81map%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.22.</span> <span class="toc-text">22、map的三种遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81HashMap%E4%B8%8EHashTable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.23.</span> <span class="toc-text">23、HashMap与HashTable 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.24.</span> <span class="toc-text">24、ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">1.1.25.</span> <span class="toc-text">25、什么是反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.1.26.</span> <span class="toc-text">26、深拷贝和浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%B4%E5%87%BA%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、Java集合框架是什么?说出集合框架的一些优点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、集合接口的常见实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81List%E5%92%8CMap%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、List和Map区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81List%E3%80%81Map%E3%80%81Set%E4%B8%89%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AD%98%E5%8F%96%E5%85%83%E7%B4%A0%E6%97%B6%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、List、Map、Set三个接口，存取元素时，各有什么特点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88Map%E6%8E%A5%E5%8F%A3%E4%B8%8D%E7%BB%A7%E6%89%BFCollection%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.5.</span> <span class="toc-text">5、为什么Map接口不继承Collection接口?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Iterator%E5%92%8CListIterator%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">6、Iterator和ListIterator之间有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.7.</span> <span class="toc-text">7、集合框架中的泛型有什么优点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Map%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E9%9B%86%E5%90%88%E8%A7%86%E5%9B%BE"><span class="toc-number">1.2.8.</span> <span class="toc-text">8、Map接口提供了哪些不同的集合视图?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81jdk1-7HashMap"><span class="toc-number">1.2.9.</span> <span class="toc-text">9、jdk1.7HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81jdk1-8HashMap"><span class="toc-number">1.2.10.</span> <span class="toc-text">10、jdk1.8HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81JDK8%E4%B8%AD%E7%9A%84HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">1.2.11.</span> <span class="toc-text">11、JDK8中的HashMap为什么要使用红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81JDK8%E4%B8%AD%E7%9A%84HashMap%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%B0%86%E9%93%BE%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">1.2.12.</span> <span class="toc-text">12、JDK8中的HashMap什么时候将链表转化为红黑树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81JDK7%E4%B8%8EJDK8%E4%B8%ADHashMap%E7%9A%84%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-number">1.2.13.</span> <span class="toc-text">13、JDK7与JDK8中HashMap的不同点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81jdk1-7ConcurrentHashMap"><span class="toc-number">1.2.14.</span> <span class="toc-text">14、jdk1.7ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81jdk1-8ConcurrentHashMap"><span class="toc-number">1.2.15.</span> <span class="toc-text">15、jdk1.8ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81jdk1-7ConcurrentHashMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.16.</span> <span class="toc-text">16、jdk1.7ConcurrentHashMap如何保证并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81jdk1-8ConcurrentHashMap%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91"><span class="toc-number">1.2.17.</span> <span class="toc-text">17、jdk1.8ConcurrentHashMap如何保证并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%AB%98%E7%BA%A7-%E5%BB%BA%E8%AE%AE%E4%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">Java高级-建议会</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">2.1.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%91%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%9F%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">１、说一下JVM的主要组成部分？及其作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%9F"><span class="toc-number">2.1.2.</span> <span class="toc-text">2、说一下JVM运行时数据区？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">3、什么是类加载器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.4.</span> <span class="toc-text">4、双亲委派模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%95%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.1.5.</span> <span class="toc-text">５、说一下类装载的执行过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%96%E3%80%81%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">2.1.6.</span> <span class="toc-text">６、怎么判断对象是否可以被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots"><span class="toc-number">2.1.7.</span> <span class="toc-text">7、哪些对象可以作为GC-Roots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Java%E4%B8%AD%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.1.8.</span> <span class="toc-text">8、Java中都有哪些引用类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">2.1.9.</span> <span class="toc-text">9、说一下JVM有哪些垃圾回收算法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">2.1.10.</span> <span class="toc-text">10、说一下JVM有哪些垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BCMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">2.1.11.</span> <span class="toc-text">11、详细介绍一下CMS垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.1.12.</span> <span class="toc-text">12、新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E7%AE%80%E8%BF%B0%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">2.1.13.</span> <span class="toc-text">13、简述分代垃圾回收器是怎么工作的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.14.</span> <span class="toc-text">14、垃圾回收器的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="toc-number">2.1.15.</span> <span class="toc-text">15、三色标记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C-%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%EF%BC%88IU%EF%BC%89"><span class="toc-number">2.1.15.1.</span> <span class="toc-text">写屏障 + 增量更新（IU）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C-%E5%8E%9F%E5%A7%8B%E5%BF%AB%E7%85%A7%EF%BC%88SATB%EF%BC%89"><span class="toc-number">2.1.15.2.</span> <span class="toc-text">写屏障 + 原始快照（SATB）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">2.1.16.</span> <span class="toc-text">16、说一下JVM调优的工具？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.1.17.</span> <span class="toc-text">17、常用的JVM调优的参数都有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%BD%A0%E8%83%BD%E4%BF%9D%E8%AF%81GC%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.18.</span> <span class="toc-text">18、你能保证GC执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96Java%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%EF%BC%9F%E5%A0%86%E4%BD%BF%E7%94%A8%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%EF%BC%9F"><span class="toc-number">2.1.19.</span> <span class="toc-text">19、怎么获取Java程序使用的内存？堆使用的百分比？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">1 、什么是设计模式？有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%847%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2、 设计模式的7大基本原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%81%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">3 、使用哪种设计模式可以提高代码可维护性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%AF%E4%BB%A5%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%8D%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text">4、 使用哪种设计模式可以提高代码的复用性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E3%80%81%E4%BD%A0%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">2.2.5.</span> <span class="toc-text">5 、你在工作中是如何使用设计模式的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">6、单例模式的多种写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-%E5%A6%82%E4%BD%95%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.2.7.</span> <span class="toc-text">7、 如何破坏单例模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%9E%9A%E4%B8%BE%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.2.8.</span> <span class="toc-text">8 、为什么说枚举是实现单例最好的方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%94%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-number">2.2.9.</span> <span class="toc-text">9 、不使用锁如何实现线程安全的单例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">2.2.10.</span> <span class="toc-text">10、什么是享元模式，有哪些具体应用？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%A1%86%E6%9E%B6-%E2%80%93%E5%BF%85%E4%BC%9A100"><span class="toc-number">3.</span> <span class="toc-text">Java框架 –必会100%</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis"><span class="toc-number">3.1.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Mybatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、Mybatis中#和$的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Mybatis%E7%9A%84%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、Mybatis的编程步骤是什么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81JDBC%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84%EF%BC%8CMyBatis%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8MyBatis%E7%9A%84mapper%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">3.1.4.</span> <span class="toc-text">4、使用MyBatis的mapper接口调用时有哪些要求？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Mybatis%E4%B8%AD%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B8%8E%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">5、Mybatis中一级缓存与二级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81MyBatis%E5%9C%A8insert%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E6%97%B6%E5%A6%82%E4%BD%95%E8%BF%94%E5%9B%9E%E4%B8%BB%E9%94%AEID%EF%BC%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">6、MyBatis在insert插入操作时如何返回主键ID？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E8%BF%B0-Mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="toc-number">3.1.7.</span> <span class="toc-text">7、简述 Mybatis 的插件运行原理，如何编写一个插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E3%80%81SpringMVC%E3%80%81SpringBoot"><span class="toc-number">3.2.</span> <span class="toc-text">Spring、SpringMVC、SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-Spring-IOC-%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 什么是 Spring IOC 容器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASpring%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 如何实现一个Spring容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%8C%E6%88%90%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 什么是依赖注入？可以通过多少种方式完成依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-BeanFactory-%E5%92%8C-ApplicationContext%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. BeanFactory 和 ApplicationContext的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5%E5%92%8C-setter-%E6%B3%A8%E5%85%A5"><span class="toc-number">3.2.5.</span> <span class="toc-text">5. 构造函数注入和 setter 注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-spring-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.2.6.</span> <span class="toc-text">6. spring 提供了哪些配置方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Spring-%E4%B8%AD%E7%9A%84-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.2.7.</span> <span class="toc-text">7. Spring 中的 bean 的作用域有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B7%B1%E5%85%A5%E8%B0%88%E8%B0%88%E5%AF%B9Ioc%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.2.8.</span> <span class="toc-text">8. 深入谈谈对Ioc的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BASpring%E7%9A%84-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.2.9.</span> <span class="toc-text">9. 将一个类声明为Spring的 bean 的注解有哪些?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Spring-%E4%B8%AD%E7%9A%84-bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.10.</span> <span class="toc-text">10. Spring 中的 bean 生命周期?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AFbean%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.2.11.</span> <span class="toc-text">11.什么是bean的自动装配，有哪些方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Spring%E4%B8%AD%E5%87%BA%E7%8E%B0%E5%90%8C%E5%90%8Dbean%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.2.12.</span> <span class="toc-text">12. Spring中出现同名bean怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Spring-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.2.13.</span> <span class="toc-text">13. Spring 怎么解决循环依赖问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">3.2.13.1.</span> <span class="toc-text">什么是循环依赖:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">3.2.13.2.</span> <span class="toc-text">如何解决循环依赖：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Spring-%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B-bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.2.14.</span> <span class="toc-text">14. Spring 中的单例 bean 的线程安全问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF-AOP%EF%BC%9F"><span class="toc-number">3.2.15.</span> <span class="toc-text">15. 什么是 AOP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E8%B0%88%E8%B0%88%E5%AF%B9Aop%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.2.16.</span> <span class="toc-text">16. 谈谈对Aop的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-AOP-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.2.17.</span> <span class="toc-text">17. AOP 有哪些实现方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.2.18.</span> <span class="toc-text">18. Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.19.</span> <span class="toc-text">19. Spring 事务实现方式有哪些以及原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.2.20.</span> <span class="toc-text">20. Spring事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-Spring%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A7%84%E5%88%99"><span class="toc-number">3.2.21.</span> <span class="toc-text">21. Spring事务定义的传播规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">3.2.22.</span> <span class="toc-text">22. Spring事务什么时候会失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-SpringMVC-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">3.2.23.</span> <span class="toc-text">23. SpringMVC 工作原理了解吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D-Spring-MVC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.24.</span> <span class="toc-text">24. 简单介绍 Spring MVC 的核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Controller-%E6%B3%A8%E8%A7%A3%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">3.2.25.</span> <span class="toc-text">25. @Controller 注解有什么用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-RestController-%E5%92%8C-Controller-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.26.</span> <span class="toc-text">26. @RestController 和 @Controller 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-RequestMapping-%E5%92%8C-GetMapping-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.2.27.</span> <span class="toc-text">27. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-RequestParam-%E5%92%8C-PathVariable-%E4%B8%A4%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.28.</span> <span class="toc-text">28. @RequestParam 和 @PathVariable 两个注解的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E8%BF%94%E5%9B%9E-JSON-%E6%A0%BC%E5%BC%8F%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.2.29.</span> <span class="toc-text">29. 返回 JSON 格式使用什么注解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%80%E4%B9%88%E6%98%AFspringmvc%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%9F"><span class="toc-number">3.2.30.</span> <span class="toc-text">30. 什么是springmvc拦截器以及如何使用它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8SpringBoot"><span class="toc-number">3.2.31.</span> <span class="toc-text">31. 为什么要用SpringBoot?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%8C%85%E6%8B%AC%E8%AE%B8%E5%A4%9A%E6%9C%89%E7%94%A8%E7%9A%84%E9%9D%9E%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7%EF%BC%88%E4%BE%8B%E5%A6%82%E5%AE%89%E5%85%A8%E5%92%8C%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%EF%BC%89%E3%80%82"><span class="toc-number">3.3.</span> <span class="toc-text">SpringBoot包括许多有用的非功能特性（例如安全和健康检查）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-Spring-Boot-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">32.Spring Boot 自动配置原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-Spring-Boot%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81%EF%BC%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">33. Spring Boot中如何实现对不同环境的属性配置文件的支持？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-Spring-Boot-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E6%98%AF%E5%93%AA%E4%B8%AA%EF%BC%9F%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%B1%E5%93%AA%E5%87%A0%E4%B8%AA%E6%B3%A8%E8%A7%A3%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">3.3.3.</span> <span class="toc-text">34. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E4%BD%A0%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-Spring-Boot-%E4%B8%AD%E7%9A%84-Starter%EF%BC%9F"><span class="toc-number">3.3.4.</span> <span class="toc-text">35. 你如何理解 Spring Boot 中的 Starter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-Spring-Boot-Starter-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">36. Spring Boot Starter 的工作原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.3.6.</span> <span class="toc-text">37. 什么是嵌入式服务器？为什么要使用嵌入式服务器?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringCloud"><span class="toc-number">3.4.</span> <span class="toc-text">SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81spring-cloud%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、spring cloud断路器的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81spring-cloud%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">3.4.2.</span> <span class="toc-text">2、spring cloud的核心组件有哪些以及作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81spring-%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8Ccloud%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">3、spring 如何注册cloud服务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.4.</span> <span class="toc-text">4、微服务优点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.5.</span> <span class="toc-text">5、微服务的缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Spring-Cloud-Bus%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.6.</span> <span class="toc-text">6、Spring Cloud Bus是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="toc-number">3.4.7.</span> <span class="toc-text">7、什么是服务熔断？什么是服务降级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.8.</span> <span class="toc-text">8、负载均衡的意义是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81SpringBoot%E5%92%8CSpringCloud%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.9.</span> <span class="toc-text">9、SpringBoot和SpringCloud有什么联系和区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E2%80%93%E5%BF%85%E4%BC%9A100"><span class="toc-number">4.</span> <span class="toc-text">JUC–必会100%</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">什么是线程池，线程池有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89newCachedThreadPool"><span class="toc-number">4.1.1.</span> <span class="toc-text">（1）newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89newFixedThreadPool"><span class="toc-number">4.1.2.</span> <span class="toc-text">（2）newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89newSingleThreadExecutor"><span class="toc-number">4.1.3.</span> <span class="toc-text">（3）newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89newScheduleThreadPool"><span class="toc-number">4.1.4.</span> <span class="toc-text">（4）newScheduleThreadPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%BE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E9%87%8D%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadPoolExecutor对象有哪些参数？都有什么作用？怎么设定核心线程数和最大线程数？拒绝策略有哪些？ [重点]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%EF%BC%9A%E5%85%B17%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">参数与作用：共7个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">线程池大小设置：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">4.2.3.</span> <span class="toc-text">拒绝策略：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">常见线程安全的并发容器有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">Atomic原子类了解多少？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Flock%E5%BA%95%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">synchronized底层实现是什么？lock底层是什么？有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">4.5.1.</span> <span class="toc-text">Synchronized原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">4.5.2.</span> <span class="toc-text">Lock原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.3.</span> <span class="toc-text">Lock与synchronized的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93-%E2%80%93100"><span class="toc-number">5.</span> <span class="toc-text">数据库 –100%</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E2%80%93100"><span class="toc-number">5.1.</span> <span class="toc-text">MySQL–100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%BB%E9%87%8D%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.1.</span> <span class="toc-text">1、对MySQL数据库去重的关键字是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81MySQL%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F%E8%BF%99%E4%BA%9B%E8%BF%9E%E6%8E%A5%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">2、MySQL多表连接有哪些方式？怎么用的？这些连接都有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.3.</span> <span class="toc-text">3、索引的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF%EF%BC%9F"><span class="toc-number">5.1.4.</span> <span class="toc-text">4、说一下索引的优势和劣势？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81MySQL%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.5.</span> <span class="toc-text">5、MySQL聚簇和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%90%84%E8%87%AA%E4%BC%98%E5%8A%A3"><span class="toc-number">5.1.6.</span> <span class="toc-text">6、MySQL索引的数据结构，各自优劣</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.1.7.</span> <span class="toc-text">7、MySQL索引的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81MySQL%E4%B8%ADB-%E6%A0%91%E5%92%8CB%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.8.</span> <span class="toc-text">8、MySQL中B+树和B树的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81MySQL%E4%B8%AD%E7%9A%84%E9%94%81%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.1.9.</span> <span class="toc-text">9、MySQL中的锁类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81MySQL%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">5.1.10.</span> <span class="toc-text">10、MySQL什么是死锁？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81MySQL%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.1.11.</span> <span class="toc-text">11、MySQL的约束有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%85%B3%E5%BF%83%E8%BF%87%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%9D%A2%E7%9A%84sql%E8%80%97%E6%97%B6%E5%90%97%EF%BC%9F%E7%BB%9F%E8%AE%A1%E8%BF%87%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E5%AF%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%83%BD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E8%BF%87%EF%BC%9F"><span class="toc-number">5.1.12.</span> <span class="toc-text">12、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81MySQL%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.1.13.</span> <span class="toc-text">13、MySQL事务的基本特性和隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81MySQL%E4%B8%ADACID%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E7%9A%84%EF%BC%9F"><span class="toc-number">5.1.14.</span> <span class="toc-text">14、MySQL中ACID靠什么保证的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81MySQL%E4%B8%AD%E7%9A%84MVCC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.15.</span> <span class="toc-text">15、MySQL中的MVCC是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81UNION%E5%92%8CUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.1.16.</span> <span class="toc-text">16、UNION和UNION ALL的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID%E8%BF%98%E6%98%AFUUID%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.17.</span> <span class="toc-text">17、主键使用自增ID还是UUID，为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81MySQL%E6%95%B0%E6%8D%AE%E5%BA%93cpu%E9%A3%99%E5%8D%87%E7%9A%84%E8%AF%9D%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-number">5.1.18.</span> <span class="toc-text">18、MySQL数据库cpu飙升的话，要怎么处理呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">5.1.19.</span> <span class="toc-text">19、什么是存储过程？有哪些优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A8%E5%88%86%E5%8C%BA%E5%90%97%EF%BC%9F%E8%A1%A8%E5%88%86%E5%8C%BA%E7%9A%84%E5%A5%BD%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.1.20.</span> <span class="toc-text">20、了解什么是表分区吗？表分区的好处有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81MySQL%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.21.</span> <span class="toc-text">21、MySQL主从同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E7%AE%80%E8%BF%B0MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.22.</span> <span class="toc-text">22、简述MyISAM和InnoDB的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E7%AE%80%E8%BF%B0MySQL%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.1.23.</span> <span class="toc-text">23、简述MySQL中索引类型及对数据库的性能的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81MySQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%80%8E%E4%B9%88%E7%9C%8B"><span class="toc-number">5.1.24.</span> <span class="toc-text">24、MySQL执行计划怎么看</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81MySQL%E5%B8%B8%E8%A7%81%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">5.1.25.</span> <span class="toc-text">25、MySQL常见优化手段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E2%80%9360"><span class="toc-number">6.</span> <span class="toc-text">网络–60%</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E2%80%93%E4%B8%8D%E7%9C%8B%EF%BC%88%E5%BF%AB%E9%80%9F%E5%AD%A6%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">Netty–不看（快速学）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88Netty%E9%80%82%E5%90%88%E5%81%9A%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">1 为什么Netty适合做网络编程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Netty%E6%80%A7%E8%83%BD%E5%A5%BD%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.1.2.</span> <span class="toc-text">2 Netty性能好的原因是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">6.1.3.</span> <span class="toc-text">3 Netty的零拷贝是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%83%BD%E4%B8%8D%E8%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4Netty%E7%9A%84%E6%97%A0%E9%94%81%E5%8C%96%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">6.1.4.</span> <span class="toc-text">4 能不能说一说Netty的无锁化设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">6.1.5.</span> <span class="toc-text">5 Netty的线程模型是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Netty%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3TCP%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="toc-number">6.1.6.</span> <span class="toc-text">6 Netty如何解决TCP粘包、拆包的问题的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Netty%E7%9A%84Buffer%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A5%BD%E7%94%A8"><span class="toc-number">6.1.7.</span> <span class="toc-text">7 Netty的Buffer为什么好用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%AF%B4%E8%AF%B4-Netty-%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%EF%BC%9F"><span class="toc-number">6.1.8.</span> <span class="toc-text">8 说说 Netty 的对象池技术？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Netty%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">6.1.9.</span> <span class="toc-text">9 Netty有哪些序列化协议？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Netty-%E4%B8%AD%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">6.1.10.</span> <span class="toc-text">10 Netty 中用了哪些设计模式？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat-100"><span class="toc-number">6.2.</span> <span class="toc-text">Tomcat 100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Tomcat%E7%9A%84%E7%BC%BA%E7%9C%81%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%AE%E6%94%B9%EF%BC%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">1、Tomcat的缺省端口是多少，怎么修改？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81tomcat-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8DConnector-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F-%E4%BC%98%E5%8C%96-%EF%BC%9F"><span class="toc-number">6.2.2.</span> <span class="toc-text">2、tomcat 有哪几种Connector 运行模式(优化)？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Tomcat%E6%9C%89%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">6.2.3.</span> <span class="toc-text">3、Tomcat有几种部署方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81tomcat%E5%AE%B9%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BAservlet%E7%B1%BB%E5%AE%9E%E4%BE%8B%EF%BC%9F%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">6.2.4.</span> <span class="toc-text">4、tomcat容器是如何创建servlet类实例？用到了什么原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81tomcat-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">5、tomcat 如何优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%86%9F%E6%82%89tomcat%E7%9A%84%E5%93%AA%E4%BA%9B%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">6.2.6.</span> <span class="toc-text">6、熟悉tomcat的哪些配置？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%80%89%E6%8B%A9%EF%BC%88%E5%8E%9F%E7%90%86%E5%BF%85%E9%A1%BB%E6%90%9E%E6%B8%85%E6%A5%9A%EF%BC%89%E9%80%89%E6%8B%A9%E6%80%A7%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.3.</span> <span class="toc-text">计算机网络 -选择（原理必须搞清楚）选择性学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BOSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">1、介绍一下OSI七层模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%9A%84%E7%B2%98%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="toc-number">6.3.2.</span> <span class="toc-text">2、什么是TCP的粘包、拆包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81ARP-%E4%B8%8E-RARP-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">3、ARP 与 RARP 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.4.</span> <span class="toc-text">4、路由器与交换机的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">6.3.5.</span> <span class="toc-text">5、什么是TCP三次握手、四次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F"><span class="toc-number">6.3.6.</span> <span class="toc-text">6、TCP是如何保证可靠传输的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%9F%BA%E4%BA%8EUDP%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AATCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.7.</span> <span class="toc-text">7、基于UDP实现一个TCP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81HTTP-2%EF%BC%8C%E4%BB%96%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.3.8.</span> <span class="toc-text">8、为什么需要HTTP&#x2F;2，他解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81HTTP-2%E5%AD%98%E5%9C%A8%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81HTTP-3%EF%BC%9F"><span class="toc-number">6.3.9.</span> <span class="toc-text">9、HTTP&#x2F;2存在什么问题，为什么需要HTTP&#x2F;3？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Cookie%EF%BC%8CSession%EF%BC%8CToken%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.10.</span> <span class="toc-text">10、Cookie，Session，Token的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81HTTPS%E5%8F%AA%E6%98%AF%E6%AF%94HTTP%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="toc-number">6.3.11.</span> <span class="toc-text">11、HTTPS只是比HTTP安全吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5www-baidu-com%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">6.3.12.</span> <span class="toc-text">12、浏览器输入www.baidu.com回车之后发生了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.3.13.</span> <span class="toc-text">13、对称加密和非对称加密有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BDNS%EF%BC%9F"><span class="toc-number">6.3.14.</span> <span class="toc-text">14、简单介绍一下DNS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81ping%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.3.15.</span> <span class="toc-text">15、ping的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFIPV6%EF%BC%9F%E5%92%8CIPV4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.3.16.</span> <span class="toc-text">16、什么是IPV6？和IPV4有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F"><span class="toc-number">6.3.17.</span> <span class="toc-text">17、什么是正向代理和反向代理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">6.3.18.</span> <span class="toc-text">18、什么是跨域访问问题，如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFCDN%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%96%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">6.3.19.</span> <span class="toc-text">19、什么是CDN，为什么他可以做缓存？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ-%E2%80%93Kafaka"><span class="toc-number">7.1.</span> <span class="toc-text">RabbitMQ –Kafaka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E8%BF%B0RabbitMQ%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.1.</span> <span class="toc-text">1、简述RabbitMQ的架构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BRabbitMQ%E6%9C%89%E5%87%A0%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">2、介绍一下RabbitMQ有几种工作模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%81RabbitMQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-%EF%BC%9F-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%EF%BC%9F"><span class="toc-number">7.1.3.</span> <span class="toc-text">3 、RabbitMQ如何确保消息发送 ？ 消息接收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81RabbitMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">7.1.4.</span> <span class="toc-text">4、RabbitMQ事务消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81RabbitMQ%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="toc-number">7.1.5.</span> <span class="toc-text">5、RabbitMQ如何实现延迟消息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">7.1.6.</span> <span class="toc-text">6、RabbitMQ如何保证消息的顺序性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8RabbitMQ%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">7.1.7.</span> <span class="toc-text">7、如何使用RabbitMQ解决分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2RabbitMQ%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="toc-number">7.1.8.</span> <span class="toc-text">8、如何防止RabbitMQ消息重复消费？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-%E6%9C%89%E5%87%A0%E7%99%BE%E4%B8%87%E7%9A%84%E6%B6%88%E6%81%AF%E6%8C%81%E7%BB%AD%E7%A7%AF%E5%8E%8B%E5%87%A0%E5%B0%8F%E6%97%B6-%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">7.1.9.</span> <span class="toc-text">9、如何解决消息队列的延时以及过期失效问题?消息队列满了之后该如何处理?有几百万的消息持续积压几小时,说说如何解决?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloud%E6%A0%B8%E5%BF%83%E4%B8%AD%E9%97%B4%E4%BB%B6100"><span class="toc-number">8.1.</span> <span class="toc-text">Cloud核心中间件100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Nacos"><span class="toc-number">8.1.1.</span> <span class="toc-text">一、Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B%EF%BC%9F"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">1、注册中心如何选型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNacos%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E6%9D%A5%E4%BD%9C%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">2、什么是Nacos，主要用来作什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Nacos%E6%98%AFAP%E7%9A%84%E8%BF%98%E6%98%AFCP%E7%9A%84%EF%BC%9F"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">3、Nacos是AP的还是CP的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81Nacos%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8F%98%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E6%84%9F%E7%9F%A5%E5%88%B0%EF%BC%9F"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">4、Nacos如何实现的配置变化客户端可以感知到？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81Nacos%E8%83%BD%E5%90%8C%E6%97%B6%E5%AE%9E%E7%8E%B0AP%E5%92%8CCP%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.1.5.</span> <span class="toc-text">5、Nacos能同时实现AP和CP的原理是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81Nacos%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.1.6.</span> <span class="toc-text">6、Nacos服务发现的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.1.7.</span> <span class="toc-text">7、Nacos注册中心原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Feign"><span class="toc-number">8.1.2.</span> <span class="toc-text">二、Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Feign%E7%9A%84%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">Feign的调用原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Feign-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">Feign+Nacos注册中心原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Feign%E7%9A%84%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">Feign的底层调用源码大致流程:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">远程调用的本质：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch"><span class="toc-number">8.2.</span> <span class="toc-text">ElasticSearch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8ElasticSearch%EF%BC%9F"><span class="toc-number">8.2.1.</span> <span class="toc-text">1 、为什么要使用ElasticSearch？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E3%80%81ElasticSearch%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">8.2.2.</span> <span class="toc-text">2 、ElasticSearch为什么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%81%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">3 、倒排索引是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81ES%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">8.2.4.</span> <span class="toc-text">4 、如何保证ES和数据库的数据一致性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F100"><span class="toc-number">8.3.</span> <span class="toc-text">微服务、分布式100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.3.1.</span> <span class="toc-text">1、分布式和微服务的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%9F%E4%BC%98%E5%8A%BF%EF%BC%9F%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">8.3.2.</span> <span class="toc-text">2、什么是微服务架构？优势？特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.3.</span> <span class="toc-text">3、负载均衡算法、类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%B8%8B%EF%BC%8CSession-%E5%85%B1%E4%BA%AB%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.4.</span> <span class="toc-text">4、分布式架构下，Session 共享有什么方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81CAP%E7%90%86%E8%AE%BA%EF%BC%8CBASE%E7%90%86%E8%AE%BA"><span class="toc-number">8.3.5.</span> <span class="toc-text">5、CAP理论，BASE理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8FId%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.6.</span> <span class="toc-text">6、分布式Id生成方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.7.</span> <span class="toc-text">7、分布式锁的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.3.8.</span> <span class="toc-text">8、实现一个分布式锁需要考虑哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.3.9.</span> <span class="toc-text">9、什么是分布式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.10.</span> <span class="toc-text">10、分布式事务解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AFTCC%EF%BC%8C%E5%92%8C2PC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.3.11.</span> <span class="toc-text">11、 什么是TCC，和2PC有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">8.3.12.</span> <span class="toc-text">12、什么是柔性事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">8.3.13.</span> <span class="toc-text">13、如何基于本地消息表实现分布式事务？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSeata%EF%BC%9F%E4%BB%96%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.3.14.</span> <span class="toc-text">14、什么是Seata？他有哪几种模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">8.3.15.</span> <span class="toc-text">15、如何实现接口的幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81token-%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.15.1.</span> <span class="toc-text">1、token 机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.15.2.</span> <span class="toc-text">2、各种锁机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%90%84%E7%A7%8D%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.3.15.3.</span> <span class="toc-text">3、各种唯一约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%A1%A8%E9%98%B2%E9%87%8D"><span class="toc-number">8.3.15.4.</span> <span class="toc-text">4、表防重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">8.3.16.</span> <span class="toc-text">16、微服务架构的服务治理有哪些实现方案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B9%B6%E5%8F%91100"><span class="toc-number">8.4.</span> <span class="toc-text">线程、并发100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="toc-number">8.4.1.</span> <span class="toc-text">1、什么是并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.2.</span> <span class="toc-text">2、并发和并行有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="toc-number">8.4.3.</span> <span class="toc-text">3、为什么要使用并发？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">8.4.4.</span> <span class="toc-text">4、并发编程有哪些缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.4.5.</span> <span class="toc-text">5、上下文切换是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.4.6.</span> <span class="toc-text">6、使用多线程可能会带来什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">8.4.7.</span> <span class="toc-text">7、简要总结线程与进程的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81sleep-%E3%80%81wait-%E3%80%81join-%E3%80%81yield-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.8.</span> <span class="toc-text">8、sleep()、wait()、join()、yield()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%B0%88%E8%B0%88%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.9.</span> <span class="toc-text">9、谈谈对线程安全的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.10.</span> <span class="toc-text">10、Thread和Runnable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E8%B0%88%E8%B0%88%E5%AF%B9%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.11.</span> <span class="toc-text">11、谈谈对守护线程的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81ThreadLocal%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.4.12.</span> <span class="toc-text">12、ThreadLocal的原理和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">8.4.13.</span> <span class="toc-text">13、ThreadLocal内存泄露原因，如何避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%B9%B6%E5%8F%91%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">8.4.14.</span> <span class="toc-text">14、并发的三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.4.15.</span> <span class="toc-text">15、JMM内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81JVM%E5%AD%98%E5%9C%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">8.4.16.</span> <span class="toc-text">16、JVM存在的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E8%B0%88%E8%B0%88Volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.4.17.</span> <span class="toc-text">17、谈谈Volatile关键字的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%AA%8C%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">8.4.17.1.</span> <span class="toc-text">1、验证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%AA%8C%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">8.4.17.2.</span> <span class="toc-text">2、验证有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%8D%E5%85%B7%E5%A4%87%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">8.4.17.3.</span> <span class="toc-text">3、不具备原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E8%A7%A3%E9%87%8A%E4%B8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">8.4.18.</span> <span class="toc-text">18、为什么用线程池？解释下线程池参数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.19.</span> <span class="toc-text">19、JUC线程池的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%E6%98%AF%E5%A6%82%E4%BD%95%E6%B5%81%E8%BD%AC%E7%9A%84"><span class="toc-number">8.4.20.</span> <span class="toc-text">20、线程池的五种状态是如何流转的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E5%BE%97%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">8.4.21.</span> <span class="toc-text">21 、线程池为什么一定得是阻塞队列？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BC%9A%E8%A2%AB%E7%A7%BB%E5%87%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97%EF%BC%9F"><span class="toc-number">8.4.22.</span> <span class="toc-text">22、线程发生异常，会被移出线程池吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%E3%80%81%E6%9C%80%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="toc-number">8.4.23.</span> <span class="toc-text">23、线程池的核心线程数、最大线程数该如何设置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81Tomcat%E6%98%AF%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%EF%BC%9F"><span class="toc-number">8.4.24.</span> <span class="toc-text">24、Tomcat是如何自定义线程池的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81volatile%E5%8F%98%E9%87%8F%E5%92%8Catomic%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.25.</span> <span class="toc-text">25、volatile变量和atomic变量有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">9.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E2%80%93100"><span class="toc-number">9.1.</span> <span class="toc-text">Redis–100%</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E3%80%81Redis%E6%98%AFAP%E7%9A%84%E8%BF%98%E6%98%AFCP%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.1.</span> <span class="toc-text">1 、Redis是AP的还是CP的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BRedis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">9.1.2.</span> <span class="toc-text">2 、介绍一下Redis的集群方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRedis%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%EF%BC%9F"><span class="toc-number">9.1.3.</span> <span class="toc-text">3 、什么是Redis的数据分片？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E3%80%81Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">9.1.4.</span> <span class="toc-text">4 、Redis为什么这么快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81-Redis-%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.5.</span> <span class="toc-text">5、 Redis 的事务机制是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E3%80%81Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.6.</span> <span class="toc-text">6 、Redis的持久化机制是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81-Redis-%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.7.</span> <span class="toc-text">7、 Redis 的过期策略是怎么样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E3%80%81Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">9.1.8.</span> <span class="toc-text">8 、Redis的内存淘汰策略是怎么样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%BF%9B%E8%A1%8C%E6%B7%98%E6%B1%B0%E7%9A%84-7-%E7%A7%8D%E5%85%B6%E4%BB%96%E7%AD%96%E7%95%A5%E3%80%82"><span class="toc-number">9.2.</span> <span class="toc-text">会进行淘汰的 7 种其他策略。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81-Redis%E7%9A%84LRU%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.1.</span> <span class="toc-text">9、 Redis的LRU算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81-Redis%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">9.2.2.</span> <span class="toc-text">10、 Redis的淘汰策略的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E7%83%ADKey%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%83%ADkey%E9%97%AE%E9%A2%98"><span class="toc-number">9.2.3.</span> <span class="toc-text">11、 什么是热Key问题，如何解决热key问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%A7Key%E9%97%AE%E9%A2%98%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">9.2.4.</span> <span class="toc-text">12、 什么是大Key问题，如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">9.2.5.</span> <span class="toc-text">13、 什么是缓存击穿、缓存穿透、缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">9.2.6.</span> <span class="toc-text">14、 什么情况下会出现数据库和缓存不一致的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">9.2.7.</span> <span class="toc-text">15、 如何解决Redis和数据库的一致性问题？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%B9%B6%E5%8F%91%EF%BC%88%E8%AF%BB%E3%80%81%E5%86%99%EF%BC%89%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BB%8D%E7%84%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%B1%E6%95%88%E6%9C%BA%E5%88%B6-%E4%B8%BB%E5%8A%A8%E5%88%A0%E7%BC%93%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%82%EF%BC%88%E5%9C%A8%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%E5%92%8C%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E5%A4%B1%E6%95%88%E6%9C%9F%E9%97%B4%E4%BB%8D%E7%84%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">有并发（读、写）的情况下，仍然会出现缓存数据和数据库数据不一致问题，因此还需要通过缓存数据的失效机制+主动删缓存的机制来保证缓存数据和数据库数据的一致性。（在删除缓存和缓存数据失效期间仍然会出现不一致）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="toc-number">9.3.1.</span> <span class="toc-text">16、 Redis如何实现延迟消息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81-%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%EF%BC%8CRedis%E8%BF%98%E8%83%BD%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.3.2.</span> <span class="toc-text">17、 除了做缓存，Redis还能用来干什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81-%E5%A6%82%E4%BD%95%E7%94%A8SETNX%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">9.3.3.</span> <span class="toc-text">18、 如何用SETNX实现分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81-%E4%BB%80%E4%B9%88%E6%98%AFRedLock%EF%BC%8C%E4%BB%96%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">9.3.4.</span> <span class="toc-text">19、 什么是RedLock，他解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81-%E5%A6%82%E4%BD%95%E7%94%A8Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">9.3.5.</span> <span class="toc-text">20、 如何用Redisson实现分布式锁？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%83%AD%E9%97%A8%E9%A2%86%E5%9F%9F%E6%A6%82%E5%BF%B5%E2%80%93%E4%BA%86%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">热门领域概念–了解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E8%AE%A1%E7%AE%97"><span class="toc-number">10.1.</span> <span class="toc-text">云计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%9F"><span class="toc-number">10.1.1.</span> <span class="toc-text">1、什么是云计算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%AC%E6%9C%89%E4%BA%91%E3%80%81%E7%A7%81%E6%9C%89%E4%BA%91%E3%80%81%E6%B7%B7%E5%90%88%E4%BA%91%EF%BC%9F"><span class="toc-number">10.1.2.</span> <span class="toc-text">2、什么是公有云、私有云、混合云？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFIaaS%E3%80%81PaaS%E3%80%81SaaS%EF%BC%9F"><span class="toc-number">10.1.3.</span> <span class="toc-text">3、什么是IaaS、PaaS、SaaS？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFServerless%EF%BC%9F"><span class="toc-number">10.1.4.</span> <span class="toc-text">4、什么是Serverless？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98%E2%80%94%E7%90%86%E8%A7%A3"><span class="toc-number">11.1.</span> <span class="toc-text">场景题—理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%87%8F%E7%AA%81%E7%84%B6%E6%8F%90%E5%8D%87100%E5%80%8DQPS%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">11.1.1.</span> <span class="toc-text">1、如果你的业务量突然提升100倍QPS你会怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%AE%A2%E5%8D%95%E5%8F%B7%E7%94%9F%E6%88%90%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">11.1.2.</span> <span class="toc-text">2、让你设计一个订单号生成服务，该怎么做?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%AE%A2%E5%8D%95%E5%88%B0%E6%9C%9F%E5%85%B3%E9%97%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.1.3.</span> <span class="toc-text">3、订单到期关闭如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">11.1.4.</span> <span class="toc-text">4、如何设计一个购物车功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%AF%8F%E5%A4%A9100w%E6%AC%A1%E7%99%BB%E5%BD%95%E8%AF%B7%E6%B1%82%EF%BC%8C4C8G%E6%9C%BA%E5%99%A8%E5%A6%82%E4%BD%95%E5%81%9AJVM%E8%B0%83%E4%BC%98%EF%BC%9F"><span class="toc-number">11.1.5.</span> <span class="toc-text">5、每天100w次登录请求，4C8G机器如何做JVM调优？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E4%B8%8D%E7%94%A8redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%8C-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E7%94%A8%E6%88%B7%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB%EF%BC%9F"><span class="toc-number">11.1.6.</span> <span class="toc-text">6、不用redis分布式锁， 如何防止用户重复点击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.1.7.</span> <span class="toc-text">7、让你设计一个秒杀系统，你会考虑哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.1.8.</span> <span class="toc-text">8、如果让你实现消息队列，会考虑哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%B6%85%E5%8D%96%E5%92%8C%E5%B0%91%E5%8D%96%EF%BC%9F"><span class="toc-number">11.1.9.</span> <span class="toc-text">9、库存扣减如何避免超卖和少卖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E6%9C%8B%E5%8F%8B%E5%9C%88%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">11.1.10.</span> <span class="toc-text">10、如何用Redis实现朋友圈点赞功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81Redis%E7%9A%84zset%E5%AE%9E%E7%8E%B0%E6%8E%92%E8%A1%8C%E6%A6%9C%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%88%86%E6%95%B0%E7%9B%B8%E5%90%8C%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">11.1.11.</span> <span class="toc-text">11、Redis的zset实现排行榜，实现分数相同按照时间顺序排序，怎么做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%80%9D%E6%9F%A5%E6%89%BE%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E2%80%9D%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">11.1.12.</span> <span class="toc-text">12、如何实现”查找附近的人”功能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E6%8B%89%E6%A8%A1%E5%BC%8F%E5%A5%BD%E8%BF%98%E6%98%AF%E6%8E%A8%E6%A8%A1%E5%BC%8F%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.1.13.</span> <span class="toc-text">13、消息队列使用拉模式好还是推模式好？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AADubbo%EF%BC%8C%E4%BC%9A%E8%80%83%E8%99%91%E7%94%A8%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.1.14.</span> <span class="toc-text">14、如果让你实现一个Dubbo，会考虑用哪些技术解决哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81Kafka%EF%BC%8C%E5%8D%95%E5%88%86%E5%8C%BA%E5%8D%95%E6%B6%88%E8%B4%B9%E8%80%85%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">11.1.15.</span> <span class="toc-text">15、Kafka，单分区单消费者实例，如何提高吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E4%B8%80%E4%B8%AA%E8%AE%A2%E5%8D%95%EF%BC%8C%E5%9C%A811-00%E8%B6%85%E6%97%B6%E5%85%B3%E9%97%AD%EF%BC%8C%E4%BD%86%E5%9C%A811-00%E4%B9%9F%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E4%BA%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.1.16.</span> <span class="toc-text">16、一个订单，在11:00超时关闭，但在11:00也支付成功了，怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E4%B8%80%E4%B8%AA%E6%94%AF%E4%BB%98%E5%8D%95%EF%BC%8C%E5%A4%9A%E4%B8%AA%E6%B8%A0%E9%81%93%E5%90%8C%E6%97%B6%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">11.1.17.</span> <span class="toc-text">17、一个支付单，多个渠道同时支付成功了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%87%8D%E5%A4%8D%E4%B8%8B%E5%8D%95%E7%AD%89%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.1.18.</span> <span class="toc-text">18、如何解决消息重复消费、重复下单等问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CSQL%E8%B0%83%E4%BC%98%E7%9A%84%EF%BC%9F"><span class="toc-number">11.1.19.</span> <span class="toc-text">19、你是如何进行SQL调优的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E4%B8%8D%E4%BD%BF%E7%94%A8synchronized%E5%92%8CLock%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%EF%BC%9F"><span class="toc-number">11.1.20.</span> <span class="toc-text">20、不使用synchronized和Lock如何设计一个线程安全的单例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%9A%84%EF%BC%8C%E6%9C%89%E9%82%A3%E4%BA%9B%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">11.1.21.</span> <span class="toc-text">21、索引失效的问题是如何排查的，有那些种情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%8140%E4%BA%BF%E4%B8%AAQQ%E5%8F%B7%EF%BC%8C%E9%99%90%E5%88%B61G%E5%86%85%E5%AD%98%EF%BC%8C%E5%A6%82%E4%BD%95%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">11.1.22.</span> <span class="toc-text">22、40亿个QQ号，限制1G内存，如何去重？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E4%BB%8EB-%E6%A0%91%E7%9A%84%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E8%A1%A82000%E4%B8%87%E8%A6%81%E8%80%83%E8%99%91%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">11.1.23.</span> <span class="toc-text">23、从B+树的角度分析为什么单表2000万要考虑分表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E7%BA%BF%E4%B8%8A%E6%8E%A5%E5%8F%A3%E5%A6%82%E6%9E%9C%E5%93%8D%E5%BA%94%E5%BE%88%E6%85%A2%E5%A6%82%E4%BD%95%E5%8E%BB%E6%8E%92%E6%9F%A5%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F"><span class="toc-number">11.1.24.</span> <span class="toc-text">24、线上接口如果响应很慢如何去排查定位问题呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E6%80%8E%E4%B9%88%E5%81%9A%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B4%A6%EF%BC%9F"><span class="toc-number">11.1.25.</span> <span class="toc-text">25、怎么做数据对账？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81MySQL%E5%8D%83%E4%B8%87%E7%BA%A7%E5%A4%A7%E8%A1%A8%E5%A6%82%E4%BD%95%E5%81%9A%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%EF%BC%9F"><span class="toc-number">11.1.26.</span> <span class="toc-text">26、MySQL千万级大表如何做数据清理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%EF%BC%8CMongoDB%E7%94%A8B%E6%A0%91%EF%BC%9F"><span class="toc-number">11.1.27.</span> <span class="toc-text">27、为什么MySQL用B+树，MongoDB用B树？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%A7%AF%E5%88%86%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%8A%A0%E7%A7%AF%E5%88%86%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">11.1.28.</span> <span class="toc-text">28、高并发的积分系统，在数据库增加积分，怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81MySQL%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.1.29.</span> <span class="toc-text">29、MySQL热点数据更新会带来哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81%E5%92%8C%E5%A4%96%E9%83%A8%E6%9C%BA%E6%9E%84%E4%BA%A4%E4%BA%92%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A2%AB%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%E8%80%8C%E6%8B%96%E5%9E%AE"><span class="toc-number">11.1.30.</span> <span class="toc-text">30、和外部机构交互如何防止被外部服务不可用而拖垮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81MySQL-%E9%87%8C%E6%9C%89-2000W-%E6%95%B0%E6%8D%AE%EF%BC%8CRedis-%E4%B8%AD%E5%8F%AA%E5%AD%98-20W-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">11.1.31.</span> <span class="toc-text">31、MySQL 里有 2000W 数据，Redis 中只存 20W 的数据，如何保证 Redis 中的数据都是热点数据?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E2%80%93%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C"><span class="toc-number">11.2.</span> <span class="toc-text">项目上线问题排查–工作经验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81RT%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.1.</span> <span class="toc-text">1、RT飙高问题排查过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81CPU%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.2.</span> <span class="toc-text">2、CPU飙高问题排查过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%BB%A1%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.3.</span> <span class="toc-text">3、数据库连接池满排查过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93CPU%E8%A2%AB%E6%89%93%E6%BB%A1%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.4.</span> <span class="toc-text">4、数据库CPU被打满排查过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.5.</span> <span class="toc-text">5、OOM问题排查过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%A2%91%E7%B9%81FullGC%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">11.2.6.</span> <span class="toc-text">6、频繁FullGC问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81Arthas%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.2.7.</span> <span class="toc-text">7、Arthas统计方法耗时的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%85%A2SQL%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">11.2.8.</span> <span class="toc-text">8、慢SQL问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Load%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">11.2.9.</span> <span class="toc-text">9、Load飙高问题排查过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%BA%E4%BA%8B%E9%9D%A2%E8%AF%95%E2%80%93%E6%83%85%E5%95%86"><span class="toc-number">12.</span> <span class="toc-text">人事面试–情商</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BD%A0%E8%87%AA%E5%B7%B1"><span class="toc-number">12.1.</span> <span class="toc-text">一、请介绍一下你自己</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9D%A5%E6%B7%B1%E5%9C%B3%E6%89%BE%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">二、为什么来深圳找工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E5%8E%9F%E6%9D%A5%E7%9A%84%E5%85%AC%E5%8F%B8%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">三、你为什么离开原来的公司？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%A0%E6%9C%80%E5%A4%A7%E7%9A%84%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.4.</span> <span class="toc-text">四、你最大的缺点是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BD%A0%E6%9C%AA%E6%9D%A53-5%E5%B9%B4%E7%9A%84%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">五、你未来3-5年的职业规划是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BD%A0%E5%AF%B9%E8%96%AA%E8%B5%84%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">六、你对薪资的要求？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%83%BD%E5%85%A5%E8%81%8C%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">七、什么时候能入职？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%AA%E4%BD%A0%E8%AE%A4%E4%B8%BA%E6%9C%80%E7%86%9F%E6%82%89%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%88%E9%A1%B9%E7%9B%AE%E7%BB%8F%E7%90%86%EF%BC%89"><span class="toc-number">12.8.</span> <span class="toc-text">八、介绍一个你认为最熟悉的项目（项目经理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%A6%82%E6%9E%9C%E5%85%AC%E5%8F%B8%E5%BD%95%E7%94%A8%E4%BD%A0%EF%BC%8C%E4%BD%A0%E5%B0%86%E6%80%8E%E6%A0%B7%E5%BC%80%E5%B1%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">九、如果公司录用你，你将怎样开展工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E4%BD%A0%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E9%97%AE%E6%88%91%E5%90%97%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">十、你还有什么问题问我吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%A4%BE%E4%BF%9D%E9%97%AE%E9%A2%98"><span class="toc-number">12.11.</span> <span class="toc-text">十一、社保问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E4%B8%8A%E5%AE%B6%E5%85%AC%E5%8F%B8%E8%96%AA%E8%B5%84%E6%9E%84%E6%88%90%EF%BC%8C%E5%8F%8A%E5%88%B0%E6%89%8B%E5%A4%9A%E5%B0%91%E9%92%B1"><span class="toc-number">12.12.</span> <span class="toc-text">十二、上家公司薪资构成，及到手多少钱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E4%BD%A0%E6%9C%89%E6%B2%A1%E6%9C%89%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E8%BF%87%E4%BD%A0%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E9%83%BD%E9%9A%BE%E4%BB%A5%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E7%9A%84%E6%80%81%E5%BA%A6%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">十三、你有没有在工作中遇到过你无论如何都难以解决的问题？你的态度如何？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%8E%8B%E5%8A%9B%E9%9D%A2%E8%AF%95%EF%BC%9A"><span class="toc-number">12.14.</span> <span class="toc-text">十四、压力面试：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%EF%BC%9A"><span class="toc-number">12.15.</span> <span class="toc-text">十五、电话面试：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E4%BD%A0%E5%AF%B9%E5%8A%A0%E7%8F%AD%E7%9A%84%E7%9C%8B%E6%B3%95%EF%BC%9F"><span class="toc-number">12.16.</span> <span class="toc-text">十六、你对加班的看法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E4%BD%A0%E6%9C%8B%E5%8F%8B%E5%AF%B9%E4%BD%A0%E7%9A%84%E8%AF%84%E4%BB%B7%EF%BC%9F"><span class="toc-number">12.17.</span> <span class="toc-text">十七、你朋友对你的评价？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81%E5%A6%82%E6%9E%9C%E9%80%9A%E8%BF%87%E8%BF%99%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%88%91%E4%BB%AC%E5%8D%95%E4%BD%8D%E5%BD%95%E7%94%A8%E4%BA%86%E4%BD%A0%EF%BC%8C%E4%BD%86%E5%B7%A5%E4%BD%9C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%8D%B4%E5%8F%91%E7%8E%B0%E4%BD%A0%E6%A0%B9%E6%9C%AC%E4%B8%8D%E9%80%82%E5%90%88%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.18.</span> <span class="toc-text">十八、如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81%E5%9C%A8%E5%AE%8C%E6%88%90%E6%9F%90%E9%A1%B9%E5%B7%A5%E4%BD%9C%E6%97%B6%EF%BC%8C%E4%BD%A0%E8%AE%A4%E4%B8%BA%E9%A2%86%E5%AF%BC%E8%A6%81%E6%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8D%E6%98%AF%E6%9C%80%E5%A5%BD%E7%9A%84%EF%BC%8C%E8%87%AA%E5%B7%B1%E8%BF%98%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">12.19.</span> <span class="toc-text">十九、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%87%BA%E7%8E%B0%E5%A4%B1%E8%AF%AF%EF%BC%8C%E7%BB%99%E6%9C%AC%E5%85%AC%E5%8F%B8%E9%80%A0%E6%88%90%E7%BB%8F%E6%B5%8E%E6%8D%9F%E5%A4%B1%EF%BC%8C%E4%BD%A0%E8%AE%A4%E4%B8%BA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.20.</span> <span class="toc-text">二十、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%81%9A%E7%9A%84%E4%B8%80%E9%A1%B9%E5%B7%A5%E4%BD%9C%E5%8F%97%E5%88%B0%E4%B8%8A%E7%BA%A7%E9%A2%86%E5%AF%BC%E7%9A%84%E8%A1%A8%E6%89%AC%EF%BC%8C%E4%BD%86%E4%BD%A0%E4%B8%BB%E7%AE%A1%E9%A2%86%E5%AF%BC%E5%8D%B4%E8%AF%B4%E6%98%AF%E4%BB%96%E5%81%9A%E7%9A%84%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">12.21.</span> <span class="toc-text">二十一、如果你做的一项工作受到上级领导的表扬，但你主管领导却说是他做的，你该怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E8%B7%B3%E6%A7%BD%E7%9A%84%E7%9C%8B%E6%B3%95%EF%BC%9F"><span class="toc-number">12.22.</span> <span class="toc-text">二十二、谈谈你对跳槽的看法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%A0%E9%9A%BE%E4%BB%A5%E5%92%8C%E5%90%8C%E4%BA%8B%E3%80%81%E4%B8%8A%E5%8F%B8%E7%9B%B8%E5%A4%84%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.23.</span> <span class="toc-text">二十三、工作中你难以和同事、上司相处，你该怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81%E5%81%87%E8%AE%BE%E4%BD%A0%E5%9C%A8%E6%9F%90%E5%8D%95%E4%BD%8D%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%88%90%E7%BB%A9%E6%AF%94%E8%BE%83%E7%AA%81%E5%87%BA%EF%BC%8C%E5%BE%97%E5%88%B0%E9%A2%86%E5%AF%BC%E7%9A%84%E8%82%AF%E5%AE%9A%E3%80%82%E4%BD%86%E5%90%8C%E6%97%B6%E4%BD%A0%E5%8F%91%E7%8E%B0%E5%90%8C%E4%BA%8B%E4%BB%AC%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%AD%A4%E7%AB%8B%E4%BD%A0%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E5%87%86%E5%A4%87%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.24.</span> <span class="toc-text">二十四、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你怎么看这个问题？你准备怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E4%BD%A0%E5%AF%B9%E4%BA%8E%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">12.25.</span> <span class="toc-text">二十五、你对于我们公司了解多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%BD%A0%E9%80%89%E6%8B%A9%E8%BF%99%E4%BB%BD%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%8A%A8%E6%9C%BA%EF%BC%9F"><span class="toc-number">12.26.</span> <span class="toc-text">二十六、请说出你选择这份工作的动机？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E4%BD%A0%E6%9C%80%E6%93%85%E9%95%BF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%B9%E5%90%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.27.</span> <span class="toc-text">二十七、你最擅长的技术方向是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E4%BD%A0%E8%83%BD%E4%B8%BA%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">12.28.</span> <span class="toc-text">二十八、你能为我们公司带来什么呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E6%9C%80%E8%83%BD%E6%A6%82%E6%8B%AC%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%89%E4%B8%AA%E8%AF%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.29.</span> <span class="toc-text">二十九、最能概括你自己的三个词是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E3%80%81%E4%BD%A0%E7%9A%84%E4%B8%9A%E4%BD%99%E7%88%B1%E5%A5%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.30.</span> <span class="toc-text">三十、你的业余爱好是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%80%E3%80%81%E4%BD%9C%E4%B8%BA%E8%A2%AB%E9%9D%A2%E8%AF%95%E8%80%85%E7%BB%99%E6%88%91%E6%89%93%E4%B8%80%E4%B8%8B%E5%88%86%EF%BC%9F"><span class="toc-number">12.31.</span> <span class="toc-text">三十一、作为被面试者给我打一下分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%BA%8C%E3%80%81%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E4%BD%A0%E5%BA%94%E8%81%98%E7%9A%84%E8%81%8C%E4%BD%8D%EF%BC%9F"><span class="toc-number">12.32.</span> <span class="toc-text">三十二、你怎么理解你应聘的职位？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%89%E3%80%81%E5%96%9C%E6%AC%A2%E8%BF%99%E4%BB%BD%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%93%AA%E4%B8%80%E7%82%B9%EF%BC%9F"><span class="toc-number">12.33.</span> <span class="toc-text">三十三、喜欢这份工作的哪一点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%9B%9B%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E8%A1%8C%E4%B8%9A%E3%80%81%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E7%9A%84%E7%9C%8B%E6%B3%95%EF%BC%9F"><span class="toc-number">12.34.</span> <span class="toc-text">三十四、说说你对行业、技术发展趋势的看法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%BA%94%E3%80%81%E8%AF%B4%E4%BD%A0%E7%9A%84%E5%AE%B6%E5%BA%AD%EF%BC%9F"><span class="toc-number">12.35.</span> <span class="toc-text">三十五、说你的家庭？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AD%E3%80%81%E5%B0%B1%E4%BD%A0%E7%94%B3%E8%AF%B7%E7%9A%84%E8%BF%99%E4%B8%AA%E8%81%8C%E4%BD%8D%EF%BC%8C%E4%BD%A0%E8%AE%A4%E4%B8%BA%E4%BD%A0%E8%BF%98%E6%AC%A0%E7%BC%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.36.</span> <span class="toc-text">三十六、就你申请的这个职位，你认为你还欠缺什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%83%E3%80%81%E4%BD%A0%E6%AC%A3%E8%B5%8F%E5%93%AA%E7%A7%8D%E6%80%A7%E6%A0%BC%E7%9A%84%E4%BA%BA%EF%BC%9F"><span class="toc-number">12.37.</span> <span class="toc-text">三十七、你欣赏哪种性格的人？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E5%85%AB%E3%80%81%E4%BD%A0%E9%80%9A%E5%B8%B8%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%88%A5%E4%BA%BA%E7%9A%84%E6%89%B9%E8%AF%84%EF%BC%9F"><span class="toc-number">12.38.</span> <span class="toc-text">三十八、你通常如何处理別人的批评？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B9%9D%E3%80%81%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%84%BF%E6%84%8F%E5%88%B0%E6%88%91%E4%BB%AC%E5%85%AC%E5%8F%B8%E6%9D%A5%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">12.39.</span> <span class="toc-text">三十九、你为什么愿意到我们公司来工作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E3%80%81%E4%BD%A0%E5%92%8C%E5%88%AB%E4%BA%BA%E5%8F%91%E7%94%9F%E8%BF%87%E4%BA%89%E6%89%A7%E5%90%97%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">12.40.</span> <span class="toc-text">四十、你和别人发生过争执吗？你是怎样解决的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%80%E3%80%81%E4%BD%A0%E5%81%9A%E8%BF%87%E7%9A%84%E5%93%AA%E4%BB%B6%E4%BA%8B%E6%9C%80%E4%BB%A4%E8%87%AA%E5%B7%B1%E6%84%9F%E5%88%B0%E9%AA%84%E5%82%B2%EF%BC%9F"><span class="toc-number">12.41.</span> <span class="toc-text">四十一、你做过的哪件事最令自己感到骄傲？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%BA%8C%E3%80%81%E5%AF%B9%E8%BF%99%E9%A1%B9%E5%B7%A5%E4%BD%9C%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E9%A2%84%E8%A7%81%E7%9A%84%E5%9B%B0%E9%9A%BE%EF%BC%9F"><span class="toc-number">12.42.</span> <span class="toc-text">四十二、对这项工作，你有哪些可预见的困难？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%89%E3%80%81%E6%80%8E%E6%A0%B7%E5%AF%B9%E5%BE%85%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B1%E6%95%97%EF%BC%9F"><span class="toc-number">12.43.</span> <span class="toc-text">四十三、怎样对待自己的失敗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%9B%9B%E3%80%81%E4%BB%80%E4%B9%88%E4%BC%9A%E8%AE%A9%E4%BD%A0%E6%9C%89%E6%88%90%E5%B0%B1%E6%84%9F%EF%BC%9F"><span class="toc-number">12.43.1.</span> <span class="toc-text">四十四、什么会让你有成就感？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%BA%94%E3%80%81%E7%9C%BC%E4%B8%8B%E4%BD%A0%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.43.2.</span> <span class="toc-text">四十五、眼下你生活中最重要的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%85%AD%E3%80%81%E4%B8%8E%E4%B8%8A%E7%BA%A7%E6%84%8F%E8%A7%81%E4%B8%8D%E4%B8%80%E6%98%AF%EF%BC%8C%E4%BD%A0%E5%B0%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.43.3.</span> <span class="toc-text">四十六、与上级意见不一是，你将怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B8%83%E3%80%81%E4%BD%A0%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E6%AC%A0%E7%BC%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E8%83%BD%E8%83%9C%E4%BB%BB%E8%BF%99%E9%A1%B9%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">12.43.4.</span> <span class="toc-text">四十七、你工作经验欠缺，如何能胜任这项工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E5%85%AB%E3%80%81%E4%BD%A0%E5%B8%8C%E6%9C%9B%E4%B8%8E%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%B8%8A%E7%BA%A7%E5%85%B1%E4%BA%8B%EF%BC%9F"><span class="toc-number">12.43.5.</span> <span class="toc-text">四十八、你希望与什么样的上级共事？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%8D%81%E4%B9%9D%E3%80%81%E8%B0%88%E8%B0%88%E5%A6%82%E4%BD%95%E9%80%82%E5%BA%94%E5%8A%9E%E5%85%AC%E5%AE%A4%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%96%B0%E7%8E%AF%E5%A2%83%EF%BC%9F"><span class="toc-number">12.43.6.</span> <span class="toc-text">四十九、谈谈如何适应办公室工作的新环境？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E3%80%81%E4%B8%BA%E4%BA%86%E5%81%9A%E5%A5%BD%E4%BD%A0%E5%B7%A5%E4%BD%9C%E4%BB%BD%E5%A4%96%E4%B9%8B%E4%BA%8B%EF%BC%8C%E4%BD%A0%E8%AF%A5%E6%80%8E%E6%A0%B7%E8%8E%B7%E5%BE%97%E4%BB%96%E4%BA%BA%E7%9A%84%E6%94%AF%E6%8C%81%E5%92%8C%E5%B8%AE%E5%8A%A9%EF%BC%9F"><span class="toc-number">12.43.7.</span> <span class="toc-text">五十、为了做好你工作份外之事，你该怎样获得他人的支持和帮助？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B8%80%E3%80%81%E5%A6%82%E6%9E%9C%E4%BD%A0%E5%9C%A8%E8%BF%99%E6%AC%A1%E9%9D%A2%E8%AF%95%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%BD%95%E7%94%A8%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E6%89%93%E7%AE%97%EF%BC%9F"><span class="toc-number">12.43.8.</span> <span class="toc-text">五十一、如果你在这次面试中没有被录用，你怎么打算？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%BA%8C%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E8%BF%87%E5%8E%BB%E5%81%9A%E8%BF%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%A1%88%E4%BE%8B%EF%BC%9F"><span class="toc-number">12.43.9.</span> <span class="toc-text">五十二、谈谈你过去做过的成功案例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B8%89%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E8%BF%87%E5%8E%BB%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B8%AD%EF%BC%8C%E6%9C%80%E4%BB%A4%E4%BD%A0%E6%8C%AB%E6%8A%98%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%9F"><span class="toc-number">12.43.10.</span> <span class="toc-text">五十三、谈谈你过去的工作经验中，最令你挫折的事情？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%9B%9B%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E5%9C%A8%E4%BC%97%E5%A4%9A%E7%9A%84%E9%9D%A2%E8%AF%95%E8%80%85%E4%B8%AD%E9%80%89%E6%8B%A9%E4%BD%A0%EF%BC%9F"><span class="toc-number">12.43.11.</span> <span class="toc-text">五十四、为什么我们要在众多的面试者中选择你？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%BA%94%E3%80%81%E4%BD%A0%E5%B9%B6%E9%9D%9E%E6%AF%95%E4%B8%9A%E4%BA%8E%E5%90%8D%E7%89%8C%E9%99%A2%E6%A0%A1%EF%BC%9F"><span class="toc-number">12.43.12.</span> <span class="toc-text">五十五、你并非毕业于名牌院校？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%85%AD%E3%80%81%E6%80%8E%E6%A0%B7%E7%9C%8B%E5%BE%85%E5%AD%A6%E5%8E%86%E5%92%8C%E8%83%BD%E5%8A%9B%EF%BC%9F"><span class="toc-number">12.43.13.</span> <span class="toc-text">五十六、怎样看待学历和能力？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B8%83%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%88%B0%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.43.14.</span> <span class="toc-text">五十七、工作中学习到了些什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E5%85%AB%E3%80%81%E6%83%B3%E8%BF%87%E5%88%9B%E4%B8%9A%E5%90%97%EF%BC%9F"><span class="toc-number">12.43.15.</span> <span class="toc-text">五十八、想过创业吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%8D%81%E4%B9%9D%E3%80%81%E9%99%A4%E4%BA%86%E6%9C%AC%E5%85%AC%E5%8F%B8%E5%A4%96%EF%BC%8C%E8%BF%98%E5%BA%94%E8%81%98%E4%BA%86%E5%93%AA%E4%BA%9B%E5%85%AC%E5%8F%B8%EF%BC%9F"><span class="toc-number">12.43.16.</span> <span class="toc-text">五十九、除了本公司外，还应聘了哪些公司？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E5%8D%81%E3%80%81%E9%9D%A2%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">12.43.17.</span> <span class="toc-text">六十、面试注意事项：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/" title="八股文详细版"><img src="https://img.090227.xyz/api/cfile/AgACAgUAAyEGAASOgsooAAOcZ-QUxbbeBlYZKN6lWHDyn0hwZ0cAAmTDMRu_ASBXCHO1-gQZnj8BAAMCAAN3AAM2BA" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文详细版"/></a><div class="content"><a class="title" href="/2025/03/26/%E5%85%AB%E8%82%A1%E6%96%87%E8%AF%A6%E7%BB%86%E7%89%88/" title="八股文详细版">八股文详细版</a><time datetime="2025-03-26T14:48:51.000Z" title="发表于 2025-03-26 22:48:51">2025-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/24/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/" title="这是一篇新的博文"><img src="https://img.090227.xyz/file/ae62475a131f3734a201c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是一篇新的博文"/></a><div class="content"><a class="title" href="/2025/03/24/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/" title="这是一篇新的博文">这是一篇新的博文</a><time datetime="2025-03-24T13:19:26.000Z" title="发表于 2025-03-24 21:19:26">2025-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/24/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="常见面试题"><img src="https://img.090227.xyz/file/ae62475a131f3734a201c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见面试题"/></a><div class="content"><a class="title" href="/2025/03/24/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="常见面试题">常见面试题</a><time datetime="2025-03-24T08:45:10.000Z" title="发表于 2025-03-24 16:45:10">2025-03-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="lyon ai" target="_blank">lyon ai</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Java/" style="font-size: 0.88rem;">Java<sup>2</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" style="font-size: 0.88rem;">八股文<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>1</sup></a><a href="/tags/%E5%9C%BA%E6%99%AF%E9%A2%98/" style="font-size: 0.88rem;">场景题<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B0%9A%E7%A1%85%E8%B0%B7/" style="font-size: 0.88rem;">尚硅谷<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">网络编程<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="anzhiyu.scrollToDest(document.body.scrollHeight, 500)"><i class="anzhiyufont anzhiyu-icon-arrow-down"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("25/03/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 lyon ai 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://lyonai-github-io.vercel.app/',
      region: 'ap-shanghai',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://lyonai-github-io.vercel.app/',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://lyonai-github-io.vercel.app/',
        region: 'ap-shanghai',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/imgloaded.js"></script><script src="/js/custom/schedule.js"></script><script src="https://open.lightxi.com/unpkg/chinese-lunar@0.1.4/lib/chinese-lunar.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>