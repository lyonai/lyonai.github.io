<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>这是一篇新的博文</title>
      <link href="/2025/03/24/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/"/>
      <url>/2025/03/24/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E6%96%B0%E7%9A%84%E5%8D%9A%E6%96%87/</url>
      
        <content type="html"><![CDATA[<div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题</title>
      <link href="/2025/03/24/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/03/24/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="一、什么是Spring容器"><a href="#一、什么是Spring容器" class="headerlink" title="一、什么是Spring容器"></a><strong>一、什么是Spring容器</strong></h2><p>Spring框架的核心就是Spring容器，ioc容器创建对象，管理对象（通过依赖注入，装配对象，并管理他们的生命周期）</p><h2 id="二、如何实现一个Spring容器"><a href="#二、如何实现一个Spring容器" class="headerlink" title="二、如何实现一个Spring容器"></a><strong>二、如何实现一个Spring容器</strong></h2><p>1.配置文件配置包扫描路径。2.递归包扫描获取.class文件。 3.反射、确定需要交给ioc管理的类。4.对需要注入的类进行依赖注入</p><p>配置文件中指定需要扫描的包路径<br>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解<br>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路<br>径下所有以.class结尾的文件添加到一个Set集合中进行存储<br>遍历这个set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的Map用来存储这些对象<br>遍历这个IOC容器，获取到每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入。</p><h2 id="三、什么是依赖注入？可以通过多少种方式完成依赖注入？"><a href="#三、什么是依赖注入？可以通过多少种方式完成依赖注入？" class="headerlink" title="三、什么是依赖注入？可以通过多少种方式完成依赖注入？"></a><strong>三、什么是依赖注入？可以通过多少种方式完成依赖注入？</strong></h2><p>在依赖注入中，你不需要创建对象，但必须描述如何创建他们。描述配置文件中哪些组件需要哪些服务。由Ioc容器来将他们装配在一起。</p><p>1.通过Autowired和Resouce注解来注入    2. 通过构造函数注入  3.通过setter方法注入 4.接口注入</p><h2 id="四、BeanFactory-和-ApplicationContext的区别？"><a href="#四、BeanFactory-和-ApplicationContext的区别？" class="headerlink" title="四、BeanFactory 和 ApplicationContext的区别？"></a><strong>四、BeanFactory 和 ApplicationContext的区别？</strong></h2><p>ApplicationContext他是BeanFactory的子接口。</p><p>ApplicationContext提供了更完整的功能：</p><p>1.继承了MessageSource,因此支持国际化。</p><p>2.提供了统一的资源文件访问方式</p><p>3.提供在监听器中注册Bean的事件</p><p>4.同时加载多个配置文件（预加载）</p><p>5.载入多个有继承关系的上下文，使得每一个上下文都专注于一个特定的层次，比如应用的Web层。</p><p>BeanFactory采用的是延迟加载的形式来注入Bean的，只有在使用某个Bean（getBean()调用），才对该Bean进行加载实例化。</p><p>如果Bean的某个属性没有注入，BeanFactory加载后，直到第一次使用调用getBean方法之后才会抛出异常。</p><h2 id="五、spring-提供了哪些配置方式？"><a href="#五、spring-提供了哪些配置方式？" class="headerlink" title="五、spring 提供了哪些配置方式？"></a><strong>五、spring 提供了哪些配置方式？</strong></h2><p>1.基于xml配置</p><p>2.基于注解配置</p><p>3.基于 Java Config配置—目前使用主流。</p><p> Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p><h2 id="六、Spring-中的-bean-的作用域有哪些"><a href="#六、Spring-中的-bean-的作用域有哪些" class="headerlink" title="六、Spring 中的 bean 的作用域有哪些?"></a><strong>六、Spring 中的 bean 的作用域有哪些?</strong></h2><p>1.Singleton 2.prototype 3.session 4.application 5.global-session 6.refresh</p><h2 id="七、将一个类声明为Spring的-bean-的注解有哪些"><a href="#七、将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="七、将一个类声明为Spring的 bean 的注解有哪些?"></a><strong>七、将一个类声明为Spring的 bean 的注解有哪些?</strong></h2><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。&#x20;</li><li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li><li>@Configuration+@Bean的方式</li></ul><h2 id="八、Spring-中的-bean-生命周期"><a href="#八、Spring-中的-bean-生命周期" class="headerlink" title="八、Spring 中的 bean 生命周期"></a><strong>八、Spring 中的 bean 生命周期</strong></h2><p>1.实例化Bean实例 2.设置对象属性 3.检查Aware相关接口 4.BeanPostProcessor前置处理 </p><p>5.是否实现 InitializingBean 接口 6.是否配置了init-method 7.BeanPostProcessor后置处理</p><p>8.注册destruction相关的回调接口 9.Bean处于使用中 10.DisposableBean相关的回调接口</p><p>11.是否配置了自定义的destory-method.</p><p><img src="C:\Users\lyon\AppData\Roaming\Typora\typora-user-images\image-20250302231540697.png" alt="image-20250302231540697"></p><h2 id="九、Springboot的自动装配"><a href="#九、Springboot的自动装配" class="headerlink" title="九、Springboot的自动装配"></a>九、Springboot的自动装配</h2><p>在启动类有一个@SpringBootApplication注解，这是一个组合注解，他包含了@ComponentScan,@EnableAutoConfiguration</p><p>和@SpringBootConfiguration注解，其中的@EnableAutoConfiguration注解包含了一个@import注解，他导入了一个AutoConfigurationImportSelector.class,通过层层调用读取了一个.imports配置文件完成了自动装配。</p><h2 id="十、什么是bean的自动装配，有哪些方式？"><a href="#十、什么是bean的自动装配，有哪些方式？" class="headerlink" title="十、什么是bean的自动装配，有哪些方式？"></a><strong>十、什么是bean的自动装配，有哪些方式？</strong></h2><p>Bean的自动装配是SpringIOC容器在初始化Bean自动根据一定规则将依赖注入到bean的过程</p><p>开启自动装配，只需要在xml配置文件中定义“autowire”属性。</p><h3 id="（一）基于xml的自动装配："><a href="#（一）基于xml的自动装配：" class="headerlink" title="（一）基于xml的自动装配："></a>（一）基于xml的自动装配：</h3><p>autowire属性有六种装配的方式：</p><p>1.no – 缺省情况下，自动配置是通过“ref”属性手动设定 。</p><p>2.by-Name根据bean的属性名称进行自动装配</p><p>3.by-Type根据bena的类型进行自动装配</p><p>4.constructor-类似byType，不过是应用于构造器的参数。</p><p>5.autodetect-如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。但是spring3.0+已将该值废弃。</p><p>6.default：由上级标签&lt;beans&gt;的default-autowire属性确定。</p><h3 id="（二）基于注解的自动装配"><a href="#（二）基于注解的自动装配" class="headerlink" title="（二）基于注解的自动装配"></a>（二）基于注解的自动装配</h3><p>1.@Autowired自动装配bean，可以在字段、setter方法、构造函数上使用。相比Spring自带的自动注入方式，更加灵活。</p><p>2.@Qualifier按类型装配有多个候选Bean时，可以指定具体要装配Bean的名称</p><p>3.@Resoure按照name属性来装配</p><h2 id="十一、Spring中出现同名bean怎么办？"><a href="#十一、Spring中出现同名bean怎么办？" class="headerlink" title="十一、Spring中出现同名bean怎么办？"></a><strong>十一、Spring中出现同名bean怎么办？</strong></h2><p>如果是在不同的@Component注解中定义的同一个BeanName，那么Spring会直接报错。</p><p>如果可以修改类名，最简单的方法是更换类名。</p><p>如果需要指定 Bean 的名称，可以使用 <code>@Bean</code> 或 <code>@Qualifier</code> 注解。</p><p>如果需要优先选择某个 Bean，可以使用 <code>@Primary</code> 注解。</p><h2 id="十二、Spring-中的单例-bean-的线程安全问题？"><a href="#十二、Spring-中的单例-bean-的线程安全问题？" class="headerlink" title="十二、Spring 中的单例 bean 的线程安全问题？"></a><strong>十二、Spring 中的单例 bean 的线程安全问题？</strong></h2><p>不要在bean中声明任何有状态的实例变量或类变量，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了.</p><p>比较典型就是超卖问题：</p><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><h2 id="十三、什么是-AOP？"><a href="#十三、什么是-AOP？" class="headerlink" title="十三、什么是 AOP？"></a><strong>十三、什么是 AOP？</strong></h2><p>AOP即面向切面编程，它跟OOP（<strong>面向对象编程</strong>）是相辅相成的，提供了与OOP不同的抽象软件结构的视角。在OOP中，我们以类作为我们的基本单元，AOP的基本单元是<strong>Aspect(切面)</strong></p><p>AOP：将程序中的交叉业务逻辑（比如安全，日志，事务等），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去。AOP可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前额外的做一些事情，在某个方法执行之后额外的做一些事情。</p><h2 id="十四、AOP-有哪些实现方式？"><a href="#十四、AOP-有哪些实现方式？" class="headerlink" title="十四、AOP 有哪些实现方式？"></a><strong>十四、AOP 有哪些实现方式？</strong></h2><p>实现 AOP 的技术，主要分为两大类：</p><p>1.静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p><p>2.动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><h2 id="十五、-Spring-框架中用到了哪些设计模式？"><a href="#十五、-Spring-框架中用到了哪些设计模式？" class="headerlink" title="十五、 Spring 框架中用到了哪些设计模式？"></a>十五、 Spring 框架中用到了哪些设计模式？</h2><p>1**.工厂设计模式**</p><p>Spring 使用工厂模式通过 <code>BeanFactory</code> 和 <code>ApplicationContext</code> 创建 Bean 实例。它们是工厂类，负责生成和管理 Bean 的生命周期。</p><p><strong>2.单例模式</strong></p><p>大多数 Bean 在 Spring 中默认是以单例模式创建的，确保在整个应用上下文中只有一个实例。</p><p><strong>3.适配器模式</strong></p><p>Spring MVC 中的 <code>HandlerAdapter</code> 和事件监听器适配器等。将不兼容的接口转换为目标接口。</p><p><strong>4.装饰器模式</strong></p><p>Spring中用到的装饰器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><p><strong>5.代理模式</strong></p><p>Spring AOP 使用代理模式实现切面编程。通过动态代理为对象生成代理对象，添加额外功能（如日志、事务管理）。</p><p><strong>6.观察者模式</strong></p><p>spring的事件驱动模型使用的是观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p><p><strong>7、策略模式</strong></p><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了Resource 接口来访问底层资源。</p><p><strong>8、模板方法模式</strong> :&#x20;</p><p>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现</p><p>Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p><h2 id="十六、Spring-事务实现方式有哪些以及原理"><a href="#十六、Spring-事务实现方式有哪些以及原理" class="headerlink" title="十六、Spring 事务实现方式有哪些以及原理"></a><strong>十六、Spring 事务实现方式有哪些以及原理</strong></h2><p>1.编程式事务管理</p><p>2.声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。@Transactional注解就是声明式事务。</p><p>首先，事务这个概念是数据库层面的，Spring只是基于数据库中的事务进行了扩展，以及提供了一些能让程序员更加方便操作事务的方式。</p><p>比如，我们可以通过在某个方法上添加@Transactional注解，就可以开启事务，这个方法中所有的sql都会在一个事务中执行，统一成功，统一失败。</p><h2 id="十七、Spring事务的隔离级别"><a href="#十七、Spring事务的隔离级别" class="headerlink" title="十七、Spring事务的隔离级别"></a>十七、Spring事务的隔离级别</h2><p>spring事务隔离级别就是数据库的隔离级别：外加一个默认级别<br>read uncommitted（未提交读）<br>read committed（提交读、不可重复读）<br>repeatable read（可重复读）<br>serializable（可串行化）</p><h2 id="十八、数据库和缓存不一致解决方案"><a href="#十八、数据库和缓存不一致解决方案" class="headerlink" title="十八、数据库和缓存不一致解决方案"></a>十八、数据库和缓存不一致解决方案</h2><ul><li>由于我们的缓存数据源来自数据库，而数据库的数据是会发生变化的，因此，如果当数据库中数据发生变化，而缓存却没有同步，此时就会有一致性问题存在，其后果是<ul><li>用户使用缓存中的过时数据，就会产生类似多线程数据安全问题，从而影响业务，产品口碑等</li></ul></li><li>那么如何解决这个问题呢？有如下三种方式<ol><li>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库之后再去更新缓存，也称之为双写方案</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。但是维护这样一个服务很复杂，市面上也不容易找到这样的一个现成的服务，开发成本高</li><li>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，最终实现一致性。但是维护这样的一个异步的任务很复杂，需要实时监控缓存中的数据更新，其他线程去异步更新数据库也可能不太及时，而且缓存服务器如果宕机，那么缓存的数据也就丢失了</li></ol></li></ul><h2 id="十九、缓存穿透问题的解决思路"><a href="#十九、缓存穿透问题的解决思路" class="headerlink" title="十九、缓存穿透问题的解决思路"></a><strong>十九、缓存穿透问题的解决思路</strong></h2><ul><li><code>缓存穿透</code>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远都不会生效（只有数据库查到了，才会让redis缓存，但现在的问题是查不到），会频繁的去访问数据库。</li><li>常见的结局方案有两种<ol><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗，可能造成短期的不一致</li></ul></li><li>布隆过滤<ul><li>优点：内存占用啥哦，没有多余的key</li><li>缺点：实现复杂，可能存在误判</li></ul></li></ol></li></ul><h2 id="二十、缓存雪崩问题及其解决思路"><a href="#二十、缓存雪崩问题及其解决思路" class="headerlink" title="二十、缓存雪崩问题及其解决思路"></a><strong>二十、缓存雪崩问题及其解决思路</strong></h2><ul><li>缓存雪崩是指在同一时间段，大量缓存的key同时失效，或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</li><li>解决方案<ul><li>给不同的Key的TTL添加随机值，让其在不同时间段分批失效</li><li>利用Redis集群提高服务的可用性（使用一个或者多个哨兵(<code>Sentinel</code>)实例组成的系统，对redis节点进行监控，在主节点出现故障的情况下，能将从节点中的一个升级为主节点，进行故障转义，保证系统的可用性。 ）</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存（浏览器访问静态资源时，优先读取浏览器本地缓存；访问非静态资源（ajax查询数据）时，访问服务端；请求到达Nginx后，优先读取Nginx本地缓存；如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）；如果Redis查询未命中，则查询Tomcat；请求进入Tomcat后，优先查询JVM进程缓存；如果JVM进程缓存未命中，则查询数据库）</li></ul></li></ul><h2 id="二十一、缓存击穿问题及解决思路"><a href="#二十一、缓存击穿问题及解决思路" class="headerlink" title="二十一、缓存击穿问题及解决思路"></a><strong>二十一、缓存击穿问题及解决思路</strong></h2><ul><li><p>缓存击穿也叫热点Key问题，就是一个被<code>高并发访问</code>并且<code>缓存重建业务较复杂</code>的key突然失效了，那么无数请求访问就会在瞬间给数据库带来巨大的冲击</p></li><li><p>举个不太恰当的例子：一件秒杀中的商品的key突然失效了，大家都在疯狂抢购，那么这个瞬间就会有无数的请求访问去直接抵达数据库，从而造成缓存击穿</p></li><li><p>常见的解决方案有两种</p><ol><li>互斥锁</li><li>逻辑过期</li></ol></li><li><p><code>逻辑分析</code>：假设线程1在查询缓存之后未命中，本来应该去查询数据库，重建缓存数据，完成这些之后，其他线程也就能从缓存中加载这些数据了。但是在线程1还未执行完毕时，又进来了线程2、3、4同时来访问当前方法，那么这些线程都不能从缓存中查询到数据，那么他们就会在同一时刻访问数据库，执行SQL语句查询，对数据库访问压力过大</p><p><img src="https://pic1.imgdb.cn/item/6354f77716f2c2beb1225032.jpg" alt="img"></p></li><li><p><code>解决方案一</code>：互斥锁</p></li><li><p>利用锁的互斥性，假设线程过来，只能一个人一个人的访问数据库，从而避免对数据库频繁访问产生过大压力，但这也会影响查询的性能，将查询的性能从并行变成了串行，我们可以采用tryLock方法+double check来解决这个问题</p></li><li><p>线程1在操作的时候，拿着锁把房门锁上了，那么线程2、3、4就不能都进来操作数据库，只有1操作完了，把房门打开了，此时缓存数据也重建好了，线程2、3、4直接从redis中就可以查询到数据。</p></li><li><p><code>解决方案二</code>：逻辑过期方案</p></li><li><p>方案分析：我们之所以会出现缓存击穿问题，主要原因是在于我们对key设置了TTL，如果我们不设置TTL，那么就不会有缓存击穿问题，但是不设置TTL，数据又会一直占用我们的内存，所以我们可以采用逻辑过期方案</p></li><li><p>我们之前是TTL设置在redis的value中，注意：这个过期时间并不会直接作用于Redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断当前数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的进程他会开启一个新线程去进行之前的重建缓存数据的逻辑，直到新开的线程完成者逻辑之后，才会释放锁，而线程1直接进行返回，假设现在线程3过来访问，由于线程2拿着锁，所以线程3无法获得锁，线程3也直接返回数据（但只能返回旧数据，牺牲了数据一致性，换取性能上的提高），只有等待线程2重建缓存数据之后，其他线程才能返回正确的数据</p></li><li><p>这种方案巧妙在于，异步构建缓存数据，缺点是在重建完缓存数据之前，返回的都是脏数据</p></li></ul><h2 id="二十二、redis分布式锁的实现核心思路"><a href="#二十二、redis分布式锁的实现核心思路" class="headerlink" title="二十二、redis分布式锁的实现核心思路"></a><strong>二十二、redis分布式锁的实现核心思路</strong></h2><ul><li>我们利用redis的<code>SETNX</code>方法，当有多个线程进入时，我们就利用该方法来获取锁。第一个线程进入时，redis 中就有这个key了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁（返回了0）的线程，等待一定时间之后重试</li><li><img src="C:\Users\lyon\AppData\Roaming\Typora\typora-user-images\image-20250306174646429.png" alt="image-20250306174646429"></li></ul><h2 id="二十三、解决分布式锁误删问题"><a href="#二十三、解决分布式锁误删问题" class="headerlink" title="二十三、解决分布式锁误删问题"></a><strong>二十三、解决分布式锁误删问题</strong></h2><ul><li>满足：在获取锁的时候存入线程标识（用UUID标识，在一个JVM中，ThreadId一般不会重复，但是我们现在是集群模式，有多个JVM，多个JVM之间可能会出现ThreadId重复的情况），在释放锁的时候先获取锁的线程标识，判断是否与当前线程标识一致<ul><li>如果一致则释放锁</li><li>如果不一致则不释放锁</li></ul></li><li>核心逻辑：在存入锁的时候，放入自己的线程标识，在删除锁的时候，判断当前这把锁是不是自己存入的<ul><li>如果是，则进行删除</li><li>如果不是，则不进行删除</li></ul></li></ul><h2 id="二十四、在Mybatis中嵌套查询和嵌套结果的区别"><a href="#二十四、在Mybatis中嵌套查询和嵌套结果的区别" class="headerlink" title="二十四、在Mybatis中嵌套查询和嵌套结果的区别"></a><strong>二十四、在Mybatis中嵌套查询和嵌套结果的区别</strong></h2><p>1.嵌套查询：在一个查询中嵌套另一个查询。</p><p>2.嵌套结果：在一个查询中通过联合查询一次性将主表和关联表的数据查询出来，然后通过结果映射将数据组装成主对象和关联对象的形式。</p><h2 id="二十五、OSI-七层模型是什么？每一层的作用是什么？"><a href="#二十五、OSI-七层模型是什么？每一层的作用是什么？" class="headerlink" title="二十五、OSI 七层模型是什么？每一层的作用是什么？"></a>二十五、OSI 七层模型是什么？每一层的作用是什么？</h2><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p><h2 id="二十六、TCP-IP-四层模型是什么？每一层的作用是什么？"><a href="#二十六、TCP-IP-四层模型是什么？每一层的作用是什么？" class="headerlink" title="二十六、TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？"></a>二十六、TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</h2><p><img src="C:\Users\lyon\AppData\Roaming\Typora\typora-user-images\image-20250308143438846.png" alt="image-20250308143438846"></p><h2 id="二十七、应用层有哪些常见的协议"><a href="#二十七、应用层有哪些常见的协议" class="headerlink" title="二十七、应用层有哪些常见的协议"></a>二十七、应用层有哪些常见的协议</h2><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层常见协议"></p><h2 id="二十八、传输层有哪些协议"><a href="#二十八、传输层有哪些协议" class="headerlink" title="二十八、传输层有哪些协议"></a>二十八、传输层有哪些协议</h2><p>TCP：面向连接，可靠的数据传输服务</p><p>UDP：无连接，尽最大努力（不可靠）的数据传输服务</p><h2 id="二十九、从输入-URL-到页面展示到底发生了什么？"><a href="#二十九、从输入-URL-到页面展示到底发生了什么？" class="headerlink" title="二十九、从输入 URL 到页面展示到底发生了什么？"></a>二十九、从输入 URL 到页面展示到底发生了什么？</h2><p>1.在浏览器输入url </p><p>2.浏览器通过DNS协议，获取域名对应的IP地址</p><p>3.根据IP地址和端口号，向目标服务器发起一个TCP连接请求</p><p>4.浏览器在TCP连接上，向服务器发送一个http请求报文，请求获取网页的内容</p><p>5.服务器在收到http请求报文后，处理请求，并返回http响应报文给浏览器</p><p>6.浏览器收到http响应报文后，解析响应体中的代码，渲染网页结构和样式，同时根据</p><p>html中的其他资源，再次发起Http请求，获取这些资源的内容，直到页面完全加载</p><p>7.浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</p><h2 id="三十、HTTP-和-HTTPS-有什么区别？"><a href="#三十、HTTP-和-HTTPS-有什么区别？" class="headerlink" title="三十、HTTP 和 HTTPS 有什么区别？"></a>三十、HTTP 和 HTTPS 有什么区别？</h2><p>端口号：http默认的端口是80，https默认的是443</p><p>URL前缀：http的url前缀是http:&#x2F;&#x2F;  ,https的url前缀是https:&#x2F;&#x2F;</p><p>安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密。</p><h2 id="三十一、Cookie-和-Session-有什么区别？"><a href="#三十一、Cookie-和-Session-有什么区别？" class="headerlink" title="三十一、Cookie 和 Session 有什么区别？"></a>三十一、Cookie 和 Session 有什么区别？</h2><p><strong><code>Session</code> 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了。</p><p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="三十二、JWT-由哪些部分组成？"><a href="#三十二、JWT-由哪些部分组成？" class="headerlink" title="三十二、JWT 由哪些部分组成？"></a>三十二、JWT 由哪些部分组成？</h2><p>JWT由三部分组成，分为头部，载荷，签名</p><p><strong>Header（头部）</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 <code>Token</code> 的类型。Header 被 Base64Url 编码后成为 JWT 的第一部分。</p><p><strong>Payload（载荷）</strong> : 用来存放实际需要传递的数据，包含声明（Claims），如<code>sub</code>（subject，主题）、<code>jti</code>（JWT ID）。Payload 被 Base64Url 编码后成为 JWT 的第二部分。</p><p><strong>Signature（签名）</strong>：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。生成的签名会成为 JWT 的第三部分。</p><h2 id="三十二、什么是TCP的粘包、拆包"><a href="#三十二、什么是TCP的粘包、拆包" class="headerlink" title="三十二、什么是TCP的粘包、拆包"></a>三十二、什么是TCP的粘包、拆包</h2><p>粘包：粘包指的是在发送端将多个小数据包连续发送，而接收端却可能一次性接收到了多个小数据包，这些数据包“粘”在一起，无法准确分辨出每个数据包的界限。</p><p>拆包：拆包指的是在发送端将一个大数据包分割成多个小数据包发送，而接收端却可能无法正确地将这些小数据包组合成完整的大数据包。</p><h2 id="三十三、什么是TCP三次握手、四次挥手？"><a href="#三十三、什么是TCP三次握手、四次挥手？" class="headerlink" title="三十三、什么是TCP三次握手、四次挥手？"></a>三十三、什么是TCP三次握手、四次挥手？</h2><p>TCP三次握手：</p><p>TCP三次握手是在建立TCP连接时使用的一种协议，用于确保客户端和服务器之间的通信能够稳定地开始。这个过程涉及三个步骤：</p><p>第一步：客户端向服务器发送一个带有SYN（同步）标志的数据包，请求建立连接。</p><p>第二步：服务器收到客户端的请求后，会发送一个带有SYN和ACK(确认)标志的数据包，表示同意建立连接</p><p>第三步：客户端收到服务器的响应后，发送一个带有ACK标志的数据包给服务器，确认连接已经建立。双方都进入已建立连接的状态，可以开始进行数据传输。</p><p>TCP四次挥手：</p><p>TCP四次挥手是在关闭TCP连接时使用的一种协议，用于确保双方能够安全地终止连接。这个过程涉及四个步骤：</p><p>第一步：一方向另一方发送一个带有FIN标志的数据包，表示希望关闭连接。</p><p>第二步：接收方收到关闭请求后，发送一个带有ACK标志的数据包作为确认。</p><p>第三步：接收方准备好关闭连接时，会发送一个带有FIN标志的数据包，表示同意关闭连接。</p><p>第四步：发送方收到接收方的关闭确认后，发送一个带有ACK标志的数据包作为确认。双方都进入连接已关闭状态</p><p>这四步挥手过程确保双方都完成了数据传输，并且同意关闭连接，避免了数据丢失或不完整的情况。</p><p>总之，TCP三次握手和四次挥手是确保通信的可靠性和完整性的重要步骤，分别用于建立和关闭TCP连接。</p><h2 id="三十四、MySQL事务的基本特性和隔离级别"><a href="#三十四、MySQL事务的基本特性和隔离级别" class="headerlink" title="三十四、MySQL事务的基本特性和隔离级别"></a>三十四、MySQL事务的基本特性和隔离级别</h2><p>事务基本特性ACID分别是：</p><p><strong>原子性</strong>:指的是一个事务中的操作要么全部成功，要么全部失败。</p><p><strong>一致性:</strong> 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如A转账给B100块钱，假设A只有90块，支付之前我们数据库里的数据都是符合约束的,但是如果事务执行成功了,我们的数据库数据就破坏约束了,因此事务不能成功,这里我们说事务提供了一致性的保证。</p><p><strong>隔离性</strong>:指的是一个事务的修改在最终提交前，对其他事务是不可见的。</p><p><strong>持久性</strong>：指的是一旦事务提交，所做的修改就会永久保存到数据库中。</p><p>隔离性有4个隔离级别，分别是：</p><p><strong>read uncommit</strong> 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。<br>用户本来应该读取到id&#x3D;1的用户age应该是10，结果读取到了其他事务还没有提交的事务，结果读取结果age&#x3D;20，这就是脏读。</p><p>**read commit **读已提交，两次读取结果不一致，叫做不可重复读。<br>不可重复读解决了脏读的问题，他只会读取已经提交的事务。<br>用户开启事务读取id&#x3D;1用户，查询到age&#x3D;10，再次读取发现结果&#x3D;20，在同一个事务里同一个查询读取到不同的结果叫做不可重复读。</p><p>**repeatable read **可重复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。</p><p>**serializable **串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争<br>的问题。</p><p><strong>脏读</strong>(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。<br><strong>不可重复读</strong>(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。<br><strong>幻读</strong>(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p><h2 id="三十五、-SpringMVC-工作原理了解吗"><a href="#三十五、-SpringMVC-工作原理了解吗" class="headerlink" title="三十五、 SpringMVC 工作原理了解吗?"></a>三十五、 SpringMVC 工作原理了解吗?</h2><p><strong>流程说明（重要）：</strong></p><p>1)  用户发送请求至前端控制器 DispatcherServlet。<br>2）DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。<br>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进行查找)，生成处理器及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。<br>4）DispatcherServlet 调用 HandlerAdapter 处理器适配器。<br>5）HandlerAdapter 经过适配调用具体的处理器(Controller，也叫后端控制器)<br>6）Controller 执行完成返回 ModelAndView。<br>7）HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet。</p><p>8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。<br>9）ViewReslover 解析后返回具体 View。<br>10）DispatcherServlet 根据 View 进行渲染视图（即将模型数据填充至视图中）。<br>11）DispatcherServlet 响应用户。</p><h2 id="三十六、说说List-Set-Map-Queue四者的区别？"><a href="#三十六、说说List-Set-Map-Queue四者的区别？" class="headerlink" title="三十六、说说List,Set,Map,Queue四者的区别？"></a>三十六、说说List,Set,Map,Queue四者的区别？</h2><p><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</p><p><code>Set</code>(注重独一无二的性质): 存储的元素不可重复的。（TreeSet是有序，底层是红黑树）</p><p><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</p><p><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/03/24/hello-world/"/>
      <url>/2025/03/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
